"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(rsc)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(rsc)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(rsc)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(rsc)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(rsc)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PlatformLoggerServiceImpl {\n    constructor(container){\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers.map((provider)=>{\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            } else {\n                return null;\n            }\n        }).filter((logString)=>logString).join(\" \");\n    }\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */ function isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */ ;\n}\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.9.13\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/app\");\nconst name$n = \"@firebase/app-compat\";\nconst name$m = \"@firebase/analytics-compat\";\nconst name$l = \"@firebase/analytics\";\nconst name$k = \"@firebase/app-check-compat\";\nconst name$j = \"@firebase/app-check\";\nconst name$i = \"@firebase/auth\";\nconst name$h = \"@firebase/auth-compat\";\nconst name$g = \"@firebase/database\";\nconst name$f = \"@firebase/database-compat\";\nconst name$e = \"@firebase/functions\";\nconst name$d = \"@firebase/functions-compat\";\nconst name$c = \"@firebase/installations\";\nconst name$b = \"@firebase/installations-compat\";\nconst name$a = \"@firebase/messaging\";\nconst name$9 = \"@firebase/messaging-compat\";\nconst name$8 = \"@firebase/performance\";\nconst name$7 = \"@firebase/performance-compat\";\nconst name$6 = \"@firebase/remote-config\";\nconst name$5 = \"@firebase/remote-config-compat\";\nconst name$4 = \"@firebase/storage\";\nconst name$3 = \"@firebase/storage-compat\";\nconst name$2 = \"@firebase/firestore\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"9.23.0\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The default app name\r\n *\r\n * @internal\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nconst PLATFORM_LOG_STRING = {\n    [name$o]: \"fire-core\",\n    [name$n]: \"fire-core-compat\",\n    [name$l]: \"fire-analytics\",\n    [name$m]: \"fire-analytics-compat\",\n    [name$j]: \"fire-app-check\",\n    [name$k]: \"fire-app-check-compat\",\n    [name$i]: \"fire-auth\",\n    [name$h]: \"fire-auth-compat\",\n    [name$g]: \"fire-rtdb\",\n    [name$f]: \"fire-rtdb-compat\",\n    [name$e]: \"fire-fn\",\n    [name$d]: \"fire-fn-compat\",\n    [name$c]: \"fire-iid\",\n    [name$b]: \"fire-iid-compat\",\n    [name$a]: \"fire-fcm\",\n    [name$9]: \"fire-fcm-compat\",\n    [name$8]: \"fire-perf\",\n    [name$7]: \"fire-perf-compat\",\n    [name$6]: \"fire-rc\",\n    [name$5]: \"fire-rc-compat\",\n    [name$4]: \"fire-gcs\",\n    [name$3]: \"fire-gcs-compat\",\n    [name$2]: \"fire-fst\",\n    [name$1]: \"fire-fst-compat\",\n    \"fire-js\": \"fire-js\",\n    [name]: \"fire-js-all\"\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ const _apps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */ function _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    } catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\r\n *\r\n * @internal\r\n */ function _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */ function _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()){\n        _addComponent(app, component);\n    }\n    return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */ function _getProvider(app, name) {\n    const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({\n        optional: true\n    });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */ function _clearComponents() {\n    _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call initializeApp() first\",\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */ ]: \"Illegal App name: '{$appName}\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */ ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */ ]: \"Firebase App named '{$appName}' already deleted\",\n    [\"no-options\" /* AppError.NO_OPTIONS */ ]: \"Need to provide options, when not being deployed to hosting via source.\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\",\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ ]: \"First argument to `onLog` must be null or a function.\",\n    [\"idb-open\" /* AppError.IDB_OPEN */ ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-get\" /* AppError.IDB_GET */ ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-set\" /* AppError.IDB_WRITE */ ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-delete\" /* AppError.IDB_DELETE */ ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"app\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseAppImpl {\n    constructor(options, config, container){\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"app\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */ , {\n                appName: this._name\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */ const SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== \"object\") {\n        const name = rawConfig;\n        rawConfig = {\n            name\n        };\n    }\n    const config = Object.assign({\n        name: DEFAULT_ENTRY_NAME,\n        automaticDataCollectionEnabled: false\n    }, rawConfig);\n    const name = config.name;\n    if (typeof name !== \"string\" || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */ , {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */ );\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        } else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */ , {\n                appName: name\n            });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */ function getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n            appName: name\n        });\n    }\n    return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */ function getApps() {\n    return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */ async function deleteApp(app) {\n    const name = app.name;\n    if (_apps.has(name)) {\n        _apps.delete(name);\n        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */ function registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push(\"and\");\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(\" \"));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, ()=>({\n            library,\n            version\n        }), \"VERSION\" /* ComponentType.VERSION */ ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */ function onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== \"function\") {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ );\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DB_NAME = \"firebase-heartbeat-database\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"firebase-heartbeat-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        db.createObjectStore(STORE_NAME);\n                }\n            }\n        }).catch((e)=>{\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */ , {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const result = await db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));\n        return result;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, \"readwrite\");\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container){\n        this.container = container;\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */ this._heartbeatsCache = null;\n        const app = this.container.getProvider(\"app\").getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then((result)=>{\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */ async triggerHeartbeat() {\n        const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n        // This is the \"Firebase user agent\" string from the platform logger\n        // service, not the browser user agent.\n        const agent = platformLogger.getPlatformInfoString();\n        const date = getUTCDateString();\n        if (this._heartbeatsCache === null) {\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\n        }\n        // Do not store a heartbeat if one is already stored for this day\n        // or if a header has already been sent today.\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) {\n            return;\n        } else {\n            // There is no entry for this date. Create one.\n            this._heartbeatsCache.heartbeats.push({\n                date,\n                agent\n            });\n        }\n        // Remove entries older than 30 days.\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n            const now = Date.now();\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n        });\n        return this._storage.overwrite(this._heartbeatsCache);\n    }\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */ async getHeartbeatsHeader() {\n        if (this._heartbeatsCache === null) {\n            await this._heartbeatsCachePromise;\n        }\n        // If it's still null or the array is empty, there is no data to send.\n        if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {\n            return \"\";\n        }\n        const date = getUTCDateString();\n        // Extract as many heartbeats from the cache as will fit under the size limit.\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n            version: 2,\n            heartbeats: heartbeatsToSend\n        }));\n        // Store last sent date to prevent another being logged/sent for the same day.\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\n        if (unsentEntries.length > 0) {\n            // Store any unsent entries if they exist.\n            this._heartbeatsCache.heartbeats = unsentEntries;\n            // This seems more likely than emptying the array (below) to lead to some odd state\n            // since the cache isn't empty and this will be called again on the next request,\n            // and is probably safest if we await it.\n            await this._storage.overwrite(this._heartbeatsCache);\n        } else {\n            this._heartbeatsCache.heartbeats = [];\n            // Do not wait for this, to reduce latency.\n            void this._storage.overwrite(this._heartbeatsCache);\n        }\n        return headerString;\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache){\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [\n                    singleDateHeartbeat.date\n                ]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        } else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app){\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(()=>true).catch(()=>false);\n        }\n    }\n    /**\r\n     * Read all heartbeats.\r\n     */ async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return {\n                heartbeats: []\n            };\n        } else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            return idbHeartbeatObject || {\n                heartbeats: []\n            };\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */ function countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(// heartbeatsCache wrapper properties\n    JSON.stringify({\n        version: 2,\n        heartbeats: heartbeatsCache\n    })).length;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"platform-logger\", (container)=>new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"heartbeat\", (container)=>new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    // Register `app` package.\n    registerVersion(name$o, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    registerVersion(name$o, version$1, \"esm2017\");\n    // Register platform SDK identifier (no version).\n    registerVersion(\"fire-js\", \"\");\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */ registerCoreComponents(\"\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdUI7QUFDa0Y7QUFDOUg7QUFDbEI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTWM7SUFDRkMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNyQjtJQUNBLHFFQUFxRTtJQUNyRSwrREFBK0Q7SUFDL0RDLHdCQUF3QjtRQUNwQixNQUFNQyxZQUFZLElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxZQUFZO1FBQzdDLHlFQUF5RTtRQUN6RSxzQkFBc0I7UUFDdEIsT0FBT0QsVUFDRkUsR0FBRyxDQUFDQyxDQUFBQTtZQUNMLElBQUlDLHlCQUF5QkQsV0FBVztnQkFDcEMsTUFBTUUsVUFBVUYsU0FBU0csWUFBWTtnQkFDckMsT0FBTyxDQUFDLEVBQUVELFFBQVFFLE9BQU8sQ0FBQyxDQUFDLEVBQUVGLFFBQVFHLE9BQU8sQ0FBQyxDQUFDO1lBQ2xELE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osR0FDS0MsTUFBTSxDQUFDQyxDQUFBQSxZQUFhQSxXQUNwQkMsSUFBSSxDQUFDO0lBQ2Q7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTUCx5QkFBeUJELFFBQVE7SUFDdEMsTUFBTVMsWUFBWVQsU0FBU1UsWUFBWTtJQUN2QyxPQUFPLENBQUNELGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRSxJQUFJLE1BQU0sVUFBVSx5QkFBeUI7QUFDekg7QUFFQSxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsWUFBWTtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyxTQUFTLElBQUlqQyxvREFBTUEsQ0FBQztBQUUxQixNQUFNa0MsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FB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Ozs7OztDQUtDLEdBQ0RzRix1QkFBdUI7QUFFb1EsQ0FDM1IseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFteWVlbWFuLmNvbS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/NzJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIEZpcmViYXNlRXJyb3IsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmV4cG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgLy8gSW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBieSBpbnN0YWxsYXRpb25zIG9uXHJcbiAgICAvLyBhdXRoIHRva2VuIHJlZnJlc2gsIGFuZCBpbnN0YWxsYXRpb25zIHdpbGwgc2VuZCB0aGlzIHN0cmluZy5cclxuICAgIGdldFBsYXRmb3JtSW5mb1N0cmluZygpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcnMoKTtcclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggcHJvdmlkZXJzIGFuZCBnZXQgbGlicmFyeS92ZXJzaW9uIHBhaXJzIGZyb20gYW55IHRoYXQgYXJlXHJcbiAgICAgICAgLy8gdmVyc2lvbiBjb21wb25lbnRzLlxyXG4gICAgICAgIHJldHVybiBwcm92aWRlcnNcclxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2VydmljZS5saWJyYXJ5fS8ke3NlcnZpY2UudmVyc2lvbn1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGxvZ1N0cmluZyA9PiBsb2dTdHJpbmcpXHJcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBwcm92aWRlciBjaGVjayBpZiB0aGlzIHByb3ZpZGVyIHByb3ZpZGVzIGEgVmVyc2lvblNlcnZpY2VcclxuICpcclxuICogTk9URTogVXNpbmcgUHJvdmlkZXI8J2FwcC12ZXJzaW9uJz4gaXMgYSBoYWNrIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3ZpZGVyXHJcbiAqIHByb3ZpZGVzIFZlcnNpb25TZXJ2aWNlLiBUaGUgcHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyaWx5IGEgJ2FwcC12ZXJzaW9uJ1xyXG4gKiBwcm92aWRlci5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikge1xyXG4gICAgY29uc3QgY29tcG9uZW50ID0gcHJvdmlkZXIuZ2V0Q29tcG9uZW50KCk7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudC50eXBlKSA9PT0gXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovO1xyXG59XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FwcFwiO1xuY29uc3QgdmVyc2lvbiQxID0gXCIwLjkuMTNcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcCcpO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hcHAtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FuYWx5dGljcy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzXCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2FwcC1jaGVjay1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrXCI7XG5cbmNvbnN0IG5hbWUkaSA9IFwiQGZpcmViYXNlL2F1dGhcIjtcblxuY29uc3QgbmFtZSRoID0gXCJAZmlyZWJhc2UvYXV0aC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRnID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcblxuY29uc3QgbmFtZSRmID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnNcIjtcblxuY29uc3QgbmFtZSRiID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRhID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nXCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ4ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2VcIjtcblxuY29uc3QgbmFtZSQ3ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWdcIjtcblxuY29uc3QgbmFtZSQ1ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBuYW1lJDMgPSBcIkBmaXJlYmFzZS9zdG9yYWdlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDIgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiOS4yMy4wXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xyXG5jb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xyXG4gICAgW25hbWUkb106ICdmaXJlLWNvcmUnLFxyXG4gICAgW25hbWUkbl06ICdmaXJlLWNvcmUtY29tcGF0JyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hbmFseXRpY3MnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWFwcC1jaGVjaycsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRpXTogJ2ZpcmUtYXV0aCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxyXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGInLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLXJ0ZGItY29tcGF0JyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbicsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtZm4tY29tcGF0JyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQnLFxyXG4gICAgW25hbWUkYl06ICdmaXJlLWlpZC1jb21wYXQnLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbScsXHJcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtZmNtLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ4XTogJ2ZpcmUtcGVyZicsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjJyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1yYy1jb21wYXQnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcycsXHJcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtZnN0JyxcclxuICAgIFtuYW1lJDFdOiAnZmlyZS1mc3QtY29tcGF0JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogUmVnaXN0ZXJlZCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmNvbnN0IF9jb21wb25lbnRzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfYWRkQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGFwcC5jb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZhaWxlZCB0byByZWdpc3RlciB3aXRoIEZpcmViYXNlQXBwICR7YXBwLm5hbWV9YCwgZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KSB7XHJcbiAgICBhcHAuY29udGFpbmVyLmFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XHJcbiAgICBpZiAoX2NvbXBvbmVudHMuaGFzKGNvbXBvbmVudE5hbWUpKSB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGVyZSB3ZXJlIG11bHRpcGxlIGF0dGVtcHRzIHRvIHJlZ2lzdGVyIGNvbXBvbmVudCAke2NvbXBvbmVudE5hbWV9LmApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9jb21wb25lbnRzLnNldChjb21wb25lbnROYW1lLCBjb21wb25lbnQpO1xyXG4gICAgLy8gYWRkIHRoZSBjb21wb25lbnQgdG8gZXhpc3RpbmcgYXBwIGluc3RhbmNlc1xyXG4gICAgZm9yIChjb25zdCBhcHAgb2YgX2FwcHMudmFsdWVzKCkpIHtcclxuICAgICAgICBfYWRkQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcclxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcclxuICpcclxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkge1xyXG4gICAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IGFwcC5jb250YWluZXJcclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXHJcbiAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcclxuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcC5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0IG9ubHlcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xyXG4gICAgX2NvbXBvbmVudHMuY2xlYXIoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBFUlJPUlMgPSB7XHJcbiAgICBbXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi9dOiBcIk5vIEZpcmViYXNlIEFwcCAneyRhcHBOYW1lfScgaGFzIGJlZW4gY3JlYXRlZCAtIFwiICtcclxuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxyXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfVwiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqL106ICdOZWVkIHRvIHByb3ZpZGUgb3B0aW9ucywgd2hlbiBub3QgYmVpbmcgZGVwbG95ZWQgdG8gaG9zdGluZyB2aWEgc291cmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcclxuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovXTogJ0ZpcnN0IGFyZ3VtZW50IHRvIGBvbkxvZ2AgbXVzdCBiZSBudWxsIG9yIGEgZnVuY3Rpb24uJyxcclxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIHdyaXRpbmcgdG8gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJ1xyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XHJcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhcHAnLCAoKSA9PiB0aGlzLCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcclxuICAgIH1cclxuICAgIGdldCBjb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcclxuICAgIH1cclxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBjdXJyZW50IFNESyB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBTREtfVkVSU0lPTiA9IHZlcnNpb247XHJcbmZ1bmN0aW9uIGluaXRpYWxpemVBcHAoX29wdGlvbnMsIHJhd0NvbmZpZyA9IHt9KSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgaWYgKHR5cGVvZiByYXdDb25maWcgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcclxuICAgICAgICByYXdDb25maWcgPSB7IG5hbWUgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBERUZBVUxUX0VOVFJZX05BTUUsIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UgfSwgcmF3Q29uZmlnKTtcclxuICAgIGNvbnN0IG5hbWUgPSBjb25maWcubmFtZTtcclxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgIW5hbWUpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqLywge1xyXG4gICAgICAgICAgICBhcHBOYW1lOiBTdHJpbmcobmFtZSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSBnZXREZWZhdWx0QXBwQ29uZmlnKCkpO1xyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9hcHBzLmdldChuYW1lKTtcclxuICAgIGlmIChleGlzdGluZ0FwcCkge1xyXG4gICAgICAgIC8vIHJldHVybiB0aGUgZXhpc3RpbmcgYXBwIGlmIG9wdGlvbnMgYW5kIGNvbmZpZyBkZWVwIGVxdWFsIHRoZSBvbmVzIGluIHRoZSBleGlzdGluZyBhcHAuXHJcbiAgICAgICAgaWYgKGRlZXBFcXVhbChvcHRpb25zLCBleGlzdGluZ0FwcC5vcHRpb25zKSAmJlxyXG4gICAgICAgICAgICBkZWVwRXF1YWwoY29uZmlnLCBleGlzdGluZ0FwcC5jb25maWcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWUpO1xyXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VBcHBJbXBsKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xyXG4gICAgcmV0dXJuIG5ld0FwcDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXHJcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cclxuICogaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxyXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXHJcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcclxuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxyXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHA7XHJcbn1cclxuLyoqXHJcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogZGVsZXRlQXBwKGFwcClcclxuICogICAudGhlbihmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gKiAgIH0pXHJcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xyXG4gICAgY29uc3QgbmFtZSA9IGFwcC5uYW1lO1xyXG4gICAgaWYgKF9hcHBzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgIF9hcHBzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XHJcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXHJcbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcclxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxyXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xyXG4gICAgaWYgKHZhcmlhbnQpIHtcclxuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXHJcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItb3BlblwiIC8qIEFwcEVycm9yLklEQl9PUEVOICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIoYXBwKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGJcclxuICAgICAgICAgICAgLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpXHJcbiAgICAgICAgICAgIC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxyXG4gICAgICAgICAgICAuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxyXG4gICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9PT0gZGF0ZSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5wdXNoKHsgZGF0ZSwgYWdlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxyXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxyXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XHJcbiAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcclxuICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xyXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XHJcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cclxuICAgIC8vIHRoZSBoZWFkZXIuXHJcbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XHJcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cclxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XHJcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcclxuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxyXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdCB8fCB7IGhlYXJ0YmVhdHM6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3ZlcndyaXRlIHRoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIG92ZXJ3cml0ZShoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgYWRkKGhlYXJ0YmVhdHNPYmplY3QpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBieXRlcyBvZiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBhcnJheSBhZnRlciBiZWluZyB3cmFwcGVkXHJcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXHJcbiAqIHRvIGJhc2UgNjQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3VudEJ5dGVzKGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgLy8gYmFzZTY0IGhhcyBhIHJlc3RyaWN0ZWQgc2V0IG9mIGNoYXJhY3RlcnMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgMSBieXRlLlxyXG4gICAgcmV0dXJuIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxyXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xyXG4gICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzQ2FjaGUgfSkpLmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdwbGF0Zm9ybS1sb2dnZXInLCBjb250YWluZXIgPT4gbmV3IFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIC8vIFJlZ2lzdGVyIGBhcHBgIHBhY2thZ2UuXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcclxuICAgIC8vIFJlZ2lzdGVyIHBsYXRmb3JtIFNESyBpZGVudGlmaWVyIChubyB2ZXJzaW9uKS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcclxufVxuXG4vKipcclxuICogRmlyZWJhc2UgQXBwXHJcbiAqXHJcbiAqIEByZW1hcmtzIFRoaXMgcGFja2FnZSBjb29yZGluYXRlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgRmlyZWJhc2UgY29tcG9uZW50c1xyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcbnJlZ2lzdGVyQ29yZUNvbXBvbmVudHMoJycpO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiwgREVGQVVMVF9FTlRSWV9OQU1FIGFzIF9ERUZBVUxUX0VOVFJZX05BTUUsIF9hZGRDb21wb25lbnQsIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudCwgX2FwcHMsIF9jbGVhckNvbXBvbmVudHMsIF9jb21wb25lbnRzLCBfZ2V0UHJvdmlkZXIsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgZGVsZXRlQXBwLCBnZXRBcHAsIGdldEFwcHMsIGluaXRpYWxpemVBcHAsIG9uTG9nLCByZWdpc3RlclZlcnNpb24sIHNldExvZ0xldmVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkNvbXBvbmVudENvbnRhaW5lciIsIkxvZ2dlciIsInNldFVzZXJMb2dIYW5kbGVyIiwic2V0TG9nTGV2ZWwiLCJzZXRMb2dMZXZlbCQxIiwiRXJyb3JGYWN0b3J5IiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImRlZXBFcXVhbCIsIkZpcmViYXNlRXJyb3IiLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsImlzSW5kZXhlZERCQXZhaWxhYmxlIiwidmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSIsIm9wZW5EQiIsIlBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwiLCJjb25zdHJ1Y3RvciIsImNvbnRhaW5lciIsImdldFBsYXRmb3JtSW5mb1N0cmluZyIsInByb3ZpZGVycyIsImdldFByb3ZpZGVycyIsIm1hcCIsInByb3ZpZGVyIiwiaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyIiwic2VydmljZSIsImdldEltbWVkaWF0ZSIsImxpYnJhcnkiLCJ2ZXJzaW9uIiwiZmlsdGVyIiwibG9nU3RyaW5nIiwiam9pbiIsImNvbXBvbmVudCIsImdldENvbXBvbmVudCIsInR5cGUiLCJuYW1lJG8iLCJ2ZXJzaW9uJDEiLCJsb2dnZXIiLCJuYW1lJG4iLCJuYW1lJG0iLCJuYW1lJGwiLCJuYW1lJGsiLCJuYW1lJGoiLCJuYW1lJGkiLCJuYW1lJGgiLCJuYW1lJGciLCJuYW1lJGYiLCJuYW1lJGUiLCJuYW1lJGQiLCJuYW1lJGMiLCJuYW1lJGIiLCJuYW1lJGEiLCJuYW1lJDkiLCJuYW1lJDgiLCJuYW1lJDciLCJuYW1lJDYiLCJuYW1lJDUiLCJuYW1lJDQiLCJuYW1lJDMiLCJuYW1lJDIiLCJuYW1lJDEiLCJuYW1lIiwiREVGQVVMVF9FTlRSWV9OQU1FIiwiUExBVEZPUk1fTE9HX1NUUklORyIsIl9hcHBzIiwiTWFwIiwiX2NvbXBvbmVudHMiLCJfYWRkQ29tcG9uZW50IiwiYXBwIiwiYWRkQ29tcG9uZW50IiwiZSIsImRlYnVnIiwiX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJjb21wb25lbnROYW1lIiwiaGFzIiwic2V0IiwidmFsdWVzIiwiX2dldFByb3ZpZGVyIiwiaGVhcnRiZWF0Q29udHJvbGxlciIsImdldFByb3ZpZGVyIiwib3B0aW9uYWwiLCJ0cmlnZ2VySGVhcnRiZWF0IiwiX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSIsImluc3RhbmNlSWRlbnRpZmllciIsImNsZWFySW5zdGFuY2UiLCJfY2xlYXJDb21wb25lbnRzIiwiY2xlYXIiLCJFUlJPUlMiLCJFUlJPUl9GQUNUT1JZIiwiRmlyZWJhc2VBcHBJbXBsIiwib3B0aW9ucyIsImNvbmZpZyIsIl9pc0RlbGV0ZWQiLCJfb3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIl9jb25maWciLCJfbmFtZSIsIl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJfY29udGFpbmVyIiwiY2hlY2tEZXN0cm95ZWQiLCJ2YWwiLCJpc0RlbGV0ZWQiLCJjcmVhdGUiLCJhcHBOYW1lIiwiU0RLX1ZFUlNJT04iLCJpbml0aWFsaXplQXBwIiwicmF3Q29uZmlnIiwiU3RyaW5nIiwiZXhpc3RpbmdBcHAiLCJnZXQiLCJuZXdBcHAiLCJnZXRBcHAiLCJnZXRBcHBzIiwiQXJyYXkiLCJmcm9tIiwiZGVsZXRlQXBwIiwiZGVsZXRlIiwiUHJvbWlzZSIsImFsbCIsInJlZ2lzdGVyVmVyc2lvbiIsImxpYnJhcnlLZXlPck5hbWUiLCJ2YXJpYW50IiwiX2EiLCJsaWJyYXJ5TWlzbWF0Y2giLCJtYXRjaCIsInZlcnNpb25NaXNtYXRjaCIsIndhcm5pbmciLCJwdXNoIiwid2FybiIsIm9uTG9nIiwibG9nQ2FsbGJhY2siLCJsb2dMZXZlbCIsIkRCX05BTUUiLCJEQl9WRVJTSU9OIiwiU1RPUkVfTkFNRSIsImRiUHJvbWlzZSIsImdldERiUHJvbWlzZSIsInVwZ3JhZGUiLCJkYiIsIm9sZFZlcnNpb24iLCJjcmVhdGVPYmplY3RTdG9yZSIsImNhdGNoIiwib3JpZ2luYWxFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwicmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCIiwicmVzdWx0IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsImNvbXB1dGVLZXkiLCJpZGJHZXRFcnJvciIsIndyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCIiwiaGVhcnRiZWF0T2JqZWN0IiwidHgiLCJwdXQiLCJkb25lIiwiYXBwSWQiLCJNQVhfSEVBREVSX0JZVEVTIiwiU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyIsIkhlYXJ0YmVhdFNlcnZpY2VJbXBsIiwiX2hlYXJ0YmVhdHNDYWNoZSIsIl9zdG9yYWdlIiwiSGVhcnRiZWF0U3RvcmFnZUltcGwiLCJfaGVhcnRiZWF0c0NhY2hlUHJvbWlzZSIsInJlYWQiLCJ0aGVuIiwicGxhdGZvcm1Mb2dnZXIiLCJhZ2VudCIsImRhdGUiLCJnZXRVVENEYXRlU3RyaW5nIiwibGFzdFNlbnRIZWFydGJlYXREYXRlIiwiaGVhcnRiZWF0cyIsInNvbWUiLCJzaW5nbGVEYXRlSGVhcnRiZWF0IiwiaGJUaW1lc3RhbXAiLCJEYXRlIiwidmFsdWVPZiIsIm5vdyIsIm92ZXJ3cml0ZSIsImdldEhlYXJ0YmVhdHNIZWFkZXIiLCJsZW5ndGgiLCJoZWFydGJlYXRzVG9TZW5kIiwidW5zZW50RW50cmllcyIsImV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyIiwiaGVhZGVyU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvZGF5IiwidG9JU09TdHJpbmciLCJzdWJzdHJpbmciLCJoZWFydGJlYXRzQ2FjaGUiLCJtYXhTaXplIiwic2xpY2UiLCJoZWFydGJlYXRFbnRyeSIsImZpbmQiLCJoYiIsImRhdGVzIiwiY291bnRCeXRlcyIsInBvcCIsIl9jYW5Vc2VJbmRleGVkREJQcm9taXNlIiwicnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjayIsImNhblVzZUluZGV4ZWREQiIsImlkYkhlYXJ0YmVhdE9iamVjdCIsImhlYXJ0YmVhdHNPYmplY3QiLCJleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QiLCJhZGQiLCJyZWdpc3RlckNvcmVDb21wb25lbnRzIiwiX0RFRkFVTFRfRU5UUllfTkFNRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(rsc)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */ class Component {\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */ constructor(name, instanceFactory, type){\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\r\n         * Properties to be added to the service namespace\r\n         */ this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */ ;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */ class Provider {\n    constructor(name, container){\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */ get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                } catch (e) {\n                // when the instance factory throws an exception during get(), it should not cause\n                // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            } catch (e) {\n                if (optional) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            } else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({\n                    instanceIdentifier: DEFAULT_ENTRY_NAME\n                });\n            } catch (e) {\n            // when the instance factory for an eager Component throws an exception during the eager\n            // initialization, it should not cause a fatal error.\n            // TODO: Investigate if we need to make it configurable, because some component may want to cause\n            // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services.filter((service)=>\"INTERNAL\" in service) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service.INTERNAL.delete()),\n            ...services.filter((service)=>\"_delete\" in service) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */ onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return ()=>{\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */ invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks){\n            try {\n                callback(instance, identifier);\n            } catch (_a) {\n            // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */ if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                } catch (_a) {\n                // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        } else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ;\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */ ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */ class ComponentContainer {\n    constructor(name){\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */ addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */ getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFFMUM7O0NBRUMsR0FDRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0RDLFlBQVlDLElBQUksRUFBRUMsZUFBZSxFQUFFQyxJQUFJLENBQUU7UUFDckMsSUFBSSxDQUFDRixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsT0FBTywwQkFBMEI7UUFDMUQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBQyxxQkFBcUJDLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNILGlCQUFpQixHQUFHRztRQUN6QixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJOLGlCQUFpQixFQUFFO1FBQ3BDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FPLGdCQUFnQkMsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ1AsWUFBWSxHQUFHTztRQUNwQixPQUFPLElBQUk7SUFDZjtJQUNBQywyQkFBMkJDLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUNQLGlCQUFpQixHQUFHTztRQUN6QixPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMscUJBQXFCO0FBRTNCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0ZoQixZQUFZQyxJQUFJLEVBQUVnQixTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2dC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T0FBT0E7SUFDWDtJQUNBRyxlQUFlO1FBQ1gsT0FBTzlCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN3QixTQUFTLENBQUN2QixNQUFNO0lBQzNDO0FBQ0o7QUFFbUQsQ0FDbkQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFteWVlbWFuLmNvbS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/MjQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJEZWZlcnJlZCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImluc3RhbmNlRmFjdG9yeSIsInR5cGUiLCJtdWx0aXBsZUluc3RhbmNlcyIsInNlcnZpY2VQcm9wcyIsImluc3RhbnRpYXRpb25Nb2RlIiwib25JbnN0YW5jZUNyZWF0ZWQiLCJzZXRJbnN0YW50aWF0aW9uTW9kZSIsIm1vZGUiLCJzZXRNdWx0aXBsZUluc3RhbmNlcyIsInNldFNlcnZpY2VQcm9wcyIsInByb3BzIiwic2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2siLCJjYWxsYmFjayIsIkRFRkFVTFRfRU5UUllfTkFNRSIsIlByb3ZpZGVyIiwiY29udGFpbmVyIiwiY29tcG9uZW50IiwiaW5zdGFuY2VzIiwiTWFwIiwiaW5zdGFuY2VzRGVmZXJyZWQiLCJpbnN0YW5jZXNPcHRpb25zIiwib25Jbml0Q2FsbGJhY2tzIiwiZ2V0IiwiaWRlbnRpZmllciIsIm5vcm1hbGl6ZWRJZGVudGlmaWVyIiwibm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyIiwiaGFzIiwiZGVmZXJyZWQiLCJzZXQiLCJpc0luaXRpYWxpemVkIiwic2hvdWxkQXV0b0luaXRpYWxpemUiLCJpbnN0YW5jZSIsImdldE9ySW5pdGlhbGl6ZVNlcnZpY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJyZXNvbHZlIiwiZSIsInByb21pc2UiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25zIiwiX2EiLCJvcHRpb25hbCIsIkVycm9yIiwiZ2V0Q29tcG9uZW50Iiwic2V0Q29tcG9uZW50IiwiaXNDb21wb25lbnRFYWdlciIsImluc3RhbmNlRGVmZXJyZWQiLCJlbnRyaWVzIiwiY2xlYXJJbnN0YW5jZSIsImRlbGV0ZSIsInNlcnZpY2VzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiUHJvbWlzZSIsImFsbCIsImZpbHRlciIsInNlcnZpY2UiLCJtYXAiLCJJTlRFUk5BTCIsIl9kZWxldGUiLCJpc0NvbXBvbmVudFNldCIsImdldE9wdGlvbnMiLCJpbml0aWFsaXplIiwib3B0cyIsIm5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIiLCJvbkluaXQiLCJleGlzdGluZ0NhbGxiYWNrcyIsIlNldCIsImFkZCIsImV4aXN0aW5nSW5zdGFuY2UiLCJpbnZva2VPbkluaXRDYWxsYmFja3MiLCJjYWxsYmFja3MiLCJub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeSIsInVuZGVmaW5lZCIsIkNvbXBvbmVudENvbnRhaW5lciIsInByb3ZpZGVycyIsImFkZENvbXBvbmVudCIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJhZGRPck92ZXJ3cml0ZUNvbXBvbmVudCIsImdldFByb3ZpZGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@firebase/database/dist/node-esm/index.node.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataSnapshot: () => (/* binding */ DataSnapshot),\n/* harmony export */   Database: () => (/* binding */ Database),\n/* harmony export */   OnDisconnect: () => (/* binding */ OnDisconnect),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   _QueryImpl: () => (/* binding */ QueryImpl),\n/* harmony export */   _QueryParams: () => (/* binding */ QueryParams),\n/* harmony export */   _ReferenceImpl: () => (/* binding */ ReferenceImpl),\n/* harmony export */   _TEST_ACCESS_forceRestClient: () => (/* binding */ forceRestClient),\n/* harmony export */   _TEST_ACCESS_hijackHash: () => (/* binding */ hijackHash),\n/* harmony export */   _repoManagerDatabaseFromApp: () => (/* binding */ repoManagerDatabaseFromApp),\n/* harmony export */   _setSDKVersion: () => (/* binding */ setSDKVersion),\n/* harmony export */   _validatePathString: () => (/* binding */ validatePathString),\n/* harmony export */   _validateWritablePath: () => (/* binding */ validateWritablePath),\n/* harmony export */   child: () => (/* binding */ child),\n/* harmony export */   connectDatabaseEmulator: () => (/* binding */ connectDatabaseEmulator),\n/* harmony export */   enableLogging: () => (/* binding */ enableLogging),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   equalTo: () => (/* binding */ equalTo),\n/* harmony export */   forceLongPolling: () => (/* binding */ forceLongPolling),\n/* harmony export */   forceWebSockets: () => (/* binding */ forceWebSockets),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getDatabase: () => (/* binding */ getDatabase),\n/* harmony export */   goOffline: () => (/* binding */ goOffline),\n/* harmony export */   goOnline: () => (/* binding */ goOnline),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   limitToFirst: () => (/* binding */ limitToFirst),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   onChildAdded: () => (/* binding */ onChildAdded),\n/* harmony export */   onChildChanged: () => (/* binding */ onChildChanged),\n/* harmony export */   onChildMoved: () => (/* binding */ onChildMoved),\n/* harmony export */   onChildRemoved: () => (/* binding */ onChildRemoved),\n/* harmony export */   onDisconnect: () => (/* binding */ onDisconnect),\n/* harmony export */   onValue: () => (/* binding */ onValue),\n/* harmony export */   orderByChild: () => (/* binding */ orderByChild),\n/* harmony export */   orderByKey: () => (/* binding */ orderByKey),\n/* harmony export */   orderByPriority: () => (/* binding */ orderByPriority),\n/* harmony export */   orderByValue: () => (/* binding */ orderByValue),\n/* harmony export */   push: () => (/* binding */ push),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   refFromURL: () => (/* binding */ refFromURL),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setPriority: () => (/* binding */ setPriority),\n/* harmony export */   setWithPriority: () => (/* binding */ setWithPriority),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var faye_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! faye-websocket */ \"(rsc)/./node_modules/faye-websocket/lib/faye/websocket.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(rsc)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(rsc)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/app */ \"(rsc)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"(rsc)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const PROTOCOL_VERSION = \"5\";\nconst VERSION_PARAM = \"v\";\nconst TRANSPORT_SESSION_PARAM = \"s\";\nconst REFERER_PARAM = \"r\";\nconst FORGE_REF = \"f\";\n// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\n// firebase.corp.google.com\nconst FORGE_DOMAIN_RE = /(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;\nconst LAST_SESSION_PARAM = \"ls\";\nconst APPLICATION_ID_PARAM = \"p\";\nconst APP_CHECK_TOKEN_PARAM = \"ac\";\nconst WEBSOCKET = \"websocket\";\nconst LONG_POLLING = \"long_polling\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */ class DOMStorageWrapper {\n    /**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */ constructor(domStorage_){\n        this.domStorage_ = domStorage_;\n        // Use a prefix to avoid collisions with other stuff saved by the app.\n        this.prefix_ = \"firebase:\";\n    }\n    /**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */ set(key, value) {\n        if (value == null) {\n            this.domStorage_.removeItem(this.prefixedName_(key));\n        } else {\n            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(value));\n        }\n    }\n    /**\r\n     * @returns The value that was stored under this key, or null\r\n     */ get(key) {\n        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\n        if (storedVal == null) {\n            return null;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(storedVal);\n        }\n    }\n    remove(key) {\n        this.domStorage_.removeItem(this.prefixedName_(key));\n    }\n    prefixedName_(name) {\n        return this.prefix_ + name;\n    }\n    toString() {\n        return this.domStorage_.toString();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */ class MemoryStorage {\n    constructor(){\n        this.cache_ = {};\n        this.isInMemoryStorage = true;\n    }\n    set(key, value) {\n        if (value == null) {\n            delete this.cache_[key];\n        } else {\n            this.cache_[key] = value;\n        }\n    }\n    get(key) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.cache_, key)) {\n            return this.cache_[key];\n        }\n        return null;\n    }\n    remove(key) {\n        delete this.cache_[key];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */ const createStoragefor = function(domStorageName) {\n    try {\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\n        // so it must be inside the try/catch.\n        if (false) {}\n    } catch (e) {}\n    // Failed to create wrapper.  Just return in-memory storage.\n    // TODO: log?\n    return new MemoryStorage();\n};\n/** A storage object that lasts across sessions */ const PersistentStorage = createStoragefor(\"localStorage\");\n/** A storage object that only lasts one session */ const SessionStorage = createStoragefor(\"sessionStorage\");\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(\"@firebase/database\");\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */ const LUIDGenerator = function() {\n    let id = 1;\n    return function() {\n        return id++;\n    };\n}();\n/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */ const sha1 = function(str) {\n    const utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringToByteArray)(str);\n    const sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Sha1();\n    sha1.update(utf8Bytes);\n    const sha1Bytes = sha1.digest();\n    return _firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64.encodeByteArray(sha1Bytes);\n};\nconst buildLogMessage_ = function(...varArgs) {\n    let message = \"\";\n    for(let i = 0; i < varArgs.length; i++){\n        const arg = varArgs[i];\n        if (Array.isArray(arg) || arg && typeof arg === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof arg.length === \"number\") {\n            message += buildLogMessage_.apply(null, arg);\n        } else if (typeof arg === \"object\") {\n            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(arg);\n        } else {\n            message += arg;\n        }\n        message += \" \";\n    }\n    return message;\n};\n/**\r\n * Use this for all debug messages in Firebase.\r\n */ let logger = null;\n/**\r\n * Flag to check for log availability on first log message\r\n */ let firstLog_ = true;\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */ const enableLogging$1 = function(logger_, persistent) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\n    if (logger_ === true) {\n        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.VERBOSE;\n        logger = logClient.log.bind(logClient);\n        if (persistent) {\n            SessionStorage.set(\"logging_enabled\", true);\n        }\n    } else if (typeof logger_ === \"function\") {\n        logger = logger_;\n    } else {\n        logger = null;\n        SessionStorage.remove(\"logging_enabled\");\n    }\n};\nconst log = function(...varArgs) {\n    if (firstLog_ === true) {\n        firstLog_ = false;\n        if (logger === null && SessionStorage.get(\"logging_enabled\") === true) {\n            enableLogging$1(true);\n        }\n    }\n    if (logger) {\n        const message = buildLogMessage_.apply(null, varArgs);\n        logger(message);\n    }\n};\nconst logWrapper = function(prefix) {\n    return function(...varArgs) {\n        log(prefix, ...varArgs);\n    };\n};\nconst error = function(...varArgs) {\n    const message = \"FIREBASE INTERNAL ERROR: \" + buildLogMessage_(...varArgs);\n    logClient.error(message);\n};\nconst fatal = function(...varArgs) {\n    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;\n    logClient.error(message);\n    throw new Error(message);\n};\nconst warn = function(...varArgs) {\n    const message = \"FIREBASE WARNING: \" + buildLogMessage_(...varArgs);\n    logClient.warn(message);\n};\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */ const warnIfPageIsSecure = function() {\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\n    if (false) {}\n};\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */ const isInvalidJSONNumber = function(data) {\n    return typeof data === \"number\" && (data !== data || // NaN\n    data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);\n};\nconst executeWhenDOMReady = function(fn) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() || document.readyState === \"complete\") {\n        fn();\n    } else {\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\n        // fire before onload), but fall back to onload.\n        let called = false;\n        const wrappedFn = function() {\n            if (!document.body) {\n                setTimeout(wrappedFn, Math.floor(10));\n                return;\n            }\n            if (!called) {\n                called = true;\n                fn();\n            }\n        };\n        if (document.addEventListener) {\n            document.addEventListener(\"DOMContentLoaded\", wrappedFn, false);\n            // fallback to onload.\n            window.addEventListener(\"load\", wrappedFn, false);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (document.attachEvent) {\n            // IE.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            document.attachEvent(\"onreadystatechange\", ()=>{\n                if (document.readyState === \"complete\") {\n                    wrappedFn();\n                }\n            });\n            // fallback to onload.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            window.attachEvent(\"onload\", wrappedFn);\n        // jQuery has an extra hack for IE that we could employ (based on\n        // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\n        // I'm hoping we don't need it.\n        }\n    }\n};\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */ const MIN_NAME = \"[MIN_NAME]\";\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */ const MAX_NAME = \"[MAX_NAME]\";\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */ const nameCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a === MIN_NAME || b === MAX_NAME) {\n        return -1;\n    } else if (b === MIN_NAME || a === MAX_NAME) {\n        return 1;\n    } else {\n        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\n        if (aAsInt !== null) {\n            if (bAsInt !== null) {\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\n            } else {\n                return -1;\n            }\n        } else if (bAsInt !== null) {\n            return 1;\n        } else {\n            return a < b ? -1 : 1;\n        }\n    }\n};\n/**\r\n * @returns {!number} comparison result.\r\n */ const stringCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\nconst requireKey = function(key, obj) {\n    if (obj && key in obj) {\n        return obj[key];\n    } else {\n        throw new Error(\"Missing required key (\" + key + \") in object: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj));\n    }\n};\nconst ObjectToUniqueKey = function(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj);\n    }\n    const keys = [];\n    // eslint-disable-next-line guard-for-in\n    for(const k in obj){\n        keys.push(k);\n    }\n    // Export as json, but with the keys sorted.\n    keys.sort();\n    let key = \"{\";\n    for(let i = 0; i < keys.length; i++){\n        if (i !== 0) {\n            key += \",\";\n        }\n        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(keys[i]);\n        key += \":\";\n        key += ObjectToUniqueKey(obj[keys[i]]);\n    }\n    key += \"}\";\n    return key;\n};\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */ const splitStringBySize = function(str, segsize) {\n    const len = str.length;\n    if (len <= segsize) {\n        return [\n            str\n        ];\n    }\n    const dataSegs = [];\n    for(let c = 0; c < len; c += segsize){\n        if (c + segsize > len) {\n            dataSegs.push(str.substring(c, len));\n        } else {\n            dataSegs.push(str.substring(c, c + segsize));\n        }\n    }\n    return dataSegs;\n};\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */ function each(obj, fn) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */ const doubleToIEEE754String = function(v) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!isInvalidJSONNumber(v), \"Invalid JSON number\"); // MJL\n    const ebits = 11, fbits = 52;\n    const bias = (1 << ebits - 1) - 1;\n    let s, e, f, ln, i;\n    // Compute sign, exponent, fraction\n    // Skip NaN / Infinity handling --MJL.\n    if (v === 0) {\n        e = 0;\n        f = 0;\n        s = 1 / v === -Infinity ? 1 : 0;\n    } else {\n        s = v < 0;\n        v = Math.abs(v);\n        if (v >= Math.pow(2, 1 - bias)) {\n            // Normalized\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\n            e = ln + bias;\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\n        } else {\n            // Denormalized\n            e = 0;\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\n        }\n    }\n    // Pack sign, exponent, fraction\n    const bits = [];\n    for(i = fbits; i; i -= 1){\n        bits.push(f % 2 ? 1 : 0);\n        f = Math.floor(f / 2);\n    }\n    for(i = ebits; i; i -= 1){\n        bits.push(e % 2 ? 1 : 0);\n        e = Math.floor(e / 2);\n    }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    const str = bits.join(\"\");\n    // Return the data as a hex string. --MJL\n    let hexByteString = \"\";\n    for(i = 0; i < 64; i += 8){\n        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        hexByteString = hexByteString + hexByte;\n    }\n    return hexByteString.toLowerCase();\n};\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */ const isChromeExtensionContentScript = function() {\n    return !!( false && 0);\n};\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */ const isWindowsStoreApp = function() {\n    // Check for the presence of a couple WinRT globals\n    return typeof Windows === \"object\" && typeof Windows.UI === \"object\";\n};\n/**\r\n * Converts a server error code to a Javascript Error\r\n */ function errorForServerCode(code, query) {\n    let reason = \"Unknown Error\";\n    if (code === \"too_big\") {\n        reason = \"The data requested exceeds the maximum size \" + \"that can be accessed with a single request.\";\n    } else if (code === \"permission_denied\") {\n        reason = \"Client doesn't have permission to access the desired data.\";\n    } else if (code === \"unavailable\") {\n        reason = \"The service is unavailable\";\n    }\n    const error = new Error(code + \" at \" + query._path.toString() + \": \" + reason);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error.code = code.toUpperCase();\n    return error;\n}\n/**\r\n * Used to test for integer-looking strings\r\n */ const INTEGER_REGEXP_ = new RegExp(\"^-?(0*)\\\\d{1,10}$\");\n/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */ const INTEGER_32_MIN = -2147483648;\n/**\r\n * For use in kyes, the maximum possible 32-bit integer.\r\n */ const INTEGER_32_MAX = 2147483647;\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */ const tryParseInt = function(str) {\n    if (INTEGER_REGEXP_.test(str)) {\n        const intVal = Number(str);\n        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {\n            return intVal;\n        }\n    }\n    return null;\n};\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */ const exceptionGuard = function(fn) {\n    try {\n        fn();\n    } catch (e) {\n        // Re-throw exception when it's safe.\n        setTimeout(()=>{\n            // It used to be that \"throw e\" would result in a good console error with\n            // relevant context, but as of Chrome 39, you just get the firebase.js\n            // file/line number where we re-throw it, which is useless. So we log\n            // e.stack explicitly.\n            const stack = e.stack || \"\";\n            warn(\"Exception was thrown by user callback.\", stack);\n            throw e;\n        }, Math.floor(0));\n    }\n};\n/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */ const beingCrawled = function() {\n    const userAgent =  false || \"\";\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\n    // believe to support JavaScript/AJAX rendering.\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\n    return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;\n};\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */ const setTimeoutNonBlocking = function(fn, time) {\n    const timeout = setTimeout(fn, time);\n    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.\n    if (typeof timeout === \"number\" && // @ts-ignore Is only defined in Deno environments.\n    typeof Deno !== \"undefined\" && // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n    Deno[\"unrefTimer\"]) {\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n        Deno.unrefTimer(timeout);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } else if (typeof timeout === \"object\" && timeout[\"unref\"]) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        timeout[\"unref\"]();\n    }\n    return timeout;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A class that holds metadata about a Repo object\r\n */ class RepoInfo {\n    /**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */ constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = \"\", includeNamespaceInQueryParams = false, isUsingEmulator = false){\n        this.secure = secure;\n        this.namespace = namespace;\n        this.webSocketOnly = webSocketOnly;\n        this.nodeAdmin = nodeAdmin;\n        this.persistenceKey = persistenceKey;\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\n        this.isUsingEmulator = isUsingEmulator;\n        this._host = host.toLowerCase();\n        this._domain = this._host.substr(this._host.indexOf(\".\") + 1);\n        this.internalHost = PersistentStorage.get(\"host:\" + host) || this._host;\n    }\n    isCacheableHost() {\n        return this.internalHost.substr(0, 2) === \"s-\";\n    }\n    isCustomHost() {\n        return this._domain !== \"firebaseio.com\" && this._domain !== \"firebaseio-demo.com\";\n    }\n    get host() {\n        return this._host;\n    }\n    set host(newHost) {\n        if (newHost !== this.internalHost) {\n            this.internalHost = newHost;\n            if (this.isCacheableHost()) {\n                PersistentStorage.set(\"host:\" + this._host, this.internalHost);\n            }\n        }\n    }\n    toString() {\n        let str = this.toURLString();\n        if (this.persistenceKey) {\n            str += \"<\" + this.persistenceKey + \">\";\n        }\n        return str;\n    }\n    toURLString() {\n        const protocol = this.secure ? \"https://\" : \"http://\";\n        const query = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : \"\";\n        return `${protocol}${this.host}/${query}`;\n    }\n}\nfunction repoInfoNeedsQueryParam(repoInfo) {\n    return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;\n}\n/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */ function repoInfoConnectionURL(repoInfo, type, params) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof type === \"string\", \"typeof type must == string\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof params === \"object\", \"typeof params must == object\");\n    let connURL;\n    if (type === WEBSOCKET) {\n        connURL = (repoInfo.secure ? \"wss://\" : \"ws://\") + repoInfo.internalHost + \"/.ws?\";\n    } else if (type === LONG_POLLING) {\n        connURL = (repoInfo.secure ? \"https://\" : \"http://\") + repoInfo.internalHost + \"/.lp?\";\n    } else {\n        throw new Error(\"Unknown connection type: \" + type);\n    }\n    if (repoInfoNeedsQueryParam(repoInfo)) {\n        params[\"ns\"] = repoInfo.namespace;\n    }\n    const pairs = [];\n    each(params, (key, value)=>{\n        pairs.push(key + \"=\" + value);\n    });\n    return connURL + pairs.join(\"&\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Tracks a collection of stats.\r\n */ class StatsCollection {\n    constructor(){\n        this.counters_ = {};\n    }\n    incrementCounter(name, amount = 1) {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.counters_, name)) {\n            this.counters_[name] = 0;\n        }\n        this.counters_[name] += amount;\n    }\n    get() {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(this.counters_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const collections = {};\nconst reporters = {};\nfunction statsManagerGetCollection(repoInfo) {\n    const hashString = repoInfo.toString();\n    if (!collections[hashString]) {\n        collections[hashString] = new StatsCollection();\n    }\n    return collections[hashString];\n}\nfunction statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {\n    const hashString = repoInfo.toString();\n    if (!reporters[hashString]) {\n        reporters[hashString] = creatorFunction();\n    }\n    return reporters[hashString];\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** The semver (www.semver.org) version of the SDK. */ let SDK_VERSION = \"\";\n/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */ function setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== \"undefined\") {\n    WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== \"undefined\") {\n    WebSocketImpl = WebSocket;\n}\nfunction setWebSocketImpl(impl) {\n    WebSocketImpl = impl;\n}\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n */ class WebSocketConnection {\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.keepaliveTimer = null;\n        this.frames = null;\n        this.totalFrames = 0;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.log_ = logWrapper(this.connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);\n        this.nodeAdmin = repoInfo.nodeAdmin;\n    }\n    /**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */ static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {\n        const urlParams = {};\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() && typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n            urlParams[REFERER_PARAM] = FORGE_REF;\n        }\n        if (transportSessionId) {\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n        }\n        if (lastSessionId) {\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\n        }\n        if (appCheckToken) {\n            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;\n        }\n        if (applicationId) {\n            urlParams[APPLICATION_ID_PARAM] = applicationId;\n        }\n        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.onDisconnect = onDisconnect;\n        this.onMessage = onMessage;\n        this.log_(\"Websocket connecting to \" + this.connURL);\n        this.everConnected_ = false;\n        // Assume failure until proven otherwise.\n        PersistentStorage.set(\"previous_websocket_failure\", true);\n        try {\n            let options;\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n                const device = this.nodeAdmin ? \"AdminNode\" : \"Node\";\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n                options = {\n                    headers: {\n                        \"User-Agent\": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,\n                        \"X-Firebase-GMPID\": this.applicationId || \"\"\n                    }\n                };\n                // If using Node with admin creds, AppCheck-related checks are unnecessary.\n                // Note that we send the credentials here even if they aren't admin credentials, which is\n                // not a problem.\n                // Note that this header is just used to bypass appcheck, and the token should still be sent\n                // through the websocket connection once it is established.\n                if (this.authToken) {\n                    options.headers[\"Authorization\"] = `Bearer ${this.authToken}`;\n                }\n                if (this.appCheckToken) {\n                    options.headers[\"X-Firebase-AppCheck\"] = this.appCheckToken;\n                }\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n                const env = process[\"env\"];\n                const proxy = this.connURL.indexOf(\"wss://\") === 0 ? env[\"HTTPS_PROXY\"] || env[\"https_proxy\"] : env[\"HTTP_PROXY\"] || env[\"http_proxy\"];\n                if (proxy) {\n                    options[\"proxy\"] = {\n                        origin: proxy\n                    };\n                }\n            }\n            this.mySock = new WebSocketImpl(this.connURL, [], options);\n        } catch (e) {\n            this.log_(\"Error instantiating WebSocket.\");\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n            return;\n        }\n        this.mySock.onopen = ()=>{\n            this.log_(\"Websocket connected.\");\n            this.everConnected_ = true;\n        };\n        this.mySock.onclose = ()=>{\n            this.log_(\"Websocket connection was disconnected.\");\n            this.mySock = null;\n            this.onClosed_();\n        };\n        this.mySock.onmessage = (m)=>{\n            this.handleIncomingFrame(m);\n        };\n        this.mySock.onerror = (e)=>{\n            this.log_(\"WebSocket error.  Closing connection.\");\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n        };\n    }\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */ start() {}\n    static forceDisallow() {\n        WebSocketConnection.forceDisallow_ = true;\n    }\n    static isAvailable() {\n        let isOldAndroid = false;\n        if (typeof navigator !== \"undefined\" && navigator.userAgent) {\n            const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n                    isOldAndroid = true;\n                }\n            }\n        }\n        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n    }\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */ static previouslyFailed() {\n        // If our persistent storage is actually only in-memory storage,\n        // we default to assuming that it previously failed to be safe.\n        return PersistentStorage.isInMemoryStorage || PersistentStorage.get(\"previous_websocket_failure\") === true;\n    }\n    markConnectionHealthy() {\n        PersistentStorage.remove(\"previous_websocket_failure\");\n    }\n    appendFrame_(data) {\n        this.frames.push(data);\n        if (this.frames.length === this.totalFrames) {\n            const fullMess = this.frames.join(\"\");\n            this.frames = null;\n            const jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(fullMess);\n            //handle the message\n            this.onMessage(jsonMess);\n        }\n    }\n    /**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */ handleNewFrameCount_(frameCount) {\n        this.totalFrames = frameCount;\n        this.frames = [];\n    }\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */ extractFrameCount_(data) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.frames === null, \"We already have a frame buffer\");\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n        if (data.length <= 6) {\n            const frameCount = Number(data);\n            if (!isNaN(frameCount)) {\n                this.handleNewFrameCount_(frameCount);\n                return null;\n            }\n        }\n        this.handleNewFrameCount_(1);\n        return data;\n    }\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */ handleIncomingFrame(mess) {\n        if (this.mySock === null) {\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n        }\n        const data = mess[\"data\"];\n        this.bytesReceived += data.length;\n        this.stats_.incrementCounter(\"bytes_received\", data.length);\n        this.resetKeepAlive();\n        if (this.frames !== null) {\n            // we're buffering\n            this.appendFrame_(data);\n        } else {\n            // try to parse out a frame count, otherwise, assume 1 and process it\n            const remainingData = this.extractFrameCount_(data);\n            if (remainingData !== null) {\n                this.appendFrame_(remainingData);\n            }\n        }\n    }\n    /**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */ send(data) {\n        this.resetKeepAlive();\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n        //Send the length header\n        if (dataSegs.length > 1) {\n            this.sendString_(String(dataSegs.length));\n        }\n        //Send the actual data in segments.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.sendString_(dataSegs[i]);\n        }\n    }\n    shutdown_() {\n        this.isClosed_ = true;\n        if (this.keepaliveTimer) {\n            clearInterval(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n        if (this.mySock) {\n            this.mySock.close();\n            this.mySock = null;\n        }\n    }\n    onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is closing itself\");\n            this.shutdown_();\n            // since this is an internal close, trigger the close listener\n            if (this.onDisconnect) {\n                this.onDisconnect(this.everConnected_);\n                this.onDisconnect = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is being closed\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */ resetKeepAlive() {\n        clearInterval(this.keepaliveTimer);\n        this.keepaliveTimer = setInterval(()=>{\n            //If there has been no websocket activity for a while, send a no-op\n            if (this.mySock) {\n                this.sendString_(\"0\");\n            }\n            this.resetKeepAlive();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n    }\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */ sendString_(str) {\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n        // calls for some unknown reason.  We treat these as an error and disconnect.\n        // See https://app.asana.com/0/58926111402292/68021340250410\n        try {\n            this.mySock.send(str);\n        } catch (e) {\n            this.log_(\"Exception thrown from WebSocket.send():\", e.message || e.data, \"Closing connection.\");\n            setTimeout(this.onClosed_.bind(this), 0);\n        }\n    }\n}\n/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */ WebSocketConnection.responsesRequiredToBeHealthy = 2;\n/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */ WebSocketConnection.healthyTimeout = 30000;\nconst name = \"@firebase/database\";\nconst version = \"0.14.4\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */ class AppCheckTokenProvider {\n    constructor(appName_, appCheckProvider){\n        this.appName_ = appName_;\n        this.appCheckProvider = appCheckProvider;\n        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({\n            optional: true\n        });\n        if (!this.appCheck) {\n            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then((appCheck)=>this.appCheck = appCheck);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.appCheck) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAppCheck. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // AppCheck and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.appCheck) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.appCheck.getToken(forceRefresh);\n    }\n    addTokenChangeListener(listener) {\n        var _a;\n        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then((appCheck)=>appCheck.addTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" ` + \"are invalid. This usually indicates your app was not initialized correctly.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */ class FirebaseAuthTokenProvider {\n    constructor(appName_, firebaseOptions_, authProvider_){\n        this.appName_ = appName_;\n        this.firebaseOptions_ = firebaseOptions_;\n        this.authProvider_ = authProvider_;\n        this.auth_ = null;\n        this.auth_ = authProvider_.getImmediate({\n            optional: true\n        });\n        if (!this.auth_) {\n            authProvider_.onInit((auth)=>this.auth_ = auth);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.auth_) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAuth. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // Auth and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.auth_) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.auth_.getToken(forceRefresh).catch((error)=>{\n            // TODO: Need to figure out all the cases this is raised and whether\n            // this makes sense.\n            if (error && error.code === \"auth/token-not-initialized\") {\n                log(\"Got auth/token-not-initialized error.  Treating as null token.\");\n                return null;\n            } else {\n                return Promise.reject(error);\n            }\n        });\n    }\n    addTokenChangeListener(listener) {\n        // TODO: We might want to wrap the listener and call it with no args to\n        // avoid a leaky abstraction, but that makes removing the listener harder.\n        if (this.auth_) {\n            this.auth_.addAuthTokenListener(listener);\n        } else {\n            this.authProvider_.get().then((auth)=>auth.addAuthTokenListener(listener));\n        }\n    }\n    removeTokenChangeListener(listener) {\n        this.authProvider_.get().then((auth)=>auth.removeAuthTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        let errorMessage = 'Provided authentication credentials for the app named \"' + this.appName_ + '\" are invalid. This usually indicates your app was not ' + \"initialized correctly. \";\n        if (\"credential\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"credential\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else if (\"serviceAccount\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"serviceAccount\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else {\n            errorMessage += 'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' + \"initializeApp() match the values provided for your app at \" + \"https://console.firebase.google.com/.\";\n        }\n        warn(errorMessage);\n    }\n}\n/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */ class EmulatorTokenProvider {\n    constructor(accessToken){\n        this.accessToken = accessToken;\n    }\n    getToken(forceRefresh) {\n        return Promise.resolve({\n            accessToken: this.accessToken\n        });\n    }\n    addTokenChangeListener(listener) {\n        // Invoke the listener immediately to match the behavior in Firebase Auth\n        // (see packages/auth/src/auth.js#L1807)\n        listener(this.accessToken);\n    }\n    removeTokenChangeListener(listener) {}\n    notifyForInvalidToken() {}\n}\n/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */ EmulatorTokenProvider.OWNER = \"owner\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */ class PacketReceiver {\n    /**\r\n     * @param onMessage_\r\n     */ constructor(onMessage_){\n        this.onMessage_ = onMessage_;\n        this.pendingResponses = [];\n        this.currentResponseNum = 0;\n        this.closeAfterResponse = -1;\n        this.onClose = null;\n    }\n    closeAfter(responseNum, callback) {\n        this.closeAfterResponse = responseNum;\n        this.onClose = callback;\n        if (this.closeAfterResponse < this.currentResponseNum) {\n            this.onClose();\n            this.onClose = null;\n        }\n    }\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */ handleResponse(requestNum, data) {\n        this.pendingResponses[requestNum] = data;\n        while(this.pendingResponses[this.currentResponseNum]){\n            const toProcess = this.pendingResponses[this.currentResponseNum];\n            delete this.pendingResponses[this.currentResponseNum];\n            for(let i = 0; i < toProcess.length; ++i){\n                if (toProcess[i]) {\n                    exceptionGuard(()=>{\n                        this.onMessage_(toProcess[i]);\n                    });\n                }\n            }\n            if (this.currentResponseNum === this.closeAfterResponse) {\n                if (this.onClose) {\n                    this.onClose();\n                    this.onClose = null;\n                }\n                break;\n            }\n            this.currentResponseNum++;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // URL query parameters associated with longpolling\nconst FIREBASE_LONGPOLL_START_PARAM = \"start\";\nconst FIREBASE_LONGPOLL_CLOSE_COMMAND = \"close\";\nconst FIREBASE_LONGPOLL_COMMAND_CB_NAME = \"pLPCommand\";\nconst FIREBASE_LONGPOLL_DATA_CB_NAME = \"pRTLPCB\";\nconst FIREBASE_LONGPOLL_ID_PARAM = \"id\";\nconst FIREBASE_LONGPOLL_PW_PARAM = \"pw\";\nconst FIREBASE_LONGPOLL_SERIAL_PARAM = \"ser\";\nconst FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = \"cb\";\nconst FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = \"seg\";\nconst FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = \"ts\";\nconst FIREBASE_LONGPOLL_DATA_PARAM = \"d\";\nconst FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = \"dframe\";\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */ const KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */ const LP_CONNECT_TIMEOUT = 30000;\n/**\r\n * This class manages a single long-polling connection.\r\n */ class BrowserPollConnection {\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.repoInfo = repoInfo;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.transportSessionId = transportSessionId;\n        this.lastSessionId = lastSessionId;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.everConnected_ = false;\n        this.log_ = logWrapper(connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.urlFn = (params)=>{\n            // Always add the token if we have one.\n            if (this.appCheckToken) {\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\n        };\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.curSegmentNum = 0;\n        this.onDisconnect_ = onDisconnect;\n        this.myPacketOrderer = new PacketReceiver(onMessage);\n        this.isClosed_ = false;\n        this.connectTimeoutTimer_ = setTimeout(()=>{\n            this.log_(\"Timed out trying to connect.\");\n            // Make sure we clear the host cache\n            this.onClosed_();\n            this.connectTimeoutTimer_ = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(LP_CONNECT_TIMEOUT));\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\n        executeWhenDOMReady(()=>{\n            if (this.isClosed_) {\n                return;\n            }\n            //Set up a callback that gets triggered once a connection is set up.\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args)=>{\n                const [command, arg1, arg2, arg3, arg4] = args;\n                this.incrementIncomingBytes_(args);\n                if (!this.scriptTagHolder) {\n                    return; // we closed the connection.\n                }\n                if (this.connectTimeoutTimer_) {\n                    clearTimeout(this.connectTimeoutTimer_);\n                    this.connectTimeoutTimer_ = null;\n                }\n                this.everConnected_ = true;\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\n                    this.id = arg1;\n                    this.password = arg2;\n                } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\n                    if (arg1) {\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\n                        // through our already open polls), so don't send any more.\n                        this.scriptTagHolder.sendNewPolls = false;\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\n                        // all of the responses up to this one before closing\n                        this.myPacketOrderer.closeAfter(arg1, ()=>{\n                            this.onClosed_();\n                        });\n                    } else {\n                        this.onClosed_();\n                    }\n                } else {\n                    throw new Error(\"Unrecognized command received: \" + command);\n                }\n            }, (...args)=>{\n                const [pN, data] = args;\n                this.incrementIncomingBytes_(args);\n                this.myPacketOrderer.handleResponse(pN, data);\n            }, ()=>{\n                this.onClosed_();\n            }, this.urlFn);\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n            //from cache.\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = \"t\";\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;\n            }\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n            if (this.transportSessionId) {\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n            }\n            if (this.lastSessionId) {\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n            }\n            if (this.applicationId) {\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\n            }\n            if (this.appCheckToken) {\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            if (typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n                urlParams[REFERER_PARAM] = FORGE_REF;\n            }\n            const connectURL = this.urlFn(urlParams);\n            this.log_(\"Connecting via long-poll to \" + connectURL);\n            this.scriptTagHolder.addTag(connectURL, ()=>{\n            /* do nothing */ });\n        });\n    }\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */ start() {\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\n        this.addDisconnectPingFrame(this.id, this.password);\n    }\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */ static forceAllow() {\n        BrowserPollConnection.forceAllow_ = true;\n    }\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */ static forceDisallow() {\n        BrowserPollConnection.forceDisallow_ = true;\n    }\n    // Static method, use string literal so it can be accessed in a generic way\n    static isAvailable() {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return false;\n        } else if (BrowserPollConnection.forceAllow_) {\n            return true;\n        } else {\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n            return !BrowserPollConnection.forceDisallow_ && typeof document !== \"undefined\" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();\n        }\n    }\n    /**\r\n     * No-op for polling\r\n     */ markConnectionHealthy() {}\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */ shutdown_() {\n        this.isClosed_ = true;\n        if (this.scriptTagHolder) {\n            this.scriptTagHolder.close();\n            this.scriptTagHolder = null;\n        }\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n        if (this.myDisconnFrame) {\n            document.body.removeChild(this.myDisconnFrame);\n            this.myDisconnFrame = null;\n        }\n        if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n        }\n    }\n    /**\r\n     * Triggered when this transport is closed\r\n     */ onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is closing itself\");\n            this.shutdown_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_(this.everConnected_);\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is being closed.\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */ send(data) {\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //first, lets get the base64-encoded data\n        const base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Encode)(dataStr);\n        //We can only fit a certain amount in each URL, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n        //of segments so that we can reassemble the packet on the server.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n            this.curSegmentNum++;\n        }\n    }\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */ addDisconnectPingFrame(id, pw) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return;\n        }\n        this.myDisconnFrame = document.createElement(\"iframe\");\n        const urlParams = {};\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = \"t\";\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n        this.myDisconnFrame.src = this.urlFn(urlParams);\n        this.myDisconnFrame.style.display = \"none\";\n        document.body.appendChild(this.myDisconnFrame);\n    }\n    /**\r\n     * Used to track the bytes received by this client\r\n     */ incrementIncomingBytes_(args) {\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n        const bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(args).length;\n        this.bytesReceived += bytesReceived;\n        this.stats_.incrementCounter(\"bytes_received\", bytesReceived);\n    }\n}\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/ class FirebaseIFrameScriptHolder {\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */ constructor(commandCB, onMessageCB, onDisconnect, urlFn){\n        this.onDisconnect = onDisconnect;\n        this.urlFn = urlFn;\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n        //problems in some browsers.\n        this.outstandingRequests = new Set();\n        //A queue of the pending segments waiting for transmission to the server.\n        this.pendingSegs = [];\n        //A serial number. We use this for two things:\n        // 1) A way to ensure the browser doesn't cache responses to polls\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n        //    JSONP code in the order it was added to the iframe.\n        this.currentSerial = Math.floor(Math.random() * 100000000);\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n        // incoming data from the server that we're waiting for).\n        this.sendNewPolls = true;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n            //iframes where we put the long-polling script tags. We have two callbacks:\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\n            //   2) Message Callback - Triggered when new data arrives.\n            this.uniqueCallbackIdentifier = LUIDGenerator();\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\n            //Create an iframe for us to add script tags to.\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n            // Set the iframe's contents.\n            let script = \"\";\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n            // for ie9, but ie8 needs to do it again in the document itself.\n            if (this.myIFrame.src && this.myIFrame.src.substr(0, \"javascript:\".length) === \"javascript:\") {\n                const currentDomain = document.domain;\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n            }\n            const iframeContents = \"<html><body>\" + script + \"</body></html>\";\n            try {\n                this.myIFrame.doc.open();\n                this.myIFrame.doc.write(iframeContents);\n                this.myIFrame.doc.close();\n            } catch (e) {\n                log(\"frame writing exception\");\n                if (e.stack) {\n                    log(e.stack);\n                }\n                log(e);\n            }\n        } else {\n            this.commandCB = commandCB;\n            this.onMessageCB = onMessageCB;\n        }\n    }\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */ static createIFrame_() {\n        const iframe = document.createElement(\"iframe\");\n        iframe.style.display = \"none\";\n        // This is necessary in order to initialize the document inside the iframe\n        if (document.body) {\n            document.body.appendChild(iframe);\n            try {\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n                const a = iframe.contentWindow.document;\n                if (!a) {\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n                    log(\"No IE domain setting required\");\n                }\n            } catch (e) {\n                const domain = document.domain;\n                iframe.src = \"javascript:void((function(){document.open();document.domain='\" + domain + \"';document.close();})())\";\n            }\n        } else {\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n            // never gets hit.\n            throw \"Document body has not initialized. Wait to initialize Firebase until after the document is ready.\";\n        }\n        // Get the document of the iframe in a browser-specific way.\n        if (iframe.contentDocument) {\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n        } else if (iframe.contentWindow) {\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (iframe.document) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            iframe.doc = iframe.document; //others?\n        }\n        return iframe;\n    }\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */ close() {\n        //Mark this iframe as dead, so no new requests are sent.\n        this.alive = false;\n        if (this.myIFrame) {\n            //We have to actually remove all of the html inside this iframe before removing it from the\n            //window, or IE will continue loading and executing the script tags we've already added, which\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\n            this.myIFrame.doc.body.textContent = \"\";\n            setTimeout(()=>{\n                if (this.myIFrame !== null) {\n                    document.body.removeChild(this.myIFrame);\n                    this.myIFrame = null;\n                }\n            }, Math.floor(0));\n        }\n        // Protect from being called recursively.\n        const onDisconnect = this.onDisconnect;\n        if (onDisconnect) {\n            this.onDisconnect = null;\n            onDisconnect();\n        }\n    }\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */ startLongPoll(id, pw) {\n        this.myID = id;\n        this.myPW = pw;\n        this.alive = true;\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n        while(this.newRequest_()){}\n    }\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */ newRequest_() {\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n        // close the old request.\n        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\n            //construct our url\n            this.currentSerial++;\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n            let theURL = this.urlFn(urlParams);\n            //Now add as much data as we can.\n            let curDataString = \"\";\n            let i = 0;\n            while(this.pendingSegs.length > 0){\n                //first, lets see if the next segment will fit.\n                const nextSeg = this.pendingSegs[0];\n                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {\n                    //great, the segment will fit. Lets append it.\n                    const theSeg = this.pendingSegs.shift();\n                    curDataString = curDataString + \"&\" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + \"=\" + theSeg.seg + \"&\" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + \"=\" + theSeg.ts + \"&\" + FIREBASE_LONGPOLL_DATA_PARAM + i + \"=\" + theSeg.d;\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            theURL = theURL + curDataString;\n            this.addLongPollTag_(theURL, this.currentSerial);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */ enqueueSegment(segnum, totalsegs, data) {\n        //add this to the queue of segments to send.\n        this.pendingSegs.push({\n            seg: segnum,\n            ts: totalsegs,\n            d: data\n        });\n        //send the data immediately if there isn't already data being transmitted, unless\n        //startLongPoll hasn't been called yet.\n        if (this.alive) {\n            this.newRequest_();\n        }\n    }\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */ addLongPollTag_(url, serial) {\n        //remember that we sent this request.\n        this.outstandingRequests.add(serial);\n        const doNewRequest = ()=>{\n            this.outstandingRequests.delete(serial);\n            this.newRequest_();\n        };\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n        const readyStateCB = ()=>{\n            // Request completed.  Cancel the keepalive.\n            clearTimeout(keepaliveTimeout);\n            // Trigger a new request so we can continue receiving data.\n            doNewRequest();\n        };\n        this.addTag(url, readyStateCB);\n    }\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */ addTag(url, loadCB) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.doNodeLongPoll(url, loadCB);\n        } else {\n            setTimeout(()=>{\n                try {\n                    // if we're already closed, don't add this poll\n                    if (!this.sendNewPolls) {\n                        return;\n                    }\n                    const newScript = this.myIFrame.doc.createElement(\"script\");\n                    newScript.type = \"text/javascript\";\n                    newScript.async = true;\n                    newScript.src = url;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    newScript.onload = newScript.onreadystatechange = function() {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        const rstate = newScript.readyState;\n                        if (!rstate || rstate === \"loaded\" || rstate === \"complete\") {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            newScript.onload = newScript.onreadystatechange = null;\n                            if (newScript.parentNode) {\n                                newScript.parentNode.removeChild(newScript);\n                            }\n                            loadCB();\n                        }\n                    };\n                    newScript.onerror = ()=>{\n                        log(\"Long-poll script failed to load: \" + url);\n                        this.sendNewPolls = false;\n                        this.close();\n                    };\n                    this.myIFrame.doc.body.appendChild(newScript);\n                } catch (e) {\n                // TODO: we should make this error visible somehow\n                }\n            }, Math.floor(1));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */ class TransportManager {\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */ constructor(repoInfo){\n        this.initTransports_(repoInfo);\n    }\n    static get ALL_TRANSPORTS() {\n        return [\n            BrowserPollConnection,\n            WebSocketConnection\n        ];\n    }\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */ static get IS_TRANSPORT_INITIALIZED() {\n        return this.globalTransportInitialized_;\n    }\n    initTransports_(repoInfo) {\n        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection[\"isAvailable\"]();\n        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n        if (repoInfo.webSocketOnly) {\n            if (!isWebSocketsAvailable) {\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n            }\n            isSkipPollConnection = true;\n        }\n        if (isSkipPollConnection) {\n            this.transports_ = [\n                WebSocketConnection\n            ];\n        } else {\n            const transports = this.transports_ = [];\n            for (const transport of TransportManager.ALL_TRANSPORTS){\n                if (transport && transport[\"isAvailable\"]()) {\n                    transports.push(transport);\n                }\n            }\n            TransportManager.globalTransportInitialized_ = true;\n        }\n    }\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */ initialTransport() {\n        if (this.transports_.length > 0) {\n            return this.transports_[0];\n        } else {\n            throw new Error(\"No transports available\");\n        }\n    }\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */ upgradeTransport() {\n        if (this.transports_.length > 1) {\n            return this.transports_[1];\n        } else {\n            return null;\n        }\n    }\n}\n// Keeps track of whether the TransportManager has already chosen a transport to use\nTransportManager.globalTransportInitialized_ = false;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nconst MESSAGE_TYPE = \"t\";\nconst MESSAGE_DATA = \"d\";\nconst CONTROL_SHUTDOWN = \"s\";\nconst CONTROL_RESET = \"r\";\nconst CONTROL_ERROR = \"e\";\nconst CONTROL_PONG = \"o\";\nconst SWITCH_ACK = \"a\";\nconst END_TRANSMISSION = \"n\";\nconst PING = \"p\";\nconst SERVER_HELLO = \"h\";\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */ class Connection {\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */ constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId){\n        this.id = id;\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.appCheckToken_ = appCheckToken_;\n        this.authToken_ = authToken_;\n        this.onMessage_ = onMessage_;\n        this.onReady_ = onReady_;\n        this.onDisconnect_ = onDisconnect_;\n        this.onKill_ = onKill_;\n        this.lastSessionId = lastSessionId;\n        this.connectionCount = 0;\n        this.pendingDataMessages = [];\n        this.state_ = 0 /* RealtimeState.CONNECTING */ ;\n        this.log_ = logWrapper(\"c:\" + this.id + \":\");\n        this.transportManager_ = new TransportManager(repoInfo_);\n        this.log_(\"Connection created\");\n        this.start_();\n    }\n    /**\r\n     * Starts a connection attempt\r\n     */ start_() {\n        const conn = this.transportManager_.initialTransport();\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.primaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessageReceived = this.connReceiver_(this.conn_);\n        const onConnectionLost = this.disconnReceiver_(this.conn_);\n        this.tx_ = this.conn_;\n        this.rx_ = this.conn_;\n        this.secondaryConn_ = null;\n        this.isHealthy_ = false;\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */ setTimeout(()=>{\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n        }, Math.floor(0));\n        const healthyTimeoutMS = conn[\"healthyTimeout\"] || 0;\n        if (healthyTimeoutMS > 0) {\n            this.healthyTimeout_ = setTimeoutNonBlocking(()=>{\n                this.healthyTimeout_ = null;\n                if (!this.isHealthy_) {\n                    if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has received \" + this.conn_.bytesReceived + \" bytes.  Marking connection healthy.\");\n                        this.isHealthy_ = true;\n                        this.conn_.markConnectionHealthy();\n                    } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has sent \" + this.conn_.bytesSent + \" bytes.  Leaving connection alive.\");\n                    // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n                    // the server.\n                    } else {\n                        this.log_(\"Closing unhealthy connection after timeout.\");\n                        this.close();\n                    }\n                }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, Math.floor(healthyTimeoutMS));\n        }\n    }\n    nextTransportId_() {\n        return \"c:\" + this.id + \":\" + this.connectionCount++;\n    }\n    disconnReceiver_(conn) {\n        return (everConnected)=>{\n            if (conn === this.conn_) {\n                this.onConnectionLost_(everConnected);\n            } else if (conn === this.secondaryConn_) {\n                this.log_(\"Secondary connection lost.\");\n                this.onSecondaryConnectionLost_();\n            } else {\n                this.log_(\"closing an old connection\");\n            }\n        };\n    }\n    connReceiver_(conn) {\n        return (message)=>{\n            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n                if (conn === this.rx_) {\n                    this.onPrimaryMessageReceived_(message);\n                } else if (conn === this.secondaryConn_) {\n                    this.onSecondaryMessageReceived_(message);\n                } else {\n                    this.log_(\"message on old connection\");\n                }\n            }\n        };\n    }\n    /**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */ sendRequest(dataMsg) {\n        // wrap in a data message envelope and send it on\n        const msg = {\n            t: \"d\",\n            d: dataMsg\n        };\n        this.sendData_(msg);\n    }\n    tryCleanupConnection() {\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n            this.log_(\"cleaning up and promoting a connection: \" + this.secondaryConn_.connId);\n            this.conn_ = this.secondaryConn_;\n            this.secondaryConn_ = null;\n        // the server will shutdown the old connection\n        }\n    }\n    onSecondaryControl_(controlData) {\n        if (MESSAGE_TYPE in controlData) {\n            const cmd = controlData[MESSAGE_TYPE];\n            if (cmd === SWITCH_ACK) {\n                this.upgradeIfSecondaryHealthy_();\n            } else if (cmd === CONTROL_RESET) {\n                // Most likely the session wasn't valid. Abandon the switch attempt\n                this.log_(\"Got a reset on secondary, closing it\");\n                this.secondaryConn_.close();\n                // If we were already using this connection for something, than we need to fully close\n                if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {\n                    this.close();\n                }\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on secondary.\");\n                this.secondaryResponsesRequired_--;\n                this.upgradeIfSecondaryHealthy_();\n            }\n        }\n    }\n    onSecondaryMessageReceived_(parsedData) {\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onSecondaryControl_(data);\n        } else if (layer === \"d\") {\n            // got a data message, but we're still second connection. Need to buffer it up\n            this.pendingDataMessages.push(data);\n        } else {\n            throw new Error(\"Unknown protocol layer: \" + layer);\n        }\n    }\n    upgradeIfSecondaryHealthy_() {\n        if (this.secondaryResponsesRequired_ <= 0) {\n            this.log_(\"Secondary connection is healthy.\");\n            this.isHealthy_ = true;\n            this.secondaryConn_.markConnectionHealthy();\n            this.proceedWithUpgrade_();\n        } else {\n            // Send a ping to make sure the connection is healthy.\n            this.log_(\"sending ping on secondary.\");\n            this.secondaryConn_.send({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    proceedWithUpgrade_() {\n        // tell this connection to consider itself open\n        this.secondaryConn_.start();\n        // send ack\n        this.log_(\"sending client ack on secondary\");\n        this.secondaryConn_.send({\n            t: \"c\",\n            d: {\n                t: SWITCH_ACK,\n                d: {}\n            }\n        });\n        // send end packet on primary transport, switch to sending on this one\n        // can receive on this one, buffer responses until end received on primary transport\n        this.log_(\"Ending transmission on primary\");\n        this.conn_.send({\n            t: \"c\",\n            d: {\n                t: END_TRANSMISSION,\n                d: {}\n            }\n        });\n        this.tx_ = this.secondaryConn_;\n        this.tryCleanupConnection();\n    }\n    onPrimaryMessageReceived_(parsedData) {\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onControl_(data);\n        } else if (layer === \"d\") {\n            this.onDataMessage_(data);\n        }\n    }\n    onDataMessage_(message) {\n        this.onPrimaryResponse_();\n        // We don't do anything with data messages, just kick them up a level\n        this.onMessage_(message);\n    }\n    onPrimaryResponse_() {\n        if (!this.isHealthy_) {\n            this.primaryResponsesRequired_--;\n            if (this.primaryResponsesRequired_ <= 0) {\n                this.log_(\"Primary connection is healthy.\");\n                this.isHealthy_ = true;\n                this.conn_.markConnectionHealthy();\n            }\n        }\n    }\n    onControl_(controlData) {\n        const cmd = requireKey(MESSAGE_TYPE, controlData);\n        if (MESSAGE_DATA in controlData) {\n            const payload = controlData[MESSAGE_DATA];\n            if (cmd === SERVER_HELLO) {\n                const handshakePayload = Object.assign({}, payload);\n                if (this.repoInfo_.isUsingEmulator) {\n                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.\n                    handshakePayload.h = this.repoInfo_.host;\n                }\n                this.onHandshake_(handshakePayload);\n            } else if (cmd === END_TRANSMISSION) {\n                this.log_(\"recvd end transmission on primary\");\n                this.rx_ = this.secondaryConn_;\n                for(let i = 0; i < this.pendingDataMessages.length; ++i){\n                    this.onDataMessage_(this.pendingDataMessages[i]);\n                }\n                this.pendingDataMessages = [];\n                this.tryCleanupConnection();\n            } else if (cmd === CONTROL_SHUTDOWN) {\n                // This was previously the 'onKill' callback passed to the lower-level connection\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\n                this.onConnectionShutdown_(payload);\n            } else if (cmd === CONTROL_RESET) {\n                // payload in this case is the host we should contact\n                this.onReset_(payload);\n            } else if (cmd === CONTROL_ERROR) {\n                error(\"Server Error: \" + payload);\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on primary.\");\n                this.onPrimaryResponse_();\n                this.sendPingOnPrimaryIfNecessary_();\n            } else {\n                error(\"Unknown control packet command: \" + cmd);\n            }\n        }\n    }\n    /**\r\n     * @param handshake - The handshake data returned from the server\r\n     */ onHandshake_(handshake) {\n        const timestamp = handshake.ts;\n        const version = handshake.v;\n        const host = handshake.h;\n        this.sessionId = handshake.s;\n        this.repoInfo_.host = host;\n        // if we've already closed the connection, then don't bother trying to progress further\n        if (this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.conn_.start();\n            this.onConnectionEstablished_(this.conn_, timestamp);\n            if (PROTOCOL_VERSION !== version) {\n                warn(\"Protocol version mismatch detected\");\n            }\n            // TODO: do we want to upgrade? when? maybe a delay?\n            this.tryStartUpgrade_();\n        }\n    }\n    tryStartUpgrade_() {\n        const conn = this.transportManager_.upgradeTransport();\n        if (conn) {\n            this.startUpgrade_(conn);\n        }\n    }\n    startUpgrade_(conn) {\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.secondaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessage = this.connReceiver_(this.secondaryConn_);\n        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n        this.secondaryConn_.open(onMessage, onDisconnect);\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n        setTimeoutNonBlocking(()=>{\n            if (this.secondaryConn_) {\n                this.log_(\"Timed out trying to upgrade.\");\n                this.secondaryConn_.close();\n            }\n        }, Math.floor(UPGRADE_TIMEOUT));\n    }\n    onReset_(host) {\n        this.log_(\"Reset packet received.  New host: \" + host);\n        this.repoInfo_.host = host;\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n        // We don't currently support resets after the connection has already been established\n        if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.close();\n        } else {\n            // Close whatever connections we have open and start again.\n            this.closeConnections_();\n            this.start_();\n        }\n    }\n    onConnectionEstablished_(conn, timestamp) {\n        this.log_(\"Realtime connection established.\");\n        this.conn_ = conn;\n        this.state_ = 1 /* RealtimeState.CONNECTED */ ;\n        if (this.onReady_) {\n            this.onReady_(timestamp, this.sessionId);\n            this.onReady_ = null;\n        }\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n        // send some pings.\n        if (this.primaryResponsesRequired_ === 0) {\n            this.log_(\"Primary connection is healthy.\");\n            this.isHealthy_ = true;\n        } else {\n            setTimeoutNonBlocking(()=>{\n                this.sendPingOnPrimaryIfNecessary_();\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n        }\n    }\n    sendPingOnPrimaryIfNecessary_() {\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"sending ping on primary.\");\n            this.sendData_({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    onSecondaryConnectionLost_() {\n        const conn = this.secondaryConn_;\n        this.secondaryConn_ = null;\n        if (this.tx_ === conn || this.rx_ === conn) {\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\n            this.close();\n        }\n    }\n    /**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */ onConnectionLost_(everConnected) {\n        this.conn_ = null;\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.log_(\"Realtime connection failed.\");\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n            if (this.repoInfo_.isCacheableHost()) {\n                PersistentStorage.remove(\"host:\" + this.repoInfo_.host);\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n                this.repoInfo_.internalHost = this.repoInfo_.host;\n            }\n        } else if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"Realtime connection lost.\");\n        }\n        this.close();\n    }\n    onConnectionShutdown_(reason) {\n        this.log_(\"Connection shutdown command received. Shutting down...\");\n        if (this.onKill_) {\n            this.onKill_(reason);\n            this.onKill_ = null;\n        }\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\n        // so clear the callback.\n        this.onDisconnect_ = null;\n        this.close();\n    }\n    sendData_(data) {\n        if (this.state_ !== 1 /* RealtimeState.CONNECTED */ ) {\n            throw \"Connection is not connected\";\n        } else {\n            this.tx_.send(data);\n        }\n    }\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */ close() {\n        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n            this.log_(\"Closing realtime connection.\");\n            this.state_ = 2 /* RealtimeState.DISCONNECTED */ ;\n            this.closeConnections_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_();\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    closeConnections_() {\n        this.log_(\"Shutting down all connections\");\n        if (this.conn_) {\n            this.conn_.close();\n            this.conn_ = null;\n        }\n        if (this.secondaryConn_) {\n            this.secondaryConn_.close();\n            this.secondaryConn_ = null;\n        }\n        if (this.healthyTimeout_) {\n            clearTimeout(this.healthyTimeout_);\n            this.healthyTimeout_ = null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */ class ServerActions {\n    put(pathString, data, onComplete, hash) {}\n    merge(pathString, data, onComplete, hash) {}\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */ refreshAuthToken(token) {}\n    /**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */ refreshAppCheckToken(token) {}\n    onDisconnectPut(pathString, data, onComplete) {}\n    onDisconnectMerge(pathString, data, onComplete) {}\n    onDisconnectCancel(pathString, onComplete) {}\n    reportStats(stats) {}\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */ class EventEmitter {\n    constructor(allowedEvents_){\n        this.allowedEvents_ = allowedEvents_;\n        this.listeners_ = {};\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, \"Requires a non-empty array\");\n    }\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     */ trigger(eventType, ...varArgs) {\n        if (Array.isArray(this.listeners_[eventType])) {\n            // Clone the list, since callbacks could add/remove listeners.\n            const listeners = [\n                ...this.listeners_[eventType]\n            ];\n            for(let i = 0; i < listeners.length; i++){\n                listeners[i].callback.apply(listeners[i].context, varArgs);\n            }\n        }\n    }\n    on(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\n        this.listeners_[eventType].push({\n            callback,\n            context\n        });\n        const eventData = this.getInitialEvent(eventType);\n        if (eventData) {\n            callback.apply(context, eventData);\n        }\n    }\n    off(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        const listeners = this.listeners_[eventType] || [];\n        for(let i = 0; i < listeners.length; i++){\n            if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {\n                listeners.splice(i, 1);\n                return;\n            }\n        }\n    }\n    validateEventType_(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.allowedEvents_.find((et)=>{\n            return et === eventType;\n        }), \"Unknown event: \" + eventType);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */ class OnlineMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"online\"\n        ]);\n        this.online_ = true;\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\n        // for Cordova.\n        if (false) {}\n    }\n    static getInstance() {\n        return new OnlineMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"online\", \"Unknown event type: \" + eventType);\n        return [\n            this.online_\n        ];\n    }\n    currentlyOnline() {\n        return this.online_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Maximum key depth. */ const MAX_PATH_DEPTH = 32;\n/** Maximum number of (UTF8) bytes in a Firebase path. */ const MAX_PATH_LENGTH_BYTES = 768;\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */ class Path {\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */ constructor(pathOrString, pieceNum){\n        if (pieceNum === void 0) {\n            this.pieces_ = pathOrString.split(\"/\");\n            // Remove empty pieces.\n            let copyTo = 0;\n            for(let i = 0; i < this.pieces_.length; i++){\n                if (this.pieces_[i].length > 0) {\n                    this.pieces_[copyTo] = this.pieces_[i];\n                    copyTo++;\n                }\n            }\n            this.pieces_.length = copyTo;\n            this.pieceNum_ = 0;\n        } else {\n            this.pieces_ = pathOrString;\n            this.pieceNum_ = pieceNum;\n        }\n    }\n    toString() {\n        let pathString = \"\";\n        for(let i = this.pieceNum_; i < this.pieces_.length; i++){\n            if (this.pieces_[i] !== \"\") {\n                pathString += \"/\" + this.pieces_[i];\n            }\n        }\n        return pathString || \"/\";\n    }\n}\nfunction newEmptyPath() {\n    return new Path(\"\");\n}\nfunction pathGetFront(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    return path.pieces_[path.pieceNum_];\n}\n/**\r\n * @returns The number of segments in this path\r\n */ function pathGetLength(path) {\n    return path.pieces_.length - path.pieceNum_;\n}\nfunction pathPopFront(path) {\n    let pieceNum = path.pieceNum_;\n    if (pieceNum < path.pieces_.length) {\n        pieceNum++;\n    }\n    return new Path(path.pieces_, pieceNum);\n}\nfunction pathGetBack(path) {\n    if (path.pieceNum_ < path.pieces_.length) {\n        return path.pieces_[path.pieces_.length - 1];\n    }\n    return null;\n}\nfunction pathToUrlEncodedString(path) {\n    let pathString = \"\";\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        if (path.pieces_[i] !== \"\") {\n            pathString += \"/\" + encodeURIComponent(String(path.pieces_[i]));\n        }\n    }\n    return pathString || \"/\";\n}\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */ function pathSlice(path, begin = 0) {\n    return path.pieces_.slice(path.pieceNum_ + begin);\n}\nfunction pathParent(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length - 1; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    return new Path(pieces, 0);\n}\nfunction pathChild(path, childPathObj) {\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    if (childPathObj instanceof Path) {\n        for(let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++){\n            pieces.push(childPathObj.pieces_[i]);\n        }\n    } else {\n        const childPieces = childPathObj.split(\"/\");\n        for(let i = 0; i < childPieces.length; i++){\n            if (childPieces[i].length > 0) {\n                pieces.push(childPieces[i]);\n            }\n        }\n    }\n    return new Path(pieces, 0);\n}\n/**\r\n * @returns True if there are no segments in this path\r\n */ function pathIsEmpty(path) {\n    return path.pieceNum_ >= path.pieces_.length;\n}\n/**\r\n * @returns The path from outerPath to innerPath\r\n */ function newRelativePath(outerPath, innerPath) {\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\n    if (outer === null) {\n        return innerPath;\n    } else if (outer === inner) {\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\n    } else {\n        throw new Error(\"INTERNAL ERROR: innerPath (\" + innerPath + \") is not within \" + \"outerPath (\" + outerPath + \")\");\n    }\n}\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */ function pathCompare(left, right) {\n    const leftKeys = pathSlice(left, 0);\n    const rightKeys = pathSlice(right, 0);\n    for(let i = 0; i < leftKeys.length && i < rightKeys.length; i++){\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    if (leftKeys.length === rightKeys.length) {\n        return 0;\n    }\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n}\n/**\r\n * @returns true if paths are the same.\r\n */ function pathEquals(path, other) {\n    if (pathGetLength(path) !== pathGetLength(other)) {\n        return false;\n    }\n    for(let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */ function pathContains(path, other) {\n    let i = path.pieceNum_;\n    let j = other.pieceNum_;\n    if (pathGetLength(path) > pathGetLength(other)) {\n        return false;\n    }\n    while(i < path.pieces_.length){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    }\n    return true;\n}\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */ class ValidationPath {\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */ constructor(path, errorPrefix_){\n        this.errorPrefix_ = errorPrefix_;\n        this.parts_ = pathSlice(path, 0);\n        /** Initialize to number of '/' chars needed in path. */ this.byteLength_ = Math.max(1, this.parts_.length);\n        for(let i = 0; i < this.parts_.length; i++){\n            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(this.parts_[i]);\n        }\n        validationPathCheckValid(this);\n    }\n}\nfunction validationPathPush(validationPath, child) {\n    // Count the needed '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ += 1;\n    }\n    validationPath.parts_.push(child);\n    validationPath.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(child);\n    validationPathCheckValid(validationPath);\n}\nfunction validationPathPop(validationPath) {\n    const last = validationPath.parts_.pop();\n    validationPath.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(last);\n    // Un-count the previous '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ -= 1;\n    }\n}\nfunction validationPathCheckValid(validationPath) {\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\n        throw new Error(validationPath.errorPrefix_ + \"has a key path longer than \" + MAX_PATH_LENGTH_BYTES + \" bytes (\" + validationPath.byteLength_ + \").\");\n    }\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\n        throw new Error(validationPath.errorPrefix_ + \"path specified exceeds the maximum depth that can be written (\" + MAX_PATH_DEPTH + \") or object contains a cycle \" + validationPathToErrorString(validationPath));\n    }\n}\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */ function validationPathToErrorString(validationPath) {\n    if (validationPath.parts_.length === 0) {\n        return \"\";\n    }\n    return \"in property '\" + validationPath.parts_.join(\".\") + \"'\";\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class VisibilityMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"visible\"\n        ]);\n        let hidden;\n        let visibilityChange;\n        if (typeof document !== \"undefined\" && typeof document.addEventListener !== \"undefined\") {\n            if (typeof document[\"hidden\"] !== \"undefined\") {\n                // Opera 12.10 and Firefox 18 and later support\n                visibilityChange = \"visibilitychange\";\n                hidden = \"hidden\";\n            } else if (typeof document[\"mozHidden\"] !== \"undefined\") {\n                visibilityChange = \"mozvisibilitychange\";\n                hidden = \"mozHidden\";\n            } else if (typeof document[\"msHidden\"] !== \"undefined\") {\n                visibilityChange = \"msvisibilitychange\";\n                hidden = \"msHidden\";\n            } else if (typeof document[\"webkitHidden\"] !== \"undefined\") {\n                visibilityChange = \"webkitvisibilitychange\";\n                hidden = \"webkitHidden\";\n            }\n        }\n        // Initially, we always assume we are visible. This ensures that in browsers\n        // without page visibility support or in cases where we are never visible\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\n        // reconnects\n        this.visible_ = true;\n        if (visibilityChange) {\n            document.addEventListener(visibilityChange, ()=>{\n                const visible = !document[hidden];\n                if (visible !== this.visible_) {\n                    this.visible_ = visible;\n                    this.trigger(\"visible\", visible);\n                }\n            }, false);\n        }\n    }\n    static getInstance() {\n        return new VisibilityMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"visible\", \"Unknown event type: \" + eventType);\n        return [\n            this.visible_\n        ];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = \"server_kill\";\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_TOKEN_THRESHOLD = 3;\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */ class PersistentConnection extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.onConnectStatus_ = onConnectStatus_;\n        this.onServerInfoUpdate_ = onServerInfoUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        this.authOverride_ = authOverride_;\n        // Used for diagnostic logging.\n        this.id = PersistentConnection.nextPersistentConnectionId_++;\n        this.log_ = logWrapper(\"p:\" + this.id + \":\");\n        this.interruptReasons_ = {};\n        this.listens = new Map();\n        this.outstandingPuts_ = [];\n        this.outstandingGets_ = [];\n        this.outstandingPutCount_ = 0;\n        this.outstandingGetCount_ = 0;\n        this.onDisconnectRequestQueue_ = [];\n        this.connected_ = false;\n        this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n        this.securityDebugCallback_ = null;\n        this.lastSessionId = null;\n        this.establishConnectionTimer_ = null;\n        this.visible_ = false;\n        // Before we get connected, we keep a queue of pending messages to send.\n        this.requestCBHash_ = {};\n        this.requestNumber_ = 0;\n        this.realtime_ = null;\n        this.authToken_ = null;\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = false;\n        this.invalidAuthTokenCount_ = 0;\n        this.invalidAppCheckTokenCount_ = 0;\n        this.firstConnection_ = true;\n        this.lastConnectionAttemptTime_ = null;\n        this.lastConnectionEstablishedTime_ = null;\n        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            throw new Error(\"Auth override specified in options, but not supported on non Node.js platforms\");\n        }\n        VisibilityMonitor.getInstance().on(\"visible\", this.onVisible_, this);\n        if (repoInfo_.host.indexOf(\"fblocal\") === -1) {\n            OnlineMonitor.getInstance().on(\"online\", this.onOnline_, this);\n        }\n    }\n    sendRequest(action, body, onResponse) {\n        const curReqNum = ++this.requestNumber_;\n        const msg = {\n            r: curReqNum,\n            a: action,\n            b: body\n        };\n        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(msg));\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n        this.realtime_.sendRequest(msg);\n        if (onResponse) {\n            this.requestCBHash_[curReqNum] = onResponse;\n        }\n    }\n    get(query) {\n        this.initConnection_();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        const request = {\n            p: query._path.toString(),\n            q: query._queryObject\n        };\n        const outstandingGet = {\n            action: \"g\",\n            request,\n            onComplete: (message)=>{\n                const payload = message[\"d\"];\n                if (message[\"s\"] === \"ok\") {\n                    deferred.resolve(payload);\n                } else {\n                    deferred.reject(payload);\n                }\n            }\n        };\n        this.outstandingGets_.push(outstandingGet);\n        this.outstandingGetCount_++;\n        const index = this.outstandingGets_.length - 1;\n        if (this.connected_) {\n            this.sendGet_(index);\n        }\n        return deferred.promise;\n    }\n    listen(query, currentHashFn, tag, onComplete) {\n        this.initConnection_();\n        const queryId = query._queryIdentifier;\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + queryId);\n        if (!this.listens.has(pathString)) {\n            this.listens.set(pathString, new Map());\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"listen() called for non-default but complete query\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);\n        const listenSpec = {\n            onComplete,\n            hashFn: currentHashFn,\n            query,\n            tag\n        };\n        this.listens.get(pathString).set(queryId, listenSpec);\n        if (this.connected_) {\n            this.sendListen_(listenSpec);\n        }\n    }\n    sendGet_(index) {\n        const get = this.outstandingGets_[index];\n        this.sendRequest(\"g\", get.request, (message)=>{\n            delete this.outstandingGets_[index];\n            this.outstandingGetCount_--;\n            if (this.outstandingGetCount_ === 0) {\n                this.outstandingGets_ = [];\n            }\n            if (get.onComplete) {\n                get.onComplete(message);\n            }\n        });\n    }\n    sendListen_(listenSpec) {\n        const query = listenSpec.query;\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Listen on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"q\";\n        // Only bother to send query if it's non-default.\n        if (listenSpec.tag) {\n            req[\"q\"] = query._queryObject;\n            req[\"t\"] = listenSpec.tag;\n        }\n        req[/*hash*/ \"h\"] = listenSpec.hashFn();\n        this.sendRequest(action, req, (message)=>{\n            const payload = message[/*data*/ \"d\"];\n            const status = message[/*status*/ \"s\"];\n            // print warnings in any case...\n            PersistentConnection.warnOnListenWarnings_(payload, query);\n            const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);\n            // only trigger actions if the listen hasn't been removed and readded\n            if (currentListenSpec === listenSpec) {\n                this.log_(\"listen response\", message);\n                if (status !== \"ok\") {\n                    this.removeListen_(pathString, queryId);\n                }\n                if (listenSpec.onComplete) {\n                    listenSpec.onComplete(status, payload);\n                }\n            }\n        });\n    }\n    static warnOnListenWarnings_(payload, query) {\n        if (payload && typeof payload === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(payload, \"w\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(payload, \"w\");\n            if (Array.isArray(warnings) && ~warnings.indexOf(\"no_index\")) {\n                const indexSpec = '\".indexOn\": \"' + query._queryParams.getIndex().toString() + '\"';\n                const indexPath = query._path.toString();\n                warn(`Using an unspecified index. Your data will be downloaded and ` + `filtered on the client. Consider adding ${indexSpec} at ` + `${indexPath} to your security rules for better performance.`);\n            }\n        }\n    }\n    refreshAuthToken(token) {\n        this.authToken_ = token;\n        this.log_(\"Auth token refreshed\");\n        if (this.authToken_) {\n            this.tryAuth();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n            //the credential so we dont become authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unauth\", {}, ()=>{});\n            }\n        }\n        this.reduceReconnectDelayIfAdminCredential_(token);\n    }\n    reduceReconnectDelayIfAdminCredential_(credential) {\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n        const isFirebaseSecret = credential && credential.length === 40;\n        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isAdmin)(credential)) {\n            this.log_(\"Admin auth credential detected.  Reducing max reconnect time.\");\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        }\n    }\n    refreshAppCheckToken(token) {\n        this.appCheckToken_ = token;\n        this.log_(\"App check token refreshed\");\n        if (this.appCheckToken_) {\n            this.tryAppCheck();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us.\n            //If we're not connected, simply delete the credential so we dont become\n            // authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unappeck\", {}, ()=>{});\n            }\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */ tryAuth() {\n        if (this.connected_ && this.authToken_) {\n            const token = this.authToken_;\n            const authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isValidFormat)(token) ? \"auth\" : \"gauth\";\n            const requestData = {\n                cred: token\n            };\n            if (this.authOverride_ === null) {\n                requestData[\"noauth\"] = true;\n            } else if (typeof this.authOverride_ === \"object\") {\n                requestData[\"authvar\"] = this.authOverride_;\n            }\n            this.sendRequest(authMethod, requestData, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (this.authToken_ === token) {\n                    if (status === \"ok\") {\n                        this.invalidAuthTokenCount_ = 0;\n                    } else {\n                        // Triggers reconnect and force refresh for auth token\n                        this.onAuthRevoked_(status, data);\n                    }\n                }\n            });\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */ tryAppCheck() {\n        if (this.connected_ && this.appCheckToken_) {\n            this.sendRequest(\"appcheck\", {\n                \"token\": this.appCheckToken_\n            }, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (status === \"ok\") {\n                    this.invalidAppCheckTokenCount_ = 0;\n                } else {\n                    this.onAppCheckRevoked_(status, data);\n                }\n            });\n        }\n    }\n    /**\r\n     * @inheritDoc\r\n     */ unlisten(query, tag) {\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Unlisten called for \" + pathString + \" \" + queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"unlisten() called for non-default but complete query\");\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && this.connected_) {\n            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);\n        }\n    }\n    sendUnlisten_(pathString, queryId, queryObj, tag) {\n        this.log_(\"Unlisten on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"n\";\n        // Only bother sending queryId if it's non-default.\n        if (tag) {\n            req[\"q\"] = queryObj;\n            req[\"t\"] = tag;\n        }\n        this.sendRequest(action, req);\n    }\n    onDisconnectPut(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"o\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"o\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectMerge(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"om\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"om\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectCancel(pathString, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"oc\", pathString, null, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"oc\",\n                data: null,\n                onComplete\n            });\n        }\n    }\n    sendOnDisconnect_(action, pathString, data, onComplete) {\n        const request = {\n            p: pathString,\n            /*data*/ d: data\n        };\n        this.log_(\"onDisconnect \" + action, request);\n        this.sendRequest(action, request, (response)=>{\n            if (onComplete) {\n                setTimeout(()=>{\n                    onComplete(response[/*status*/ \"s\"], response[/* data */ \"d\"]);\n                }, Math.floor(0));\n            }\n        });\n    }\n    put(pathString, data, onComplete, hash) {\n        this.putInternal(\"p\", pathString, data, onComplete, hash);\n    }\n    merge(pathString, data, onComplete, hash) {\n        this.putInternal(\"m\", pathString, data, onComplete, hash);\n    }\n    putInternal(action, pathString, data, onComplete, hash) {\n        this.initConnection_();\n        const request = {\n            /*path*/ p: pathString,\n            /*data*/ d: data\n        };\n        if (hash !== undefined) {\n            request[/*hash*/ \"h\"] = hash;\n        }\n        // TODO: Only keep track of the most recent put for a given path?\n        this.outstandingPuts_.push({\n            action,\n            request,\n            onComplete\n        });\n        this.outstandingPutCount_++;\n        const index = this.outstandingPuts_.length - 1;\n        if (this.connected_) {\n            this.sendPut_(index);\n        } else {\n            this.log_(\"Buffering put: \" + pathString);\n        }\n    }\n    sendPut_(index) {\n        const action = this.outstandingPuts_[index].action;\n        const request = this.outstandingPuts_[index].request;\n        const onComplete = this.outstandingPuts_[index].onComplete;\n        this.outstandingPuts_[index].queued = this.connected_;\n        this.sendRequest(action, request, (message)=>{\n            this.log_(action + \" response\", message);\n            delete this.outstandingPuts_[index];\n            this.outstandingPutCount_--;\n            // Clean up array occasionally.\n            if (this.outstandingPutCount_ === 0) {\n                this.outstandingPuts_ = [];\n            }\n            if (onComplete) {\n                onComplete(message[/*status*/ \"s\"], message[/* data */ \"d\"]);\n            }\n        });\n    }\n    reportStats(stats) {\n        // If we're not connected, we just drop the stats.\n        if (this.connected_) {\n            const request = {\n                c: stats\n            };\n            this.log_(\"reportStats\", request);\n            this.sendRequest(/*stats*/ \"s\", request, (result)=>{\n                const status = result[/*status*/ \"s\"];\n                if (status !== \"ok\") {\n                    const errorReason = result[/* data */ \"d\"];\n                    this.log_(\"reportStats\", \"Error sending stats: \" + errorReason);\n                }\n            });\n        }\n    }\n    onDataMessage_(message) {\n        if (\"r\" in message) {\n            // this is a response\n            this.log_(\"from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(message));\n            const reqNum = message[\"r\"];\n            const onResponse = this.requestCBHash_[reqNum];\n            if (onResponse) {\n                delete this.requestCBHash_[reqNum];\n                onResponse(message[/*body*/ \"b\"]);\n            }\n        } else if (\"error\" in message) {\n            throw \"A server-side error has occurred: \" + message[\"error\"];\n        } else if (\"a\" in message) {\n            // a and b are action and body, respectively\n            this.onDataPush_(message[\"a\"], message[\"b\"]);\n        }\n    }\n    onDataPush_(action, body) {\n        this.log_(\"handleServerMessage\", action, body);\n        if (action === \"d\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge*/ false, body[\"t\"]);\n        } else if (action === \"m\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge=*/ true, body[\"t\"]);\n        } else if (action === \"c\") {\n            this.onListenRevoked_(body[/*path*/ \"p\"], body[/*query*/ \"q\"]);\n        } else if (action === \"ac\") {\n            this.onAuthRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"apc\") {\n            this.onAppCheckRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"sd\") {\n            this.onSecurityDebugPacket_(body);\n        } else {\n            error(\"Unrecognized action received from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(action) + \"\\nAre you using the latest client?\");\n        }\n    }\n    onReady_(timestamp, sessionId) {\n        this.log_(\"connection ready\");\n        this.connected_ = true;\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\n        this.handleTimestamp_(timestamp);\n        this.lastSessionId = sessionId;\n        if (this.firstConnection_) {\n            this.sendConnectStats_();\n        }\n        this.restoreState_();\n        this.firstConnection_ = false;\n        this.onConnectStatus_(true);\n    }\n    scheduleConnect_(timeout) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n        if (this.establishConnectionTimer_) {\n            clearTimeout(this.establishConnectionTimer_);\n        }\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n        this.establishConnectionTimer_ = setTimeout(()=>{\n            this.establishConnectionTimer_ = null;\n            this.establishConnection_();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(timeout));\n    }\n    initConnection_() {\n        if (!this.realtime_ && this.firstConnection_) {\n            this.scheduleConnect_(0);\n        }\n    }\n    onVisible_(visible) {\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n            this.log_(\"Window became visible.  Reducing delay.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        this.visible_ = visible;\n    }\n    onOnline_(online) {\n        if (online) {\n            this.log_(\"Browser went online.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        } else {\n            this.log_(\"Browser went offline.  Killing connection.\");\n            if (this.realtime_) {\n                this.realtime_.close();\n            }\n        }\n    }\n    onRealtimeDisconnect_() {\n        this.log_(\"data client disconnected\");\n        this.connected_ = false;\n        this.realtime_ = null;\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n        this.cancelSentTransactions_();\n        // Clear out the pending requests.\n        this.requestCBHash_ = {};\n        if (this.shouldReconnect_()) {\n            if (!this.visible_) {\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\n                this.reconnectDelay_ = this.maxReconnectDelay_;\n                this.lastConnectionAttemptTime_ = new Date().getTime();\n            } else if (this.lastConnectionEstablishedTime_) {\n                // If we've been connected long enough, reset reconnect delay to minimum.\n                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n                }\n                this.lastConnectionEstablishedTime_ = null;\n            }\n            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n            reconnectDelay = Math.random() * reconnectDelay;\n            this.log_(\"Trying to reconnect in \" + reconnectDelay + \"ms\");\n            this.scheduleConnect_(reconnectDelay);\n            // Adjust reconnect delay for next time.\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n        }\n        this.onConnectStatus_(false);\n    }\n    async establishConnection_() {\n        if (this.shouldReconnect_()) {\n            this.log_(\"Making a connection attempt\");\n            this.lastConnectionAttemptTime_ = new Date().getTime();\n            this.lastConnectionEstablishedTime_ = null;\n            const onDataMessage = this.onDataMessage_.bind(this);\n            const onReady = this.onReady_.bind(this);\n            const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n            const connId = this.id + \":\" + PersistentConnection.nextConnectionId_++;\n            const lastSessionId = this.lastSessionId;\n            let canceled = false;\n            let connection = null;\n            const closeFn = function() {\n                if (connection) {\n                    connection.close();\n                } else {\n                    canceled = true;\n                    onDisconnect();\n                }\n            };\n            const sendRequestFn = function(msg) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(connection, \"sendRequest call when we're not connected not allowed.\");\n                connection.sendRequest(msg);\n            };\n            this.realtime_ = {\n                close: closeFn,\n                sendRequest: sendRequestFn\n            };\n            const forceRefresh = this.forceTokenRefresh_;\n            this.forceTokenRefresh_ = false;\n            try {\n                // First fetch auth and app check token, and establish connection after\n                // fetching the token was successful\n                const [authToken, appCheckToken] = await Promise.all([\n                    this.authTokenProvider_.getToken(forceRefresh),\n                    this.appCheckTokenProvider_.getToken(forceRefresh)\n                ]);\n                if (!canceled) {\n                    log(\"getToken() completed. Creating connection.\");\n                    this.authToken_ = authToken && authToken.accessToken;\n                    this.appCheckToken_ = appCheckToken && appCheckToken.token;\n                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, /* onKill= */ (reason)=>{\n                        warn(reason + \" (\" + this.repoInfo_.toString() + \")\");\n                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);\n                    }, lastSessionId);\n                } else {\n                    log(\"getToken() completed but was canceled\");\n                }\n            } catch (error) {\n                this.log_(\"Failed to get token: \" + error);\n                if (!canceled) {\n                    if (this.repoInfo_.nodeAdmin) {\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\n                        // But getToken() may also just have temporarily failed, so we still want to\n                        // continue retrying.\n                        warn(error);\n                    }\n                    closeFn();\n                }\n            }\n        }\n    }\n    interrupt(reason) {\n        log(\"Interrupting connection for reason: \" + reason);\n        this.interruptReasons_[reason] = true;\n        if (this.realtime_) {\n            this.realtime_.close();\n        } else {\n            if (this.establishConnectionTimer_) {\n                clearTimeout(this.establishConnectionTimer_);\n                this.establishConnectionTimer_ = null;\n            }\n            if (this.connected_) {\n                this.onRealtimeDisconnect_();\n            }\n        }\n    }\n    resume(reason) {\n        log(\"Resuming connection for reason: \" + reason);\n        delete this.interruptReasons_[reason];\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_)) {\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n    }\n    handleTimestamp_(timestamp) {\n        const delta = timestamp - new Date().getTime();\n        this.onServerInfoUpdate_({\n            serverTimeOffset: delta\n        });\n    }\n    cancelSentTransactions_() {\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            const put = this.outstandingPuts_[i];\n            if (put && /*hash*/ \"h\" in put.request && put.queued) {\n                if (put.onComplete) {\n                    put.onComplete(\"disconnect\");\n                }\n                delete this.outstandingPuts_[i];\n                this.outstandingPutCount_--;\n            }\n        }\n        // Clean up array occasionally.\n        if (this.outstandingPutCount_ === 0) {\n            this.outstandingPuts_ = [];\n        }\n    }\n    onListenRevoked_(pathString, query) {\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n        let queryId;\n        if (!query) {\n            queryId = \"default\";\n        } else {\n            queryId = query.map((q)=>ObjectToUniqueKey(q)).join(\"$\");\n        }\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && listen.onComplete) {\n            listen.onComplete(\"permission_denied\");\n        }\n    }\n    removeListen_(pathString, queryId) {\n        const normalizedPathString = new Path(pathString).toString(); // normalize path.\n        let listen;\n        if (this.listens.has(normalizedPathString)) {\n            const map = this.listens.get(normalizedPathString);\n            listen = map.get(queryId);\n            map.delete(queryId);\n            if (map.size === 0) {\n                this.listens.delete(normalizedPathString);\n            }\n        } else {\n            // all listens for this path has already been removed\n            listen = undefined;\n        }\n        return listen;\n    }\n    onAuthRevoked_(statusCode, explanation) {\n        log(\"Auth token revoked: \" + statusCode + \"/\" + explanation);\n        this.authToken_ = null;\n        this.forceTokenRefresh_ = true;\n        this.realtime_.close();\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAuthTokenCount_++;\n            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                // Set a long reconnect delay because recovery is unlikely\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n                // Notify the auth token provider that the token is invalid, which will log\n                // a warning\n                this.authTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onAppCheckRevoked_(statusCode, explanation) {\n        log(\"App check token revoked: \" + statusCode + \"/\" + explanation);\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = true;\n        // Note: We don't close the connection as the developer may not have\n        // enforcement enabled. The backend closes connections with enforcements.\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAppCheckTokenCount_++;\n            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                this.appCheckTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onSecurityDebugPacket_(body) {\n        if (this.securityDebugCallback_) {\n            this.securityDebugCallback_(body);\n        } else {\n            if (\"msg\" in body) {\n                console.log(\"FIREBASE: \" + body[\"msg\"].replace(\"\\n\", \"\\nFIREBASE: \"));\n            }\n        }\n    }\n    restoreState_() {\n        //Re-authenticate ourselves if we have a credential stored.\n        this.tryAuth();\n        this.tryAppCheck();\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\n        // make sure to send listens before puts.\n        for (const queries of this.listens.values()){\n            for (const listenSpec of queries.values()){\n                this.sendListen_(listenSpec);\n            }\n        }\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            if (this.outstandingPuts_[i]) {\n                this.sendPut_(i);\n            }\n        }\n        while(this.onDisconnectRequestQueue_.length){\n            const request = this.onDisconnectRequestQueue_.shift();\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n        }\n        for(let i = 0; i < this.outstandingGets_.length; i++){\n            if (this.outstandingGets_[i]) {\n                this.sendGet_(i);\n            }\n        }\n    }\n    /**\r\n     * Sends client stats for first connection\r\n     */ sendConnectStats_() {\n        const stats = {};\n        let clientName = \"js\";\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            if (this.repoInfo_.nodeAdmin) {\n                clientName = \"admin_node\";\n            } else {\n                clientName = \"node\";\n            }\n        }\n        stats[\"sdk.\" + clientName + \".\" + SDK_VERSION.replace(/\\./g, \"-\")] = 1;\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)()) {\n            stats[\"framework.cordova\"] = 1;\n        } else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)()) {\n            stats[\"framework.reactnative\"] = 1;\n        }\n        this.reportStats(stats);\n    }\n    shouldReconnect_() {\n        const online = OnlineMonitor.getInstance().currentlyOnline();\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_) && online;\n    }\n}\nPersistentConnection.nextPersistentConnectionId_ = 0;\n/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */ PersistentConnection.nextConnectionId_ = 0;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class NamedNode {\n    constructor(name, node){\n        this.name = name;\n        this.node = node;\n    }\n    static Wrap(name, node) {\n        return new NamedNode(name, node);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Index {\n    /**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */ getCompare() {\n        return this.compare.bind(this);\n    }\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */ indexedValueChanged(oldNode, newNode) {\n        const oldWrapped = new NamedNode(MIN_NAME, oldNode);\n        const newWrapped = new NamedNode(MIN_NAME, newNode);\n        return this.compare(oldWrapped, newWrapped) !== 0;\n    }\n    /**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */ minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __EMPTY_NODE;\nclass KeyIndex extends Index {\n    static get __EMPTY_NODE() {\n        return __EMPTY_NODE;\n    }\n    static set __EMPTY_NODE(val) {\n        __EMPTY_NODE = val;\n    }\n    compare(a, b) {\n        return nameCompare(a.name, b.name);\n    }\n    isDefinedOn(node) {\n        // We could probably return true here (since every node has a key), but it's never called\n        // so just leaving unimplemented for now.\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"KeyIndex.isDefinedOn not expected to be called.\");\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return false; // The key for a node never changes.\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // TODO: This should really be created once and cached in a static property, but\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\n    }\n    makePost(indexValue, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof indexValue === \"string\", \"KeyIndex indexValue must always be a string.\");\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n        return new NamedNode(indexValue, __EMPTY_NODE);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".key\";\n    }\n}\nconst KEY_INDEX = new KeyIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An iterator over an LLRBNode.\r\n */ class SortedMapIterator {\n    /**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */ constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null){\n        this.isReverse_ = isReverse_;\n        this.resultGenerator_ = resultGenerator_;\n        this.nodeStack_ = [];\n        let cmp = 1;\n        while(!node.isEmpty()){\n            node = node;\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse_) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse_) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            } else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n                this.nodeStack_.push(node);\n                break;\n            } else {\n                // This node is greater than our start key, add it to the stack and move to the next one\n                this.nodeStack_.push(node);\n                if (this.isReverse_) {\n                    node = node.right;\n                } else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        let node = this.nodeStack_.pop();\n        let result;\n        if (this.resultGenerator_) {\n            result = this.resultGenerator_(node.key, node.value);\n        } else {\n            result = {\n                key: node.key,\n                value: node.value\n            };\n        }\n        if (this.isReverse_) {\n            node = node.left;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.right;\n            }\n        } else {\n            node = node.right;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack_.length > 0;\n    }\n    peek() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack_[this.nodeStack_.length - 1];\n        if (this.resultGenerator_) {\n            return this.resultGenerator_(node.key, node.value);\n        } else {\n            return {\n                key: node.key,\n                value: node.value\n            };\n        }\n    }\n}\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */ class LLRBNode {\n    /**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */ constructor(key, value, color, left, right){\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : SortedMap.EMPTY_NODE;\n        this.right = right != null ? right : SortedMap.EMPTY_NODE;\n    }\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return this.left.count() + 1 + this.right.count();\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n    }\n    /**\r\n     * @returns The minimum node in the tree.\r\n     */ min_() {\n        if (this.left.isEmpty()) {\n            return this;\n        } else {\n            return this.left.min_();\n        }\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ minKey() {\n        return this.min_().key;\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        } else {\n            return this.right.maxKey();\n        }\n    }\n    /**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */ insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        } else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        } else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns New tree, with the minimum key removed.\r\n     */ removeMin_() {\n        if (this.left.isEmpty()) {\n            return SortedMap.EMPTY_NODE;\n        }\n        let n = this;\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\n            n = n.moveRedLeft_();\n        }\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\n        return n.fixUp_();\n    }\n    /**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */ remove(key, comparator) {\n        let n, smallest;\n        n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n                n = n.moveRedLeft_();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        } else {\n            if (n.left.isRed_()) {\n                n = n.rotateRight_();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n                n = n.moveRedRight_();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return SortedMap.EMPTY_NODE;\n                } else {\n                    smallest = n.right.min_();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns Whether this is a RED node.\r\n     */ isRed_() {\n        return this.color;\n    }\n    /**\r\n     * @returns New tree after performing any needed rotations.\r\n     */ fixUp_() {\n        let n = this;\n        if (n.right.isRed_() && !n.left.isRed_()) {\n            n = n.rotateLeft_();\n        }\n        if (n.left.isRed_() && n.left.left.isRed_()) {\n            n = n.rotateRight_();\n        }\n        if (n.left.isRed_() && n.right.isRed_()) {\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedLeft.\r\n     */ moveRedLeft_() {\n        let n = this.colorFlip_();\n        if (n.right.left.isRed_()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\n            n = n.rotateLeft_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedRight.\r\n     */ moveRedRight_() {\n        let n = this.colorFlip_();\n        if (n.left.left.isRed_()) {\n            n = n.rotateRight_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after rotateLeft.\r\n     */ rotateLeft_() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    /**\r\n     * @returns New tree, after rotateRight.\r\n     */ rotateRight_() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    /**\r\n     * @returns Newt ree, after colorFlip.\r\n     */ colorFlip_() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    /**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */ checkMaxDepth_() {\n        const blackDepth = this.check_();\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\n    }\n    check_() {\n        if (this.isRed_() && this.left.isRed_()) {\n            throw new Error(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n        }\n        if (this.right.isRed_()) {\n            throw new Error(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n        }\n        const blackDepth = this.left.check_();\n        if (blackDepth !== this.right.check_()) {\n            throw new Error(\"Black depths differ\");\n        } else {\n            return blackDepth + (this.isRed_() ? 0 : 1);\n        }\n    }\n}\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */ class LLRBEmptyNode {\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return this;\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */ insert(key, value, comparator) {\n        return new LLRBNode(key, value, null);\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */ remove(key, comparator) {\n        return this;\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return 0;\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return true;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ inorderTraversal(action) {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    check_() {\n        return 0;\n    }\n    /**\r\n     * @returns Whether this node is red.\r\n     */ isRed_() {\n        return false;\n    }\n}\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */ class SortedMap {\n    /**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */ constructor(comparator_, root_ = SortedMap.EMPTY_NODE){\n        this.comparator_ = comparator_;\n        this.root_ = root_;\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */ insert(key, value) {\n        return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */ remove(key) {\n        return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */ get(key) {\n        let cmp;\n        let node = this.root_;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */ getPredecessorKey(key) {\n        let cmp, node = this.root_, rightParent = null;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while(!node.right.isEmpty()){\n                        node = node.right;\n                    }\n                    return node.key;\n                } else if (rightParent) {\n                    return rightParent.key;\n                } else {\n                    return null; // first item.\n                }\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw new Error(\"Attempted to find predecessor key for a nonexistent key.  What gives?\");\n    }\n    /**\r\n     * @returns True if the map is empty.\r\n     */ isEmpty() {\n        return this.root_.isEmpty();\n    }\n    /**\r\n     * @returns The total number of nodes in the map.\r\n     */ count() {\n        return this.root_.count();\n    }\n    /**\r\n     * @returns The minimum key in the map.\r\n     */ minKey() {\n        return this.root_.minKey();\n    }\n    /**\r\n     * @returns The maximum key in the map.\r\n     */ maxKey() {\n        return this.root_.maxKey();\n    }\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.root_.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.root_.reverseTraversal(action);\n    }\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */ getIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\n    }\n    getIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\n    }\n    getReverseIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\n    }\n    getReverseIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\n    }\n}\n/**\r\n * Always use the same empty node, to reduce memory.\r\n */ SortedMap.EMPTY_NODE = new LLRBEmptyNode();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function NAME_ONLY_COMPARATOR(left, right) {\n    return nameCompare(left.name, right.name);\n}\nfunction NAME_COMPARATOR(left, right) {\n    return nameCompare(left, right);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let MAX_NODE$2;\nfunction setMaxNode$1(val) {\n    MAX_NODE$2 = val;\n}\nconst priorityHashText = function(priority) {\n    if (typeof priority === \"number\") {\n        return \"number:\" + doubleToIEEE754String(priority);\n    } else {\n        return \"string:\" + priority;\n    }\n};\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n */ const validatePriorityNode = function(priorityNode) {\n    if (priorityNode.isLeafNode()) {\n        const val = priorityNode.val();\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof val === \"string\" || typeof val === \"number\" || typeof val === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(val, \".sv\"), \"Priority must be a string or number.\");\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), \"priority of unexpected type.\");\n    }\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __childrenNodeConstructor;\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */ class LeafNode {\n    /**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */ constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE){\n        this.value_ = value_;\n        this.priorityNode_ = priorityNode_;\n        this.lazyHash_ = null;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n        validatePriorityNode(this.priorityNode_);\n    }\n    static set __childrenNodeConstructor(val) {\n        __childrenNodeConstructor = val;\n    }\n    static get __childrenNodeConstructor() {\n        return __childrenNodeConstructor;\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return true;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        return new LeafNode(this.value_, newPriorityNode);\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        if (pathIsEmpty(path)) {\n            return this;\n        } else if (pathGetFront(path) === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    hasChild() {\n        return false;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode) {\n        return null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else if (newChildNode.isEmpty() && childName !== \".priority\") {\n            return this;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else if (newChildNode.isEmpty() && front !== \".priority\") {\n            return this;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(front !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return false;\n    }\n    /** @inheritDoc */ numChildren() {\n        return 0;\n    }\n    /** @inheritDoc */ forEachChild(index, action) {\n        return false;\n    }\n    val(exportFormat) {\n        if (exportFormat && !this.getPriority().isEmpty()) {\n            return {\n                \".value\": this.getValue(),\n                \".priority\": this.getPriority().val()\n            };\n        } else {\n            return this.getValue();\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.priorityNode_.isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.priorityNode_.val()) + \":\";\n            }\n            const type = typeof this.value_;\n            toHash += type + \":\";\n            if (type === \"number\") {\n                toHash += doubleToIEEE754String(this.value_);\n            } else {\n                toHash += this.value_;\n            }\n            this.lazyHash_ = sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */ getValue() {\n        return this.value_;\n    }\n    compareTo(other) {\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n            return 1;\n        } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n            return -1;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(other.isLeafNode(), \"Unknown node type\");\n            return this.compareToLeafNode_(other);\n        }\n    }\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     */ compareToLeafNode_(otherLeaf) {\n        const otherLeafType = typeof otherLeaf.value_;\n        const thisLeafType = typeof this.value_;\n        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(otherIndex >= 0, \"Unknown leaf type: \" + otherLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(thisIndex >= 0, \"Unknown leaf type: \" + thisLeafType);\n        if (otherIndex === thisIndex) {\n            // Same type, compare values\n            if (thisLeafType === \"object\") {\n                // Deferred value nodes are all equal, but we should also never get to this point...\n                return 0;\n            } else {\n                // Note that this works because true > false, all others are number or string comparisons\n                if (this.value_ < otherLeaf.value_) {\n                    return -1;\n                } else if (this.value_ === otherLeaf.value_) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            }\n        } else {\n            return thisIndex - otherIndex;\n        }\n    }\n    withIndex() {\n        return this;\n    }\n    isIndexed() {\n        return true;\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            const otherLeaf = other;\n            return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n        } else {\n            return false;\n        }\n    }\n}\n/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */ LeafNode.VALUE_TYPE_ORDER = [\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"string\"\n];\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let nodeFromJSON$1;\nlet MAX_NODE$1;\nfunction setNodeFromJSON(val) {\n    nodeFromJSON$1 = val;\n}\nfunction setMaxNode(val) {\n    MAX_NODE$1 = val;\n}\nclass PriorityIndex extends Index {\n    compare(a, b) {\n        const aPriority = a.node.getPriority();\n        const bPriority = b.node.getPriority();\n        const indexCmp = aPriority.compareTo(bPriority);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return !node.getPriority().isEmpty();\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.getPriority().equals(newNode.getPriority());\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        return new NamedNode(MAX_NAME, new LeafNode(\"[PRIORITY-POST]\", MAX_NODE$1));\n    }\n    makePost(indexValue, name) {\n        const priorityNode = nodeFromJSON$1(indexValue);\n        return new NamedNode(name, new LeafNode(\"[PRIORITY-POST]\", priorityNode));\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".priority\";\n    }\n}\nconst PRIORITY_INDEX = new PriorityIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_2 = Math.log(2);\nclass Base12Num {\n    constructor(length){\n        const logBase2 = (num)=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parseInt(Math.log(num) / LOG_2, 10);\n        const bitMask = (bits)=>parseInt(Array(bits + 1).join(\"1\"), 2);\n        this.count = logBase2(length + 1);\n        this.current_ = this.count - 1;\n        const mask = bitMask(this.count);\n        this.bits_ = length + 1 & mask;\n    }\n    nextBitIsOne() {\n        //noinspection JSBitwiseOperatorUsage\n        const result = !(this.bits_ & 0x1 << this.current_);\n        this.current_--;\n        return result;\n    }\n}\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */ const buildChildSet = function(childList, cmp, keyFn, mapSortFn) {\n    childList.sort(cmp);\n    const buildBalancedTree = function(low, high) {\n        const length = high - low;\n        let namedNode;\n        let key;\n        if (length === 0) {\n            return null;\n        } else if (length === 1) {\n            namedNode = childList[low];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const middle = parseInt(length / 2, 10) + low;\n            const left = buildBalancedTree(low, middle);\n            const right = buildBalancedTree(middle + 1, high);\n            namedNode = childList[middle];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\n        }\n    };\n    const buildFrom12Array = function(base12) {\n        let node = null;\n        let root = null;\n        let index = childList.length;\n        const buildPennant = function(chunkSize, color) {\n            const low = index - chunkSize;\n            const high = index;\n            index -= chunkSize;\n            const childTree = buildBalancedTree(low + 1, high);\n            const namedNode = childList[low];\n            const key = keyFn ? keyFn(namedNode) : namedNode;\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\n        };\n        const attachPennant = function(pennant) {\n            if (node) {\n                node.left = pennant;\n                node = pennant;\n            } else {\n                root = pennant;\n                node = pennant;\n            }\n        };\n        for(let i = 0; i < base12.count; ++i){\n            const isOne = base12.nextBitIsOne();\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n            const chunkSize = Math.pow(2, base12.count - (i + 1));\n            if (isOne) {\n                buildPennant(chunkSize, LLRBNode.BLACK);\n            } else {\n                // current == 2\n                buildPennant(chunkSize, LLRBNode.BLACK);\n                buildPennant(chunkSize, LLRBNode.RED);\n            }\n        }\n        return root;\n    };\n    const base12 = new Base12Num(childList.length);\n    const root = buildFrom12Array(base12);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new SortedMap(mapSortFn || cmp, root);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let _defaultIndexMap;\nconst fallbackObject = {};\nclass IndexMap {\n    constructor(indexes_, indexSet_){\n        this.indexes_ = indexes_;\n        this.indexSet_ = indexSet_;\n    }\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     */ static get Default() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(fallbackObject && PRIORITY_INDEX, \"ChildrenNode.ts has not been loaded\");\n        _defaultIndexMap = _defaultIndexMap || new IndexMap({\n            \".priority\": fallbackObject\n        }, {\n            \".priority\": PRIORITY_INDEX\n        });\n        return _defaultIndexMap;\n    }\n    get(indexKey) {\n        const sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexes_, indexKey);\n        if (!sortedMap) {\n            throw new Error(\"No index defined for \" + indexKey);\n        }\n        if (sortedMap instanceof SortedMap) {\n            return sortedMap;\n        } else {\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n            // regular child map\n            return null;\n        }\n    }\n    hasIndex(indexDefinition) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.indexSet_, indexDefinition.toString());\n    }\n    addIndex(indexDefinition, existingChildren) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n        const childList = [];\n        let sawIndexedValue = false;\n        const iter = existingChildren.getIterator(NamedNode.Wrap);\n        let next = iter.getNext();\n        while(next){\n            sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n            childList.push(next);\n            next = iter.getNext();\n        }\n        let newIndex;\n        if (sawIndexedValue) {\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\n        } else {\n            newIndex = fallbackObject;\n        }\n        const indexName = indexDefinition.toString();\n        const newIndexSet = Object.assign({}, this.indexSet_);\n        newIndexSet[indexName] = indexDefinition;\n        const newIndexes = Object.assign({}, this.indexes_);\n        newIndexes[indexName] = newIndex;\n        return new IndexMap(newIndexes, newIndexSet);\n    }\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */ addToIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren, indexName)=>{\n            const index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexSet_, indexName);\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(index, \"Missing index implementation for \" + indexName);\n            if (indexedChildren === fallbackObject) {\n                // Check to see if we need to index everything\n                if (index.isDefinedOn(namedNode.node)) {\n                    // We need to build this index\n                    const childList = [];\n                    const iter = existingChildren.getIterator(NamedNode.Wrap);\n                    let next = iter.getNext();\n                    while(next){\n                        if (next.name !== namedNode.name) {\n                            childList.push(next);\n                        }\n                        next = iter.getNext();\n                    }\n                    childList.push(namedNode);\n                    return buildChildSet(childList, index.getCompare());\n                } else {\n                    // No change, this remains a fallback\n                    return fallbackObject;\n                }\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                let newChildren = indexedChildren;\n                if (existingSnap) {\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                }\n                return newChildren.insert(namedNode, namedNode.node);\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */ removeFromIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren)=>{\n            if (indexedChildren === fallbackObject) {\n                // This is the fallback. Just return it, nothing to do in this case\n                return indexedChildren;\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                if (existingSnap) {\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                } else {\n                    // No record of this child\n                    return indexedChildren;\n                }\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // TODO: For memory savings, don't store priorityNode_ if it's empty.\nlet EMPTY_NODE;\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */ class ChildrenNode {\n    /**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */ constructor(children_, priorityNode_, indexMap_){\n        this.children_ = children_;\n        this.priorityNode_ = priorityNode_;\n        this.indexMap_ = indexMap_;\n        this.lazyHash_ = null;\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */ if (this.priorityNode_) {\n            validatePriorityNode(this.priorityNode_);\n        }\n        if (this.children_.isEmpty()) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), \"An empty node cannot have a priority\");\n        }\n    }\n    static get EMPTY_NODE() {\n        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return false;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_ || EMPTY_NODE;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        if (this.children_.isEmpty()) {\n            // Don't allow priorities on empty nodes\n            return this;\n        } else {\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n        }\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.getPriority();\n        } else {\n            const child = this.children_.get(childName);\n            return child === null ? EMPTY_NODE : child;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return this;\n        }\n        return this.getImmediateChild(front).getChild(pathPopFront(path));\n    }\n    /** @inheritDoc */ hasChild(childName) {\n        return this.children_.get(childName) !== null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(newChildNode, \"We should always be passing snapshot nodes\");\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else {\n            const namedNode = new NamedNode(childName, newChildNode);\n            let newChildren, newIndexMap;\n            if (newChildNode.isEmpty()) {\n                newChildren = this.children_.remove(childName);\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n            } else {\n                newChildren = this.children_.insert(childName, newChildNode);\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n            }\n            const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(path) !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);\n            return this.updateImmediateChild(front, newImmediateChild);\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return this.children_.isEmpty();\n    }\n    /** @inheritDoc */ numChildren() {\n        return this.children_.count();\n    }\n    /** @inheritDoc */ val(exportFormat) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const obj = {};\n        let numKeys = 0, maxKey = 0, allIntegerKeys = true;\n        this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            obj[key] = childNode.val(exportFormat);\n            numKeys++;\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n                maxKey = Math.max(maxKey, Number(key));\n            } else {\n                allIntegerKeys = false;\n            }\n        });\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n            // convert to array.\n            const array = [];\n            // eslint-disable-next-line guard-for-in\n            for(const key in obj){\n                array[key] = obj[key];\n            }\n            return array;\n        } else {\n            if (exportFormat && !this.getPriority().isEmpty()) {\n                obj[\".priority\"] = this.getPriority().val();\n            }\n            return obj;\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.getPriority().isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.getPriority().val()) + \":\";\n            }\n            this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                const childHash = childNode.hash();\n                if (childHash !== \"\") {\n                    toHash += \":\" + key + \":\" + childHash;\n                }\n            });\n            this.lazyHash_ = toHash === \"\" ? \"\" : sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode, index) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\n            return predecessor ? predecessor.name : null;\n        } else {\n            return this.children_.getPredecessorKey(childName);\n        }\n    }\n    getFirstChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const minKey = idx.minKey();\n            return minKey && minKey.name;\n        } else {\n            return this.children_.minKey();\n        }\n    }\n    getFirstChild(indexDefinition) {\n        const minKey = this.getFirstChildName(indexDefinition);\n        if (minKey) {\n            return new NamedNode(minKey, this.children_.get(minKey));\n        } else {\n            return null;\n        }\n    }\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */ getLastChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const maxKey = idx.maxKey();\n            return maxKey && maxKey.name;\n        } else {\n            return this.children_.maxKey();\n        }\n    }\n    getLastChild(indexDefinition) {\n        const maxKey = this.getLastChildName(indexDefinition);\n        if (maxKey) {\n            return new NamedNode(maxKey, this.children_.get(maxKey));\n        } else {\n            return null;\n        }\n    }\n    forEachChild(index, action) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            return idx.inorderTraversal((wrappedNode)=>{\n                return action(wrappedNode.name, wrappedNode.node);\n            });\n        } else {\n            return this.children_.inorderTraversal(action);\n        }\n    }\n    getIterator(indexDefinition) {\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n    }\n    getIteratorFrom(startPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getIteratorFrom(startPost, (key)=>key);\n        } else {\n            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, startPost) < 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    getReverseIterator(indexDefinition) {\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n    }\n    getReverseIteratorFrom(endPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getReverseIteratorFrom(endPost, (key)=>{\n                return key;\n            });\n        } else {\n            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, endPost) > 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    compareTo(other) {\n        if (this.isEmpty()) {\n            if (other.isEmpty()) {\n                return 0;\n            } else {\n                return -1;\n            }\n        } else if (other.isLeafNode() || other.isEmpty()) {\n            return 1;\n        } else if (other === MAX_NODE) {\n            return -1;\n        } else {\n            // Must be another node with children.\n            return 0;\n        }\n    }\n    withIndex(indexDefinition) {\n        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n            return this;\n        } else {\n            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n        }\n    }\n    isIndexed(index) {\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            return false;\n        } else {\n            const otherChildrenNode = other;\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n                return false;\n            } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n                const thisIter = this.getIterator(PRIORITY_INDEX);\n                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n                let thisCurrent = thisIter.getNext();\n                let otherCurrent = otherIter.getNext();\n                while(thisCurrent && otherCurrent){\n                    if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n                        return false;\n                    }\n                    thisCurrent = thisIter.getNext();\n                    otherCurrent = otherIter.getNext();\n                }\n                return thisCurrent === null && otherCurrent === null;\n            } else {\n                return false;\n            }\n        }\n    }\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */ resolveIndex_(indexDefinition) {\n        if (indexDefinition === KEY_INDEX) {\n            return null;\n        } else {\n            return this.indexMap_.get(indexDefinition.toString());\n        }\n    }\n}\nChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\nclass MaxNode extends ChildrenNode {\n    constructor(){\n        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);\n    }\n    compareTo(other) {\n        if (other === this) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    equals(other) {\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\n        return other === this;\n    }\n    getPriority() {\n        return this;\n    }\n    getImmediateChild(childName) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    isEmpty() {\n        return false;\n    }\n}\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n */ const MAX_NODE = new MaxNode();\nObject.defineProperties(NamedNode, {\n    MIN: {\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n    },\n    MAX: {\n        value: new NamedNode(MAX_NAME, MAX_NODE)\n    }\n});\n/**\r\n * Reference Extensions\r\n */ KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode$1(MAX_NODE);\nsetMaxNode(MAX_NODE);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const USE_HINZE = true;\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */ function nodeFromJSON(json, priority = null) {\n    if (json === null) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    if (typeof json === \"object\" && \".priority\" in json) {\n        priority = json[\".priority\"];\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priority === null || typeof priority === \"string\" || typeof priority === \"number\" || typeof priority === \"object\" && \".sv\" in priority, \"Invalid priority type found: \" + typeof priority);\n    if (typeof json === \"object\" && \".value\" in json && json[\".value\"] !== null) {\n        json = json[\".value\"];\n    }\n    // Valid leaf nodes include non-objects or server-value wrapper objects\n    if (typeof json !== \"object\" || \".sv\" in json) {\n        const jsonLeaf = json;\n        return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n    }\n    if (!(json instanceof Array) && USE_HINZE) {\n        const children = [];\n        let childrenHavePriority = false;\n        const hinzeJsonObj = json;\n        each(hinzeJsonObj, (key, child)=>{\n            if (key.substring(0, 1) !== \".\") {\n                // Ignore metadata nodes\n                const childNode = nodeFromJSON(child);\n                if (!childNode.isEmpty()) {\n                    childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();\n                    children.push(new NamedNode(key, childNode));\n                }\n            }\n        });\n        if (children.length === 0) {\n            return ChildrenNode.EMPTY_NODE;\n        }\n        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode)=>namedNode.name, NAME_COMPARATOR);\n        if (childrenHavePriority) {\n            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\n            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({\n                \".priority\": sortedChildSet\n            }, {\n                \".priority\": PRIORITY_INDEX\n            }));\n        } else {\n            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);\n        }\n    } else {\n        let node = ChildrenNode.EMPTY_NODE;\n        each(json, (key, childData)=>{\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(json, key)) {\n                if (key.substring(0, 1) !== \".\") {\n                    // ignore metadata nodes.\n                    const childNode = nodeFromJSON(childData);\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\n                        node = node.updateImmediateChild(key, childNode);\n                    }\n                }\n            }\n        });\n        return node.updatePriority(nodeFromJSON(priority));\n    }\n}\nsetNodeFromJSON(nodeFromJSON);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PathIndex extends Index {\n    constructor(indexPath_){\n        super();\n        this.indexPath_ = indexPath_;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== \".priority\", \"Can't create PathIndex with empty path or .priority key\");\n    }\n    extractChild(snap) {\n        return snap.getChild(this.indexPath_);\n    }\n    isDefinedOn(node) {\n        return !node.getChild(this.indexPath_).isEmpty();\n    }\n    compare(a, b) {\n        const aChild = this.extractChild(a.node);\n        const bChild = this.extractChild(b.node);\n        const indexCmp = aChild.compareTo(bChild);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\n        return new NamedNode(name, node);\n    }\n    maxPost() {\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\n        return new NamedNode(MAX_NAME, node);\n    }\n    toString() {\n        return pathSlice(this.indexPath_, 0).join(\"/\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ValueIndex extends Index {\n    compare(a, b) {\n        const indexCmp = a.node.compareTo(b.node);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return true;\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.equals(newNode);\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MAX;\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        return new NamedNode(name, valueNode);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".value\";\n    }\n}\nconst VALUE_INDEX = new ValueIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function changeValue(snapshotNode) {\n    return {\n        type: \"value\" /* ChangeType.VALUE */ ,\n        snapshotNode\n    };\n}\nfunction changeChildAdded(childName, snapshotNode) {\n    return {\n        type: \"child_added\" /* ChangeType.CHILD_ADDED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildRemoved(childName, snapshotNode) {\n    return {\n        type: \"child_removed\" /* ChangeType.CHILD_REMOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildChanged(childName, snapshotNode, oldSnap) {\n    return {\n        type: \"child_changed\" /* ChangeType.CHILD_CHANGED */ ,\n        snapshotNode,\n        childName,\n        oldSnap\n    };\n}\nfunction changeChildMoved(childName, snapshotNode) {\n    return {\n        type: \"child_moved\" /* ChangeType.CHILD_MOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */ class IndexedFilter {\n    constructor(index_){\n        this.index_ = index_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isIndexed(this.index_), \"A node must be indexed if only a child is updated\");\n        const oldChild = snap.getImmediateChild(key);\n        // Check if anything actually changed.\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n            // to avoid treating these cases as \"nothing changed.\"\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\n                // Nothing changed.\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n                return snap;\n            }\n        }\n        if (optChangeAccumulator != null) {\n            if (newChild.isEmpty()) {\n                if (snap.hasChild(key)) {\n                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));\n                } else {\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isLeafNode(), \"A child remove without an old child only makes sense on a leaf node\");\n                }\n            } else if (oldChild.isEmpty()) {\n                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));\n            } else {\n                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));\n            }\n        }\n        if (snap.isLeafNode() && newChild.isEmpty()) {\n            return snap;\n        } else {\n            // Make sure the node is indexed\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (optChangeAccumulator != null) {\n            if (!oldSnap.isLeafNode()) {\n                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (!newSnap.hasChild(key)) {\n                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));\n                    }\n                });\n            }\n            if (!newSnap.isLeafNode()) {\n                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (oldSnap.hasChild(key)) {\n                        const oldChild = oldSnap.getImmediateChild(key);\n                        if (!oldChild.equals(childNode)) {\n                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));\n                        }\n                    } else {\n                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));\n                    }\n                });\n            }\n        }\n        return newSnap.withIndex(this.index_);\n    }\n    updatePriority(oldSnap, newPriority) {\n        if (oldSnap.isEmpty()) {\n            return ChildrenNode.EMPTY_NODE;\n        } else {\n            return oldSnap.updatePriority(newPriority);\n        }\n    }\n    filtersNodes() {\n        return false;\n    }\n    getIndexedFilter() {\n        return this;\n    }\n    getIndex() {\n        return this.index_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */ class RangedFilter {\n    constructor(params){\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\n        this.index_ = params.getIndex();\n        this.startPost_ = RangedFilter.getStartPost_(params);\n        this.endPost_ = RangedFilter.getEndPost_(params);\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    getStartPost() {\n        return this.startPost_;\n    }\n    getEndPost() {\n        return this.endPost_;\n    }\n    matches(node) {\n        const isWithinStart = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), node) <= 0 : this.index_.compare(this.getStartPost(), node) < 0;\n        const isWithinEnd = this.endIsInclusive_ ? this.index_.compare(node, this.getEndPost()) <= 0 : this.index_.compare(node, this.getEndPost()) < 0;\n        return isWithinStart && isWithinEnd;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (newSnap.isLeafNode()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            newSnap = ChildrenNode.EMPTY_NODE;\n        }\n        let filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n        const self = this;\n        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            if (!self.matches(new NamedNode(key, childNode))) {\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n            }\n        });\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.indexedFilter_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    static getStartPost_(params) {\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\n        } else {\n            return params.getIndex().minPost();\n        }\n    }\n    static getEndPost_(params) {\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\n        } else {\n            return params.getIndex().maxPost();\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */ class LimitedFilter {\n    constructor(params){\n        this.withinDirectionalStart = (node)=>this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);\n        this.withinDirectionalEnd = (node)=>this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);\n        this.withinStartPost = (node)=>{\n            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);\n            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.withinEndPost = (node)=>{\n            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());\n            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.rangedFilter_ = new RangedFilter(params);\n        this.index_ = params.getIndex();\n        this.limit_ = params.getLimit();\n        this.reverse_ = !params.isViewFromLeft();\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        if (snap.getImmediateChild(key).equals(newChild)) {\n            // No change\n            return snap;\n        } else if (snap.numChildren() < this.limit_) {\n            return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n        } else {\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        let filtered;\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        } else {\n            if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n                // anchor to the startPost, endPost, or last element as appropriate\n                let iterator;\n                if (this.reverse_) {\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n                } else {\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext() && count < this.limit_){\n                    const next = iterator.getNext();\n                    if (!this.withinDirectionalStart(next)) {\n                        continue;\n                    } else if (!this.withinDirectionalEnd(next)) {\n                        break;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\n                        count++;\n                    }\n                }\n            } else {\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n                filtered = newSnap.withIndex(this.index_);\n                // Don't support priorities on queries\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n                let iterator;\n                if (this.reverse_) {\n                    iterator = filtered.getReverseIterator(this.index_);\n                } else {\n                    iterator = filtered.getIterator(this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext()){\n                    const next = iterator.getNext();\n                    const inRange = count < this.limit_ && this.withinDirectionalStart(next) && this.withinDirectionalEnd(next);\n                    if (inRange) {\n                        count++;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\n                    }\n                }\n            }\n        }\n        return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.rangedFilter_.getIndexedFilter();\n    }\n    getIndex() {\n        return this.index_;\n    }\n    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {\n        // TODO: rename all cache stuff etc to general snap terminology\n        let cmp;\n        if (this.reverse_) {\n            const indexCmp = this.index_.getCompare();\n            cmp = (a, b)=>indexCmp(b, a);\n        } else {\n            cmp = this.index_.getCompare();\n        }\n        const oldEventCache = snap;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(oldEventCache.numChildren() === this.limit_, \"\");\n        const newChildNamedNode = new NamedNode(childKey, childSnap);\n        const windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);\n        const inRange = this.rangedFilter_.matches(newChildNamedNode);\n        if (oldEventCache.hasChild(childKey)) {\n            const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n            while(nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))){\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\n                // the limited filter...\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n            }\n            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n            if (remainsInWindow) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\n            } else {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));\n                }\n                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\n                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n                if (nextChildInRange) {\n                    if (changeAccumulator != null) {\n                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));\n                    }\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n                } else {\n                    return newEventCache;\n                }\n            }\n        } else if (childSnap.isEmpty()) {\n            // we're deleting a node, but it was not in the window, so ignore it\n            return snap;\n        } else if (inRange) {\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));\n                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n            } else {\n                return snap;\n            }\n        } else {\n            return snap;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */ class QueryParams {\n    constructor(){\n        this.limitSet_ = false;\n        this.startSet_ = false;\n        this.startNameSet_ = false;\n        this.startAfterSet_ = false; // can only be true if startSet_ is true\n        this.endSet_ = false;\n        this.endNameSet_ = false;\n        this.endBeforeSet_ = false; // can only be true if endSet_ is true\n        this.limit_ = 0;\n        this.viewFrom_ = \"\";\n        this.indexStartValue_ = null;\n        this.indexStartName_ = \"\";\n        this.indexEndValue_ = null;\n        this.indexEndName_ = \"\";\n        this.index_ = PRIORITY_INDEX;\n    }\n    hasStart() {\n        return this.startSet_;\n    }\n    /**\r\n     * @returns True if it would return from left.\r\n     */ isViewFromLeft() {\n        if (this.viewFrom_ === \"\") {\n            // limit(), rather than limitToFirst or limitToLast was called.\n            // This means that only one of startSet_ and endSet_ is true. Use them\n            // to calculate which side of the view to anchor to. If neither is set,\n            // anchor to the end.\n            return this.startSet_;\n        } else {\n            return this.viewFrom_ === \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n        }\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     */ getIndexStartValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        return this.indexStartValue_;\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */ getIndexStartName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        if (this.startNameSet_) {\n            return this.indexStartName_;\n        } else {\n            return MIN_NAME;\n        }\n    }\n    hasEnd() {\n        return this.endSet_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */ getIndexEndValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        return this.indexEndValue_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */ getIndexEndName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        if (this.endNameSet_) {\n            return this.indexEndName_;\n        } else {\n            return MAX_NAME;\n        }\n    }\n    hasLimit() {\n        return this.limitSet_;\n    }\n    /**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */ hasAnchoredLimit() {\n        return this.limitSet_ && this.viewFrom_ !== \"\";\n    }\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     */ getLimit() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.limitSet_, \"Only valid if limit has been set\");\n        return this.limit_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    loadsAllData() {\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\n    }\n    isDefault() {\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\n    }\n    copy() {\n        const copy = new QueryParams();\n        copy.limitSet_ = this.limitSet_;\n        copy.limit_ = this.limit_;\n        copy.startSet_ = this.startSet_;\n        copy.startAfterSet_ = this.startAfterSet_;\n        copy.indexStartValue_ = this.indexStartValue_;\n        copy.startNameSet_ = this.startNameSet_;\n        copy.indexStartName_ = this.indexStartName_;\n        copy.endSet_ = this.endSet_;\n        copy.endBeforeSet_ = this.endBeforeSet_;\n        copy.indexEndValue_ = this.indexEndValue_;\n        copy.endNameSet_ = this.endNameSet_;\n        copy.indexEndName_ = this.indexEndName_;\n        copy.index_ = this.index_;\n        copy.viewFrom_ = this.viewFrom_;\n        return copy;\n    }\n}\nfunction queryParamsGetNodeFilter(queryParams) {\n    if (queryParams.loadsAllData()) {\n        return new IndexedFilter(queryParams.getIndex());\n    } else if (queryParams.hasLimit()) {\n        return new LimitedFilter(queryParams);\n    } else {\n        return new RangedFilter(queryParams);\n    }\n}\nfunction queryParamsLimitToFirst(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n    return newParams;\n}\nfunction queryParamsLimitToLast(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n    return newParams;\n}\nfunction queryParamsStartAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.startSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexStartValue_ = indexValue;\n    if (key != null) {\n        newParams.startNameSet_ = true;\n        newParams.indexStartName_ = key;\n    } else {\n        newParams.startNameSet_ = false;\n        newParams.indexStartName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsStartAfter(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsStartAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);\n    }\n    params.startAfterSet_ = true;\n    return params;\n}\nfunction queryParamsEndAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.endSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexEndValue_ = indexValue;\n    if (key !== undefined) {\n        newParams.endNameSet_ = true;\n        newParams.indexEndName_ = key;\n    } else {\n        newParams.endNameSet_ = false;\n        newParams.indexEndName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsEndBefore(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsEndAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);\n    }\n    params.endBeforeSet_ = true;\n    return params;\n}\nfunction queryParamsOrderBy(queryParams, index) {\n    const newParams = queryParams.copy();\n    newParams.index_ = index;\n    return newParams;\n}\n/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */ function queryParamsToRestQueryStringParameters(queryParams) {\n    const qs = {};\n    if (queryParams.isDefault()) {\n        return qs;\n    }\n    let orderBy;\n    if (queryParams.index_ === PRIORITY_INDEX) {\n        orderBy = \"$priority\" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */ ;\n    } else if (queryParams.index_ === VALUE_INDEX) {\n        orderBy = \"$value\" /* REST_QUERY_CONSTANTS.VALUE_INDEX */ ;\n    } else if (queryParams.index_ === KEY_INDEX) {\n        orderBy = \"$key\" /* REST_QUERY_CONSTANTS.KEY_INDEX */ ;\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queryParams.index_ instanceof PathIndex, \"Unrecognized index type!\");\n        orderBy = queryParams.index_.toString();\n    }\n    qs[\"orderBy\" /* REST_QUERY_CONSTANTS.ORDER_BY */ ] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(orderBy);\n    if (queryParams.startSet_) {\n        const startParam = queryParams.startAfterSet_ ? \"startAfter\" /* REST_QUERY_CONSTANTS.START_AFTER */  : \"startAt\" /* REST_QUERY_CONSTANTS.START_AT */ ;\n        qs[startParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartValue_);\n        if (queryParams.startNameSet_) {\n            qs[startParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartName_);\n        }\n    }\n    if (queryParams.endSet_) {\n        const endParam = queryParams.endBeforeSet_ ? \"endBefore\" /* REST_QUERY_CONSTANTS.END_BEFORE */  : \"endAt\" /* REST_QUERY_CONSTANTS.END_AT */ ;\n        qs[endParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndValue_);\n        if (queryParams.endNameSet_) {\n            qs[endParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndName_);\n        }\n    }\n    if (queryParams.limitSet_) {\n        if (queryParams.isViewFromLeft()) {\n            qs[\"limitToFirst\" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */ ] = queryParams.limit_;\n        } else {\n            qs[\"limitToLast\" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */ ] = queryParams.limit_;\n        }\n    }\n    return qs;\n}\nfunction queryParamsGetQueryObject(queryParams) {\n    const obj = {};\n    if (queryParams.startSet_) {\n        obj[\"sp\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */ ] = queryParams.indexStartValue_;\n        if (queryParams.startNameSet_) {\n            obj[\"sn\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */ ] = queryParams.indexStartName_;\n        }\n        obj[\"sin\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */ ] = !queryParams.startAfterSet_;\n    }\n    if (queryParams.endSet_) {\n        obj[\"ep\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */ ] = queryParams.indexEndValue_;\n        if (queryParams.endNameSet_) {\n            obj[\"en\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */ ] = queryParams.indexEndName_;\n        }\n        obj[\"ein\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */ ] = !queryParams.endBeforeSet_;\n    }\n    if (queryParams.limitSet_) {\n        obj[\"l\" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */ ] = queryParams.limit_;\n        let viewFrom = queryParams.viewFrom_;\n        if (viewFrom === \"\") {\n            if (queryParams.isViewFromLeft()) {\n                viewFrom = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n            } else {\n                viewFrom = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n            }\n        }\n        obj[\"vf\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */ ] = viewFrom;\n    }\n    // For now, priority index is the default, so we only specify if it's some other index\n    if (queryParams.index_ !== PRIORITY_INDEX) {\n        obj[\"i\" /* WIRE_PROTOCOL_CONSTANTS.INDEX */ ] = queryParams.index_.toString();\n    }\n    return obj;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */ class ReadonlyRestClient extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        /** @private {function(...[*])} */ this.log_ = logWrapper(\"p:rest:\");\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */ this.listens_ = {};\n    }\n    reportStats(stats) {\n        throw new Error(\"Method not implemented.\");\n    }\n    static getListenId_(query, tag) {\n        if (tag !== undefined) {\n            return \"tag$\" + tag;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault(), \"should have a tag if it's not a default query.\");\n            return query._path.toString();\n        }\n    }\n    /** @inheritDoc */ listen(query, currentHashFn, tag, onComplete) {\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + query._queryIdentifier);\n        // Mark this listener so we can tell if it's removed.\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        const thisListen = {};\n        this.listens_[listenId] = thisListen;\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n            }\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.listens_, listenId) === thisListen) {\n                let status;\n                if (!error) {\n                    status = \"ok\";\n                } else if (error === 401) {\n                    status = \"permission_denied\";\n                } else {\n                    status = \"rest_error:\" + error;\n                }\n                onComplete(status, null);\n            }\n        });\n    }\n    /** @inheritDoc */ unlisten(query, tag) {\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        delete this.listens_[listenId];\n    }\n    get(query) {\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        const pathString = query._path.toString();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, /*tag=*/ null);\n                deferred.resolve(data);\n            } else {\n                deferred.reject(new Error(data));\n            }\n        });\n        return deferred.promise;\n    }\n    /** @inheritDoc */ refreshAuthToken(token) {\n    // no-op since we just always call getToken.\n    }\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */ restRequest_(pathString, queryStringParameters = {}, callback) {\n        queryStringParameters[\"format\"] = \"export\";\n        return Promise.all([\n            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),\n            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)\n        ]).then(([authToken, appCheckToken])=>{\n            if (authToken && authToken.accessToken) {\n                queryStringParameters[\"auth\"] = authToken.accessToken;\n            }\n            if (appCheckToken && appCheckToken.token) {\n                queryStringParameters[\"ac\"] = appCheckToken.token;\n            }\n            const url = (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host + pathString + \"?\" + \"ns=\" + this.repoInfo_.namespace + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(queryStringParameters);\n            this.log_(\"Sending REST request for \" + url);\n            const xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = ()=>{\n                if (callback && xhr.readyState === 4) {\n                    this.log_(\"REST Response for \" + url + \" received. status:\", xhr.status, \"response:\", xhr.responseText);\n                    let res = null;\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        try {\n                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(xhr.responseText);\n                        } catch (e) {\n                            warn(\"Failed to parse JSON response for \" + url + \": \" + xhr.responseText);\n                        }\n                        callback(null, res);\n                    } else {\n                        // 401 and 404 are expected.\n                        if (xhr.status !== 401 && xhr.status !== 404) {\n                            warn(\"Got unsuccessful REST response for \" + url + \" Status: \" + xhr.status);\n                        }\n                        callback(xhr.status);\n                    }\n                    callback = null;\n                }\n            };\n            xhr.open(\"GET\", url, /*asynchronous=*/ true);\n            xhr.send();\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */ class SnapshotHolder {\n    constructor(){\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\n    }\n    getNode(path) {\n        return this.rootNode_.getChild(path);\n    }\n    updateSnapshot(path, newSnapshotNode) {\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newSparseSnapshotTree() {\n    return {\n        value: null,\n        children: new Map()\n    };\n}\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */ function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = data;\n        sparseSnapshotTree.children.clear();\n    } else if (sparseSnapshotTree.value !== null) {\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\n    } else {\n        const childKey = pathGetFront(path);\n        if (!sparseSnapshotTree.children.has(childKey)) {\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\n        }\n        const child = sparseSnapshotTree.children.get(childKey);\n        path = pathPopFront(path);\n        sparseSnapshotTreeRemember(child, path, data);\n    }\n}\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */ function sparseSnapshotTreeForget(sparseSnapshotTree, path) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = null;\n        sparseSnapshotTree.children.clear();\n        return true;\n    } else {\n        if (sparseSnapshotTree.value !== null) {\n            if (sparseSnapshotTree.value.isLeafNode()) {\n                // We're trying to forget a node that doesn't exist\n                return false;\n            } else {\n                const value = sparseSnapshotTree.value;\n                sparseSnapshotTree.value = null;\n                value.forEachChild(PRIORITY_INDEX, (key, tree)=>{\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\n                });\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\n            }\n        } else if (sparseSnapshotTree.children.size > 0) {\n            const childKey = pathGetFront(path);\n            path = pathPopFront(path);\n            if (sparseSnapshotTree.children.has(childKey)) {\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\n                if (safeToRemove) {\n                    sparseSnapshotTree.children.delete(childKey);\n                }\n            }\n            return sparseSnapshotTree.children.size === 0;\n        } else {\n            return true;\n        }\n    }\n}\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */ function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\n    if (sparseSnapshotTree.value !== null) {\n        func(prefixPath, sparseSnapshotTree.value);\n    } else {\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree)=>{\n            const path = new Path(prefixPath.toString() + \"/\" + key);\n            sparseSnapshotTreeForEachTree(tree, path, func);\n        });\n    }\n}\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */ function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\n    sparseSnapshotTree.children.forEach((tree, key)=>{\n        func(key, tree);\n    });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */ class StatsListener {\n    constructor(collection_){\n        this.collection_ = collection_;\n        this.last_ = null;\n    }\n    get() {\n        const newStats = this.collection_.get();\n        const delta = Object.assign({}, newStats);\n        if (this.last_) {\n            each(this.last_, (stat, value)=>{\n                delta[stat] = delta[stat] - value;\n            });\n        }\n        this.last_ = newStats;\n        return delta;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\nclass StatsReporter {\n    constructor(collection, server_){\n        this.server_ = server_;\n        this.statsToReport_ = {};\n        this.statsListener_ = new StatsListener(collection);\n        const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n    }\n    reportStats_() {\n        const stats = this.statsListener_.get();\n        const reportedStats = {};\n        let haveStatsToReport = false;\n        each(stats, (stat, value)=>{\n            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.statsToReport_, stat)) {\n                reportedStats[stat] = value;\n                haveStatsToReport = true;\n            }\n        });\n        if (haveStatsToReport) {\n            this.server_.reportStats(reportedStats);\n        }\n        // queue our next run.\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n *\r\n * @enum\r\n */ var OperationType;\n(function(OperationType) {\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\n})(OperationType || (OperationType = {}));\nfunction newOperationSourceUser() {\n    return {\n        fromUser: true,\n        fromServer: false,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServer() {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServerTaggedQuery(queryId) {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId,\n        tagged: true\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AckUserWrite {\n    /**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */ constructor(/** @inheritDoc */ path, /** @inheritDoc */ affectedTree, /** @inheritDoc */ revert){\n        this.path = path;\n        this.affectedTree = affectedTree;\n        this.revert = revert;\n        /** @inheritDoc */ this.type = OperationType.ACK_USER_WRITE;\n        /** @inheritDoc */ this.source = newOperationSourceUser();\n    }\n    operationForChild(childName) {\n        if (!pathIsEmpty(this.path)) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"operationForChild called for unrelated child.\");\n            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);\n        } else if (this.affectedTree.value != null) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.affectedTree.children.isEmpty(), \"affectedTree should not have overlapping affected paths.\");\n            // All child locations are affected as well; just return same operation.\n            return this;\n        } else {\n            const childTree = this.affectedTree.subtree(new Path(childName));\n            return new AckUserWrite(newEmptyPath(), childTree, this.revert);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ListenComplete {\n    constructor(source, path){\n        this.source = source;\n        this.path = path;\n        /** @inheritDoc */ this.type = OperationType.LISTEN_COMPLETE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new ListenComplete(this.source, newEmptyPath());\n        } else {\n            return new ListenComplete(this.source, pathPopFront(this.path));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Overwrite {\n    constructor(source, path, snap){\n        this.source = source;\n        this.path = path;\n        this.snap = snap;\n        /** @inheritDoc */ this.type = OperationType.OVERWRITE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));\n        } else {\n            return new Overwrite(this.source, pathPopFront(this.path), this.snap);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Merge {\n    constructor(/** @inheritDoc */ source, /** @inheritDoc */ path, /** @inheritDoc */ children){\n        this.source = source;\n        this.path = path;\n        this.children = children;\n        /** @inheritDoc */ this.type = OperationType.MERGE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            const childTree = this.children.subtree(new Path(childName));\n            if (childTree.isEmpty()) {\n                // This child is unaffected\n                return null;\n            } else if (childTree.value) {\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\n                return new Overwrite(this.source, newEmptyPath(), childTree.value);\n            } else {\n                // This is a merge at a deeper level\n                return new Merge(this.source, newEmptyPath(), childTree);\n            }\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"Can't get a merge for a child not on the path of the operation\");\n            return new Merge(this.source, pathPopFront(this.path), this.children);\n        }\n    }\n    toString() {\n        return \"Operation(\" + this.path + \": \" + this.source.toString() + \" merge: \" + this.children.toString() + \")\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */ class CacheNode {\n    constructor(node_, fullyInitialized_, filtered_){\n        this.node_ = node_;\n        this.fullyInitialized_ = fullyInitialized_;\n        this.filtered_ = filtered_;\n    }\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */ isFullyInitialized() {\n        return this.fullyInitialized_;\n    }\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */ isFiltered() {\n        return this.filtered_;\n    }\n    isCompleteForPath(path) {\n        if (pathIsEmpty(path)) {\n            return this.isFullyInitialized() && !this.filtered_;\n        }\n        const childKey = pathGetFront(path);\n        return this.isCompleteForChild(childKey);\n    }\n    isCompleteForChild(key) {\n        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);\n    }\n    getNode() {\n        return this.node_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */ class EventGenerator {\n    constructor(query_){\n        this.query_ = query_;\n        this.index_ = this.query_._queryParams.getIndex();\n    }\n}\n/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */ function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {\n    const events = [];\n    const moves = [];\n    changes.forEach((change)=>{\n        if (change.type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\n            moves.push(changeChildMoved(change.childName, change.snapshotNode));\n        }\n    });\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_removed\" /* ChangeType.CHILD_REMOVED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_added\" /* ChangeType.CHILD_ADDED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_moved\" /* ChangeType.CHILD_MOVED */ , moves, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_changed\" /* ChangeType.CHILD_CHANGED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"value\" /* ChangeType.VALUE */ , changes, eventRegistrations, eventCache);\n    return events;\n}\n/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */ function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {\n    const filteredChanges = changes.filter((change)=>change.type === eventType);\n    filteredChanges.sort((a, b)=>eventGeneratorCompareChanges(eventGenerator, a, b));\n    filteredChanges.forEach((change)=>{\n        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);\n        registrations.forEach((registration)=>{\n            if (registration.respondsTo(change.type)) {\n                events.push(registration.createEvent(materializedChange, eventGenerator.query_));\n            }\n        });\n    });\n}\nfunction eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {\n    if (change.type === \"value\" || change.type === \"child_removed\") {\n        return change;\n    } else {\n        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);\n        return change;\n    }\n}\nfunction eventGeneratorCompareChanges(eventGenerator, a, b) {\n    if (a.childName == null || b.childName == null) {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Should only compare child_ events.\");\n    }\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\n    return eventGenerator.index_.compare(aWrapped, bWrapped);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewCache(eventCache, serverCache) {\n    return {\n        eventCache,\n        serverCache\n    };\n}\nfunction viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {\n    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);\n}\nfunction viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {\n    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));\n}\nfunction viewCacheGetCompleteEventSnap(viewCache) {\n    return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;\n}\nfunction viewCacheGetCompleteServerSnap(viewCache) {\n    return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let emptyChildrenSingleton;\n/**\r\n * Singleton empty children collection.\r\n *\r\n */ const EmptyChildren = ()=>{\n    if (!emptyChildrenSingleton) {\n        emptyChildrenSingleton = new SortedMap(stringCompare);\n    }\n    return emptyChildrenSingleton;\n};\n/**\r\n * A tree with immutable elements.\r\n */ class ImmutableTree {\n    constructor(value, children = EmptyChildren()){\n        this.value = value;\n        this.children = children;\n    }\n    static fromObject(obj) {\n        let tree = new ImmutableTree(null);\n        each(obj, (childPath, childSnap)=>{\n            tree = tree.set(new Path(childPath), childSnap);\n        });\n        return tree;\n    }\n    /**\r\n     * True if the value is empty and there are no children\r\n     */ isEmpty() {\n        return this.value === null && this.children.isEmpty();\n    }\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */ findRootMostMatchingPathAndValue(relativePath, predicate) {\n        if (this.value != null && predicate(this.value)) {\n            return {\n                path: newEmptyPath(),\n                value: this.value\n            };\n        } else {\n            if (pathIsEmpty(relativePath)) {\n                return null;\n            } else {\n                const front = pathGetFront(relativePath);\n                const child = this.children.get(front);\n                if (child !== null) {\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\n                    if (childExistingPathAndValue != null) {\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\n                        return {\n                            path: fullPath,\n                            value: childExistingPathAndValue.value\n                        };\n                    } else {\n                        return null;\n                    }\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */ findRootMostValueAndPath(relativePath) {\n        return this.findRootMostMatchingPathAndValue(relativePath, ()=>true);\n    }\n    /**\r\n     * @returns The subtree at the given path\r\n     */ subtree(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this;\n        } else {\n            const front = pathGetFront(relativePath);\n            const childTree = this.children.get(front);\n            if (childTree !== null) {\n                return childTree.subtree(pathPopFront(relativePath));\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */ set(relativePath, toSet) {\n        if (pathIsEmpty(relativePath)) {\n            return new ImmutableTree(toSet, this.children);\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.set(pathPopFront(relativePath), toSet);\n            const newChildren = this.children.insert(front, newChild);\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */ remove(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            if (this.children.isEmpty()) {\n                return new ImmutableTree(null);\n            } else {\n                return new ImmutableTree(null, this.children);\n            }\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                const newChild = child.remove(pathPopFront(relativePath));\n                let newChildren;\n                if (newChild.isEmpty()) {\n                    newChildren = this.children.remove(front);\n                } else {\n                    newChildren = this.children.insert(front, newChild);\n                }\n                if (this.value === null && newChildren.isEmpty()) {\n                    return new ImmutableTree(null);\n                } else {\n                    return new ImmutableTree(this.value, newChildren);\n                }\n            } else {\n                return this;\n            }\n        }\n    }\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */ get(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this.value;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                return child.get(pathPopFront(relativePath));\n            } else {\n                return null;\n            }\n        }\n    }\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */ setTree(relativePath, newTree) {\n        if (pathIsEmpty(relativePath)) {\n            return newTree;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\n            let newChildren;\n            if (newChild.isEmpty()) {\n                newChildren = this.children.remove(front);\n            } else {\n                newChildren = this.children.insert(front, newChild);\n            }\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */ fold(fn) {\n        return this.fold_(newEmptyPath(), fn);\n    }\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */ fold_(pathSoFar, fn) {\n        const accum = {};\n        this.children.inorderTraversal((childKey, childTree)=>{\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\n        });\n        return fn(pathSoFar, this.value, accum);\n    }\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */ findOnPath(path, f) {\n        return this.findOnPath_(path, newEmptyPath(), f);\n    }\n    findOnPath_(pathToFollow, pathSoFar, f) {\n        const result = this.value ? f(pathSoFar, this.value) : false;\n        if (result) {\n            return result;\n        } else {\n            if (pathIsEmpty(pathToFollow)) {\n                return null;\n            } else {\n                const front = pathGetFront(pathToFollow);\n                const nextChild = this.children.get(front);\n                if (nextChild) {\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    foreachOnPath(path, f) {\n        return this.foreachOnPath_(path, newEmptyPath(), f);\n    }\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\n        if (pathIsEmpty(pathToFollow)) {\n            return this;\n        } else {\n            if (this.value) {\n                f(currentRelativePath, this.value);\n            }\n            const front = pathGetFront(pathToFollow);\n            const nextChild = this.children.get(front);\n            if (nextChild) {\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */ foreach(f) {\n        this.foreach_(newEmptyPath(), f);\n    }\n    foreach_(currentRelativePath, f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\n        });\n        if (this.value) {\n            f(currentRelativePath, this.value);\n        }\n    }\n    foreachChild(f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value) {\n                f(childName, childTree.value);\n            }\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */ class CompoundWrite {\n    constructor(writeTree_){\n        this.writeTree_ = writeTree_;\n    }\n    static empty() {\n        return new CompoundWrite(new ImmutableTree(null));\n    }\n}\nfunction compoundWriteAddWrite(compoundWrite, path, node) {\n    if (pathIsEmpty(path)) {\n        return new CompoundWrite(new ImmutableTree(node));\n    } else {\n        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n        if (rootmost != null) {\n            const rootMostPath = rootmost.path;\n            let value = rootmost.value;\n            const relativePath = newRelativePath(rootMostPath, path);\n            value = value.updateChild(relativePath, node);\n            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));\n        } else {\n            const subtree = new ImmutableTree(node);\n            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);\n            return new CompoundWrite(newWriteTree);\n        }\n    }\n}\nfunction compoundWriteAddWrites(compoundWrite, path, updates) {\n    let newWrite = compoundWrite;\n    each(updates, (childKey, node)=>{\n        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);\n    });\n    return newWrite;\n}\n/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */ function compoundWriteRemoveWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return CompoundWrite.empty();\n    } else {\n        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));\n        return new CompoundWrite(newWriteTree);\n    }\n}\n/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */ function compoundWriteHasCompleteWrite(compoundWrite, path) {\n    return compoundWriteGetCompleteNode(compoundWrite, path) != null;\n}\n/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */ function compoundWriteGetCompleteNode(compoundWrite, path) {\n    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n        return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));\n    } else {\n        return null;\n    }\n}\n/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */ function compoundWriteGetCompleteChildren(compoundWrite) {\n    const children = [];\n    const node = compoundWrite.writeTree_.value;\n    if (node != null) {\n        // If it's a leaf node, it has no children; so nothing to do.\n        if (!node.isLeafNode()) {\n            node.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n                children.push(new NamedNode(childName, childNode));\n            });\n        }\n    } else {\n        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value != null) {\n                children.push(new NamedNode(childName, childTree.value));\n            }\n        });\n    }\n    return children;\n}\nfunction compoundWriteChildCompoundWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return compoundWrite;\n    } else {\n        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);\n        if (shadowingNode != null) {\n            return new CompoundWrite(new ImmutableTree(shadowingNode));\n        } else {\n            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));\n        }\n    }\n}\n/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */ function compoundWriteIsEmpty(compoundWrite) {\n    return compoundWrite.writeTree_.isEmpty();\n}\n/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */ function compoundWriteApply(compoundWrite, node) {\n    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);\n}\nfunction applySubtreeWrite(relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n        // Since there a write is always a leaf, we're done here\n        return node.updateChild(relativePath, writeTree.value);\n    } else {\n        let priorityWrite = null;\n        writeTree.children.inorderTraversal((childKey, childTree)=>{\n            if (childKey === \".priority\") {\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n                // to apply priorities to empty nodes that are later filled\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childTree.value !== null, \"Priority writes must always be leaf nodes\");\n                priorityWrite = childTree.value;\n            } else {\n                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);\n            }\n        });\n        // If there was a priority write, we only apply it if the node is not empty\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n            node = node.updateChild(pathChild(relativePath, \".priority\"), priorityWrite);\n        }\n        return node;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */ function writeTreeChildWrites(writeTree, path) {\n    return newWriteTreeRef(path, writeTree);\n}\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */ function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older write on top of newer ones\");\n    if (visible === undefined) {\n        visible = true;\n    }\n    writeTree.allWrites.push({\n        path,\n        snap,\n        writeId,\n        visible\n    });\n    if (visible) {\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\n    }\n    writeTree.lastWriteId = writeId;\n}\n/**\r\n * Record a new merge from user code.\r\n */ function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older merge on top of newer ones\");\n    writeTree.allWrites.push({\n        path,\n        children: changedChildren,\n        writeId,\n        visible: true\n    });\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\n    writeTree.lastWriteId = writeId;\n}\nfunction writeTreeGetWrite(writeTree, writeId) {\n    for(let i = 0; i < writeTree.allWrites.length; i++){\n        const record = writeTree.allWrites[i];\n        if (record.writeId === writeId) {\n            return record;\n        }\n    }\n    return null;\n}\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */ function writeTreeRemoveWrite(writeTree, writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    const idx = writeTree.allWrites.findIndex((s)=>{\n        return s.writeId === writeId;\n    });\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(idx >= 0, \"removeWrite called with nonexistent writeId.\");\n    const writeToRemove = writeTree.allWrites[idx];\n    writeTree.allWrites.splice(idx, 1);\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n    let i = writeTree.allWrites.length - 1;\n    while(removedWriteWasVisible && i >= 0){\n        const currentWrite = writeTree.allWrites[i];\n        if (currentWrite.visible) {\n            if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\n                // The removed write was completely shadowed by a subsequent write.\n                removedWriteWasVisible = false;\n            } else if (pathContains(writeToRemove.path, currentWrite.path)) {\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\n                removedWriteOverlapsWithOtherWrites = true;\n            }\n        }\n        i--;\n    }\n    if (!removedWriteWasVisible) {\n        return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\n        writeTreeResetTree_(writeTree);\n        return true;\n    } else {\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n        if (writeToRemove.snap) {\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\n        } else {\n            const children = writeToRemove.children;\n            each(children, (childName)=>{\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\n            });\n        }\n        return true;\n    }\n}\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\n    if (writeRecord.snap) {\n        return pathContains(writeRecord.path, path);\n    } else {\n        for(const childName in writeRecord.children){\n            if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */ function writeTreeResetTree_(writeTree) {\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\n    if (writeTree.allWrites.length > 0) {\n        writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\n    } else {\n        writeTree.lastWriteId = -1;\n    }\n}\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */ function writeTreeDefaultFilter_(write) {\n    return write.visible;\n}\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */ function writeTreeLayerTree_(writes, filter, treeRoot) {\n    let compoundWrite = CompoundWrite.empty();\n    for(let i = 0; i < writes.length; ++i){\n        const write = writes[i];\n        // Theory, a later set will either:\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n        if (filter(write)) {\n            const writePath = write.path;\n            let relativePath;\n            if (write.snap) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\n                } else ;\n            } else if (write.children) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    if (pathIsEmpty(relativePath)) {\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\n                    } else {\n                        const child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(write.children, pathGetFront(relativePath));\n                        if (child) {\n                            // There exists a child in this node that matches the root path\n                            const deepNode = child.getChild(pathPopFront(relativePath));\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\n                        }\n                    }\n                } else ;\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"WriteRecord should have .snap or .children\");\n            }\n        }\n    }\n    return compoundWrite;\n}\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n        if (shadowingNode != null) {\n            return shadowingNode;\n        } else {\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n            if (compoundWriteIsEmpty(subMerge)) {\n                return completeServerCache;\n            } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n                return null;\n            } else {\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(subMerge, layeredCache);\n            }\n        }\n    } else {\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\n            return completeServerCache;\n        } else {\n            // If the server cache is null, and we don't have a complete cache, we need to return null\n            if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\n                return null;\n            } else {\n                const filter = function(write) {\n                    return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));\n                };\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(mergeAtPath, layeredCache);\n            }\n        }\n    }\n}\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */ function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\n    let completeChildren = ChildrenNode.EMPTY_NODE;\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n    if (topLevelSet) {\n        if (!topLevelSet.isLeafNode()) {\n            // we're shadowing everything. Return the children.\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap)=>{\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n            });\n        }\n        return completeChildren;\n    } else if (completeServerChildren) {\n        // Layer any children we have on top of this\n        // We know we don't have a top-level set, so just enumerate existing children\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\n        });\n        // Add any complete children we have from the set\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    } else {\n        // We don't have anything to layer on top of. Layer on any children we have\n        // Note that we can return an empty snap if we have a defined delete\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    }\n}\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */ function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingEventSnap || existingServerSnap, \"Either existingEventSnap or existingServerSnap must exist\");\n    const path = pathChild(treePath, childPath);\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\n        // At this point we can probably guarantee that we're in case 2, meaning no events\n        // May need to check visibility while doing the findRootMostValueAndPath call\n        return null;\n    } else {\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n        if (compoundWriteIsEmpty(childMerge)) {\n            // We're not shadowing at all. Case 1\n            return existingServerSnap.getChild(childPath);\n        } else {\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n            // However this is tricky to find out, since user updates don't necessary change the server\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n            // only check if the updates change the serverNode.\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\n        }\n    }\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\n    const path = pathChild(treePath, childKey);\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n    if (shadowingNode != null) {\n        return shadowingNode;\n    } else {\n        if (existingServerSnap.isCompleteForChild(childKey)) {\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\n        } else {\n            return null;\n        }\n    }\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */ function writeTreeShadowingWrite(writeTree, path) {\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */ function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\n    let toIterate;\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\n    if (shadowingNode != null) {\n        toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n        toIterate = compoundWriteApply(merge, completeServerData);\n    } else {\n        // no children to iterate on\n        return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n        const nodes = [];\n        const cmp = index.getCompare();\n        const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n        let next = iter.getNext();\n        while(next && nodes.length < count){\n            if (cmp(next, startPost) !== 0) {\n                nodes.push(next);\n            }\n            next = iter.getNext();\n        }\n        return nodes;\n    } else {\n        return [];\n    }\n}\nfunction newWriteTree() {\n    return {\n        visibleWrites: CompoundWrite.empty(),\n        allWrites: [],\n        lastWriteId: -1\n    };\n}\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n}\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */ function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\n}\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */ function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */ function writeTreeRefShadowingWrite(writeTreeRef, path) {\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */ function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\n}\n/**\r\n * Return a WriteTreeRef for a child.\r\n */ function writeTreeRefChild(writeTreeRef, childName) {\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\n}\nfunction newWriteTreeRef(path, writeTree) {\n    return {\n        treePath: path,\n        writeTree\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ChildChangeAccumulator {\n    constructor(){\n        this.changeMap = new Map();\n    }\n    trackChildChange(change) {\n        const type = change.type;\n        const childKey = change.childName;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(type === \"child_added\" /* ChangeType.CHILD_ADDED */  || type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  || type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ , \"Only child changes supported for tracking\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childKey !== \".priority\", \"Only non-priority child changes can be tracked.\");\n        const oldChange = this.changeMap.get(childKey);\n        if (oldChange) {\n            const oldType = oldChange.type;\n            if (type === \"child_added\" /* ChangeType.CHILD_ADDED */  && oldType === \"child_removed\" /* ChangeType.CHILD_REMOVED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.delete(childKey);\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Illegal combination of changes: \" + change + \" occurred after \" + oldChange);\n            }\n        } else {\n            this.changeMap.set(childKey, change);\n        }\n    }\n    getChanges() {\n        return Array.from(this.changeMap.values());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nclass NoCompleteChildSource_ {\n    getCompleteChild(childKey) {\n        return null;\n    }\n    getChildAfterChild(index, child, reverse) {\n        return null;\n    }\n}\n/**\r\n * Singleton instance.\r\n */ const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */ class WriteTreeCompleteChildSource {\n    constructor(writes_, viewCache_, optCompleteServerCache_ = null){\n        this.writes_ = writes_;\n        this.viewCache_ = viewCache_;\n        this.optCompleteServerCache_ = optCompleteServerCache_;\n    }\n    getCompleteChild(childKey) {\n        const node = this.viewCache_.eventCache;\n        if (node.isCompleteForChild(childKey)) {\n            return node.getNode().getImmediateChild(childKey);\n        } else {\n            const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;\n            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);\n        }\n    }\n    getChildAfterChild(index, child, reverse) {\n        const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);\n        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);\n        if (nodes.length === 0) {\n            return null;\n        } else {\n            return nodes[0];\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewProcessor(filter) {\n    return {\n        filter\n    };\n}\nfunction viewProcessorAssertIndexed(viewProcessor, viewCache) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Event snap not indexed\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Server snap not indexed\");\n}\nfunction viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n        const overwrite = operation;\n        if (overwrite.source.fromUser) {\n            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(overwrite.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered  and the\n            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n            // again\n            filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);\n            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.MERGE) {\n        const merge = operation;\n        if (merge.source.fromUser) {\n            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(merge.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered\n            filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();\n            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n        const ackUserWrite = operation;\n        if (!ackUserWrite.revert) {\n            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n        } else {\n            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n        }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Unknown operation type: \" + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);\n    return {\n        viewCache: newViewCache,\n        changes\n    };\n}\nfunction viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {\n    const eventSnap = newViewCache.eventCache;\n    if (eventSnap.isFullyInitialized()) {\n        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);\n        if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));\n        }\n    }\n}\nfunction viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {\n    const oldEventSnap = viewCache.eventCache;\n    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {\n        // we have a shadowing write, ignore changes\n        return viewCache;\n    } else {\n        let newEventCache, serverNode;\n        if (pathIsEmpty(changePath)) {\n            // TODO: figure out how this plays with \"sliding ack windows\"\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.isFullyInitialized(), \"If change path is empty, we must have complete server data\");\n            if (viewCache.serverCache.isFiltered()) {\n                // We need to special case this, because we need to only apply writes to complete children, or\n                // we might end up raising events for incomplete children. If the server data is filtered deep\n                // writes cannot be guaranteed to be complete\n                const serverCache = viewCacheGetCompleteServerSnap(viewCache);\n                const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;\n                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);\n            } else {\n                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);\n            }\n        } else {\n            const childKey = pathGetFront(changePath);\n            if (childKey === \".priority\") {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetLength(changePath) === 1, \"Can't have a priority with additional path components\");\n                const oldEventNode = oldEventSnap.getNode();\n                serverNode = viewCache.serverCache.getNode();\n                // we might have overwrites for this priority\n                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);\n                if (updatedPriority != null) {\n                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);\n                } else {\n                    // priority didn't change, keep old node\n                    newEventCache = oldEventSnap.getNode();\n                }\n            } else {\n                const childChangePath = pathPopFront(changePath);\n                // update child\n                let newEventChild;\n                if (oldEventSnap.isCompleteForChild(childKey)) {\n                    serverNode = viewCache.serverCache.getNode();\n                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);\n                    if (eventChildUpdate != null) {\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n                    } else {\n                        // Nothing changed, just keep the old child\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                    }\n                } else {\n                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n                }\n                if (newEventChild != null) {\n                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                } else {\n                    // no complete child available or no change\n                    newEventCache = oldEventSnap.getNode();\n                }\n            }\n        }\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());\n    }\n}\nfunction viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    const oldServerSnap = oldViewCache.serverCache;\n    let newServerCache;\n    const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();\n    if (pathIsEmpty(changePath)) {\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n        const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {\n            // We don't update incomplete nodes with updates intended for other listeners\n            return oldViewCache;\n        }\n        const childChangePath = pathPopFront(changePath);\n        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n        const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n        if (childKey === \".priority\") {\n            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n        } else {\n            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\n        }\n    }\n    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);\n}\nfunction viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    const oldEventSnap = oldViewCache.eventCache;\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n    if (pathIsEmpty(changePath)) {\n        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);\n        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (childKey === \".priority\") {\n            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);\n            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n        } else {\n            const childChangePath = pathPopFront(changePath);\n            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            let newChild;\n            if (pathIsEmpty(childChangePath)) {\n                // Child overwrite, we can replace the child\n                newChild = changedSnap;\n            } else {\n                const childNode = source.getCompleteChild(childKey);\n                if (childNode != null) {\n                    if (pathGetBack(childChangePath) === \".priority\" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {\n                        // This is a priority update on an empty node. If this node exists on the server, the\n                        // server will send down the priority in the update, so ignore for now\n                        newChild = childNode;\n                    } else {\n                        newChild = childNode.updateChild(childChangePath, changedSnap);\n                    }\n                } else {\n                    // There is no complete child node available\n                    newChild = ChildrenNode.EMPTY_NODE;\n                }\n            }\n            if (!oldChild.equals(newChild)) {\n                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());\n            } else {\n                newViewCache = oldViewCache;\n            }\n        }\n    }\n    return newViewCache;\n}\nfunction viewProcessorCacheHasChild(viewCache, childKey) {\n    return viewCache.eventCache.isCompleteForChild(childKey);\n}\nfunction viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorApplyMerge(viewProcessor, node, merge) {\n    merge.foreach((relativePath, childNode)=>{\n        node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n}\nfunction viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {\n        return viewCache;\n    }\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (pathIsEmpty(path)) {\n        viewMergeTree = changedChildren;\n    } else {\n        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.serverCache.getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree)=>{\n        if (serverNode.hasChild(childKey)) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree)=>{\n        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === null;\n        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {\n        return viewCache;\n    }\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.serverCache.isFiltered();\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.serverCache;\n    if (affectedTree.value != null) {\n        // This is an overwrite.\n        if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n        } else if (pathIsEmpty(ackPath)) {\n            // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n            // should just re-apply whatever we have in our cache as a merge.\n            let changedChildren = new ImmutableTree(null);\n            serverCache.getNode().forEachChild(KEY_INDEX, (name, node)=>{\n                changedChildren = changedChildren.set(new Path(name), node);\n            });\n            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n        } else {\n            return viewCache;\n        }\n    } else {\n        // This is a merge.\n        let changedChildren = new ImmutableTree(null);\n        affectedTree.foreach((mergePath, value)=>{\n            const serverCachePath = pathChild(ackPath, mergePath);\n            if (serverCache.isCompleteForPath(serverCachePath)) {\n                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n            }\n        });\n        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n    }\n}\nfunction viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {\n    const oldServerNode = viewCache.serverCache;\n    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\n}\nfunction viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {\n    let complete;\n    if (writeTreeRefShadowingWrite(writesCache, path) != null) {\n        return viewCache;\n    } else {\n        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n        const oldEventCache = viewCache.eventCache.getNode();\n        let newEventCache;\n        if (pathIsEmpty(path) || pathGetFront(path) === \".priority\") {\n            let newNode;\n            if (viewCache.serverCache.isFullyInitialized()) {\n                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n            } else {\n                const serverChildren = viewCache.serverCache.getNode();\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(serverChildren instanceof ChildrenNode, \"serverChildren would be complete if leaf node\");\n                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);\n            }\n            newNode = newNode;\n            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);\n        } else {\n            const childKey = pathGetFront(path);\n            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n            if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {\n                newChild = oldEventCache.getImmediateChild(childKey);\n            }\n            if (newChild != null) {\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);\n            } else if (viewCache.eventCache.getNode().hasChild(childKey)) {\n                // No complete child available, delete the existing one, if any\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);\n            } else {\n                newEventCache = oldEventCache;\n            }\n            if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {\n                // We might have reverted all child writes. Maybe the old event was a leaf node\n                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                if (complete.isLeafNode()) {\n                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);\n                }\n            }\n        }\n        complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */ class View {\n    constructor(query_, initialViewCache){\n        this.query_ = query_;\n        this.eventRegistrations_ = [];\n        const params = this.query_._queryParams;\n        const indexFilter = new IndexedFilter(params.getIndex());\n        const filter = queryParamsGetNodeFilter(params);\n        this.processor_ = newViewProcessor(filter);\n        const initialServerCache = initialViewCache.serverCache;\n        const initialEventCache = initialViewCache.eventCache;\n        // Don't filter server node with other filter than index, wait for tagged listen\n        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\n        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\n        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\n        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\n        this.viewCache_ = newViewCache(newEventCache, newServerCache);\n        this.eventGenerator_ = new EventGenerator(this.query_);\n    }\n    get query() {\n        return this.query_;\n    }\n}\nfunction viewGetServerCache(view) {\n    return view.viewCache_.serverCache.getNode();\n}\nfunction viewGetCompleteNode(view) {\n    return viewCacheGetCompleteEventSnap(view.viewCache_);\n}\nfunction viewGetCompleteServerCache(view, path) {\n    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);\n    if (cache) {\n        // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\n        // we need to see if it contains the child we're interested in.\n        if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {\n            return cache.getChild(path);\n        }\n    }\n    return null;\n}\nfunction viewIsEmpty(view) {\n    return view.eventRegistrations_.length === 0;\n}\nfunction viewAddEventRegistration(view, eventRegistration) {\n    view.eventRegistrations_.push(eventRegistration);\n}\n/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function viewRemoveEventRegistration(view, eventRegistration, cancelError) {\n    const cancelEvents = [];\n    if (cancelError) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventRegistration == null, \"A cancel should cancel all event registrations.\");\n        const path = view.query._path;\n        view.eventRegistrations_.forEach((registration)=>{\n            const maybeEvent = registration.createCancelEvent(cancelError, path);\n            if (maybeEvent) {\n                cancelEvents.push(maybeEvent);\n            }\n        });\n    }\n    if (eventRegistration) {\n        let remaining = [];\n        for(let i = 0; i < view.eventRegistrations_.length; ++i){\n            const existing = view.eventRegistrations_[i];\n            if (!existing.matches(eventRegistration)) {\n                remaining.push(existing);\n            } else if (eventRegistration.hasAnyCallback()) {\n                // We're removing just this one\n                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));\n                break;\n            }\n        }\n        view.eventRegistrations_ = remaining;\n    } else {\n        view.eventRegistrations_ = [];\n    }\n    return cancelEvents;\n}\n/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */ function viewApplyOperation(view, operation, writesCache, completeServerCache) {\n    if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_), \"We should always have a full cache before handling merges\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_), \"Missing event cache, even though we have a server cache\");\n    }\n    const oldViewCache = view.viewCache_;\n    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);\n    viewProcessorAssertIndexed(view.processor_, result.viewCache);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), \"Once a server snap is complete, it should never go back\");\n    view.viewCache_ = result.viewCache;\n    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);\n}\nfunction viewGetInitialEvents(view, registration) {\n    const eventSnap = view.viewCache_.eventCache;\n    const initialChanges = [];\n    if (!eventSnap.getNode().isLeafNode()) {\n        const eventNode = eventSnap.getNode();\n        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            initialChanges.push(changeChildAdded(key, childNode));\n        });\n    }\n    if (eventSnap.isFullyInitialized()) {\n        initialChanges.push(changeValue(eventSnap.getNode()));\n    }\n    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);\n}\nfunction viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {\n    const registrations = eventRegistration ? [\n        eventRegistration\n    ] : view.eventRegistrations_;\n    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor$1;\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */ class SyncPoint {\n    constructor(){\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */ this.views = new Map();\n    }\n}\nfunction syncPointSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor$1, \"__referenceConstructor has already been defined\");\n    referenceConstructor$1 = val;\n}\nfunction syncPointGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor$1, \"Reference.ts has not been loaded\");\n    return referenceConstructor$1;\n}\nfunction syncPointIsEmpty(syncPoint) {\n    return syncPoint.views.size === 0;\n}\nfunction syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n        const view = syncPoint.views.get(queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(view != null, \"SyncTree gave us an op for an invalid query.\");\n        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);\n    } else {\n        let events = [];\n        for (const view of syncPoint.views.values()){\n            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {\n    const queryId = query._queryIdentifier;\n    const view = syncPoint.views.get(queryId);\n    if (!view) {\n        // TODO: make writesCache take flag for complete server node\n        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);\n        let eventCacheComplete = false;\n        if (eventCache) {\n            eventCacheComplete = true;\n        } else if (serverCache instanceof ChildrenNode) {\n            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);\n            eventCacheComplete = false;\n        } else {\n            eventCache = ChildrenNode.EMPTY_NODE;\n            eventCacheComplete = false;\n        }\n        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));\n        return new View(query, viewCache);\n    }\n    return view;\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);\n    if (!syncPoint.views.has(query._queryIdentifier)) {\n        syncPoint.views.set(query._queryIdentifier, view);\n    }\n    // This is guaranteed to exist now, we just created anything that was missing\n    viewAddEventRegistration(view, eventRegistration);\n    return viewGetInitialEvents(view, eventRegistration);\n}\n/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */ function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {\n    const queryId = query._queryIdentifier;\n    const removed = [];\n    let cancelEvents = [];\n    const hadCompleteView = syncPointHasCompleteView(syncPoint);\n    if (queryId === \"default\") {\n        // When you do ref.off(...), we search all views for the registration to remove.\n        for (const [viewQueryId, view] of syncPoint.views.entries()){\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(viewQueryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    } else {\n        // remove the callback from the specific view.\n        const view = syncPoint.views.get(queryId);\n        if (view) {\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(queryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    }\n    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {\n        // We removed our last complete view.\n        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));\n    }\n    return {\n        removed,\n        events: cancelEvents\n    };\n}\nfunction syncPointGetQueryViews(syncPoint) {\n    const result = [];\n    for (const view of syncPoint.views.values()){\n        if (!view.query._queryParams.loadsAllData()) {\n            result.push(view);\n        }\n    }\n    return result;\n}\n/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */ function syncPointGetCompleteServerCache(syncPoint, path) {\n    let serverCache = null;\n    for (const view of syncPoint.views.values()){\n        serverCache = serverCache || viewGetCompleteServerCache(view, path);\n    }\n    return serverCache;\n}\nfunction syncPointViewForQuery(syncPoint, query) {\n    const params = query._queryParams;\n    if (params.loadsAllData()) {\n        return syncPointGetCompleteView(syncPoint);\n    } else {\n        const queryId = query._queryIdentifier;\n        return syncPoint.views.get(queryId);\n    }\n}\nfunction syncPointViewExistsForQuery(syncPoint, query) {\n    return syncPointViewForQuery(syncPoint, query) != null;\n}\nfunction syncPointHasCompleteView(syncPoint) {\n    return syncPointGetCompleteView(syncPoint) != null;\n}\nfunction syncPointGetCompleteView(syncPoint) {\n    for (const view of syncPoint.views.values()){\n        if (view.query._queryParams.loadsAllData()) {\n            return view;\n        }\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor;\nfunction syncTreeSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor, \"__referenceConstructor has already been defined\");\n    referenceConstructor = val;\n}\nfunction syncTreeGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor, \"Reference.ts has not been loaded\");\n    return referenceConstructor;\n}\n/**\r\n * Static tracker for next query tag.\r\n */ let syncTreeNextQueryTag_ = 1;\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */ class SyncTree {\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */ constructor(listenProvider_){\n        this.listenProvider_ = listenProvider_;\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */ this.syncPointTree_ = new ImmutableTree(null);\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */ this.pendingWriteTree_ = newWriteTree();\n        this.tagToQueryMap = new Map();\n        this.queryToTagMap = new Map();\n    }\n}\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\n    // Record pending write.\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\n    if (!visible) {\n        return [];\n    } else {\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\n    }\n}\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\n    // Record pending merge.\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\n}\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */ function syncTreeAckUserWrite(syncTree, writeId, revert = false) {\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\n    if (!needToReevaluate) {\n        return [];\n    } else {\n        let affectedTree = new ImmutableTree(null);\n        if (write.snap != null) {\n            // overwrite\n            affectedTree = affectedTree.set(newEmptyPath(), true);\n        } else {\n            each(write.children, (pathString)=>{\n                affectedTree = affectedTree.set(new Path(pathString), true);\n            });\n        }\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\n    }\n}\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerOverwrite(syncTree, path, newData) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\n}\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerMerge(syncTree, path, changedChildren) {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\n}\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyListenComplete(syncTree, path) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\n}\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query._path;\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\n    let cancelEvents = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (maybeSyncPoint && (query._queryIdentifier === \"default\" || syncPointViewExistsForQuery(maybeSyncPoint, query))) {\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\n        if (syncPointIsEmpty(maybeSyncPoint)) {\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\n        }\n        const removed = removedAndEvents.removed;\n        cancelEvents = removedAndEvents.events;\n        if (!skipListenerDedup) {\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */ // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n            // queryId === 'default'\n            const removingDefault = -1 !== removed.findIndex((query)=>{\n                return query._queryParams.loadsAllData();\n            });\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint));\n            if (removingDefault && !covered) {\n                const subtree = syncTree.syncPointTree_.subtree(path);\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\n                // removal\n                if (!subtree.isEmpty()) {\n                    // We need to fold over our subtree and collect the listeners to send\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\n                    // Ok, we've collected all the listens we need. Set them up.\n                    for(let i = 0; i < newViews.length; ++i){\n                        const view = newViews[i], newQuery = view.query;\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\n                    }\n                }\n            // Otherwise there's nothing below us, so nothing we need to start listening on\n            }\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\n            if (!covered && removed.length > 0 && !cancelError) {\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n                // default. Otherwise, we need to iterate through and cancel each individual query\n                if (removingDefault) {\n                    // We don't tag default listeners\n                    const defaultTag = null;\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\n                } else {\n                    removed.forEach((queryToRemove)=>{\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\n                    });\n                }\n            }\n        }\n        // Now, clear all of the tags we're tracking for the removed listens\n        syncTreeRemoveTags_(syncTree, removed);\n    }\n    return cancelEvents;\n}\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey != null) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // Query must have been removed already\n        return [];\n    }\n}\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const changeTree = ImmutableTree.fromObject(changedChildren);\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\n    const path = query._path;\n    let serverCache = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let serverCacheComplete;\n    if (serverCache != null) {\n        serverCacheComplete = true;\n    } else {\n        serverCacheComplete = false;\n        serverCache = ChildrenNode.EMPTY_NODE;\n        const subtree = syncTree.syncPointTree_.subtree(path);\n        subtree.foreachChild((childName, childSyncPoint)=>{\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\n            if (completeCache) {\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\n            }\n        });\n    }\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\n        // We need to track a tag for this query\n        const queryKey = syncTreeMakeQueryKey_(query);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncTree.queryToTagMap.has(queryKey), \"View does not exist, but we have a tag\");\n        const tag = syncTreeGetNextQueryTag_();\n        syncTree.queryToTagMap.set(queryKey, tag);\n        syncTree.tagToQueryMap.set(tag, queryKey);\n    }\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\n        const view = syncPointViewForQuery(syncPoint, query);\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\n    }\n    return events;\n}\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */ function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\n    const includeHiddenSets = true;\n    const writeTree = syncTree.pendingWriteTree_;\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint)=>{\n        const relativePath = newRelativePath(pathSoFar, path);\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\n        if (serverCache) {\n            return serverCache;\n        }\n    });\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\n}\nfunction syncTreeGetServerValue(syncTree, query) {\n    const path = query._path;\n    let serverCache = null;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    const serverCacheComplete = serverCache != null;\n    const serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\n    return viewGetCompleteNode(view);\n}\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */ function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\n    if (pathIsEmpty(operation.path)) {\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n    } else {\n        const syncPoint = syncPointTree.get(newEmptyPath());\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\n        if (serverCache == null && syncPoint != null) {\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n        }\n        let events = [];\n        const childName = pathGetFront(operation.path);\n        const childOperation = operation.operationForChild(childName);\n        const childTree = syncPointTree.children.get(childName);\n        if (childTree && childOperation) {\n            const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n        if (syncPoint) {\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\n    const syncPoint = syncPointTree.get(newEmptyPath());\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let events = [];\n    syncPointTree.children.inorderTraversal((childName, childTree)=>{\n        const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\n        const childOperation = operation.operationForChild(childName);\n        if (childOperation) {\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n    });\n    if (syncPoint) {\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n    }\n    return events;\n}\nfunction syncTreeCreateListenerForView_(syncTree, view) {\n    const query = view.query;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    return {\n        hashFn: ()=>{\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\n            return cache.hash();\n        },\n        onComplete: (status)=>{\n            if (status === \"ok\") {\n                if (tag) {\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\n                } else {\n                    return syncTreeApplyListenComplete(syncTree, query._path);\n                }\n            } else {\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n                const error = errorForServerCode(status, query);\n                return syncTreeRemoveEventRegistration(syncTree, query, /*eventRegistration*/ null, error);\n            }\n        }\n    };\n}\n/**\r\n * Return the tag associated with the given query.\r\n */ function syncTreeTagForQuery(syncTree, query) {\n    const queryKey = syncTreeMakeQueryKey_(query);\n    return syncTree.queryToTagMap.get(queryKey);\n}\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */ function syncTreeMakeQueryKey_(query) {\n    return query._path.toString() + \"$\" + query._queryIdentifier;\n}\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */ function syncTreeQueryKeyForTag_(syncTree, tag) {\n    return syncTree.tagToQueryMap.get(tag);\n}\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */ function syncTreeParseQueryKey_(queryKey) {\n    const splitIndex = queryKey.indexOf(\"$\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, \"Bad queryKey.\");\n    return {\n        queryId: queryKey.substr(splitIndex + 1),\n        path: new Path(queryKey.substr(0, splitIndex))\n    };\n}\n/**\r\n * A helper method to apply tagged operations\r\n */ function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\n}\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */ function syncTreeCollectDistinctViewsForSubTree_(subtree) {\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\n            return [\n                completeView\n            ];\n        } else {\n            // No complete view here, flatten any deeper listens into an array\n            let views = [];\n            if (maybeChildSyncPoint) {\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\n            }\n            each(childMap, (_key, childViews)=>{\n                views = views.concat(childViews);\n            });\n            return views;\n        }\n    });\n}\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */ function syncTreeQueryForListening_(query) {\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\n        // We treat queries that load all data as default queries\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n        // from Query\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\n    } else {\n        return query;\n    }\n}\nfunction syncTreeRemoveTags_(syncTree, queries) {\n    for(let j = 0; j < queries.length; ++j){\n        const removedQuery = queries[j];\n        if (!removedQuery._queryParams.loadsAllData()) {\n            // We should have a tag for this\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\n            syncTree.queryToTagMap.delete(removedQueryKey);\n            syncTree.tagToQueryMap.delete(removedQueryTag);\n        }\n    }\n}\n/**\r\n * Static accessor for query tags.\r\n */ function syncTreeGetNextQueryTag_() {\n    return syncTreeNextQueryTag_++;\n}\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */ function syncTreeSetupListener_(syncTree, query, view) {\n    const path = query._path;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\n    const subtree = syncTree.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\n    } else {\n        // Shadow everything at or below this location, this is a default listener.\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n            if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n                return [\n                    syncPointGetCompleteView(maybeChildSyncPoint).query\n                ];\n            } else {\n                // No default listener here, flatten any deeper queries into an array\n                let queries = [];\n                if (maybeChildSyncPoint) {\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view)=>view.query));\n                }\n                each(childMap, (_key, childQueries)=>{\n                    queries = queries.concat(childQueries);\n                });\n                return queries;\n            }\n        });\n        for(let i = 0; i < queriesToStop.length; ++i){\n            const queryToStop = queriesToStop[i];\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\n        }\n    }\n    return events;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ExistingValueProvider {\n    constructor(node_){\n        this.node_ = node_;\n    }\n    getImmediateChild(childName) {\n        const child = this.node_.getImmediateChild(childName);\n        return new ExistingValueProvider(child);\n    }\n    node() {\n        return this.node_;\n    }\n}\nclass DeferredValueProvider {\n    constructor(syncTree, path){\n        this.syncTree_ = syncTree;\n        this.path_ = path;\n    }\n    getImmediateChild(childName) {\n        const childPath = pathChild(this.path_, childName);\n        return new DeferredValueProvider(this.syncTree_, childPath);\n    }\n    node() {\n        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);\n    }\n}\n/**\r\n * Generate placeholders for deferred values.\r\n */ const generateWithValues = function(values) {\n    values = values || {};\n    values[\"timestamp\"] = values[\"timestamp\"] || new Date().getTime();\n    return values;\n};\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */ const resolveDeferredLeafValue = function(value, existingVal, serverValues) {\n    if (!value || typeof value !== \"object\") {\n        return value;\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(\".sv\" in value, \"Unexpected leaf node or priority contents\");\n    if (typeof value[\".sv\"] === \"string\") {\n        return resolveScalarDeferredValue(value[\".sv\"], existingVal, serverValues);\n    } else if (typeof value[\".sv\"] === \"object\") {\n        return resolveComplexDeferredValue(value[\".sv\"], existingVal);\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(value, null, 2));\n    }\n};\nconst resolveScalarDeferredValue = function(op, existing, serverValues) {\n    switch(op){\n        case \"timestamp\":\n            return serverValues[\"timestamp\"];\n        default:\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + op);\n    }\n};\nconst resolveComplexDeferredValue = function(op, existing, unused) {\n    if (!op.hasOwnProperty(\"increment\")) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(op, null, 2));\n    }\n    const delta = op[\"increment\"];\n    if (typeof delta !== \"number\") {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected increment value: \" + delta);\n    }\n    const existingNode = existing.node();\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingNode !== null && typeof existingNode !== \"undefined\", \"Expected ChildrenNode.EMPTY_NODE for nulls\");\n    // Incrementing a non-number sets the value to the incremented amount\n    if (!existingNode.isLeafNode()) {\n        return delta;\n    }\n    const leaf = existingNode;\n    const existingVal = leaf.getValue();\n    if (typeof existingVal !== \"number\") {\n        return delta;\n    }\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\n    return existingVal + delta;\n};\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */ const resolveDeferredValueTree = function(path, node, syncTree, serverValues) {\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\n};\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */ const resolveDeferredValueSnapshot = function(node, existing, serverValues) {\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\n};\nfunction resolveDeferredValue(node, existingVal, serverValues) {\n    const rawPri = node.getPriority().val();\n    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(\".priority\"), serverValues);\n    let newNode;\n    if (node.isLeafNode()) {\n        const leafNode = node;\n        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\n        if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {\n            return new LeafNode(value, nodeFromJSON(priority));\n        } else {\n            return node;\n        }\n    } else {\n        const childrenNode = node;\n        newNode = childrenNode;\n        if (priority !== childrenNode.getPriority().val()) {\n            newNode = newNode.updatePriority(new LeafNode(priority));\n        }\n        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\n            if (newChildNode !== childNode) {\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\n            }\n        });\n        return newNode;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */ class Tree {\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */ constructor(name = \"\", parent = null, node = {\n        children: {},\n        childCount: 0\n    }){\n        this.name = name;\n        this.parent = parent;\n        this.node = node;\n    }\n}\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */ function treeSubTree(tree, pathObj) {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = tree, next = pathGetFront(path);\n    while(next !== null){\n        const childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(child.node.children, next) || {\n            children: {},\n            childCount: 0\n        };\n        child = new Tree(next, child, childNode);\n        path = pathPopFront(path);\n        next = pathGetFront(path);\n    }\n    return child;\n}\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */ function treeGetValue(tree) {\n    return tree.node.value;\n}\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */ function treeSetValue(tree, value) {\n    tree.node.value = value;\n    treeUpdateParents(tree);\n}\n/**\r\n * @returns Whether the tree has any children.\r\n */ function treeHasChildren(tree) {\n    return tree.node.childCount > 0;\n}\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */ function treeIsEmpty(tree) {\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\n}\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */ function treeForEachChild(tree, action) {\n    each(tree.node.children, (child, childTree)=>{\n        action(new Tree(child, tree, childTree));\n    });\n}\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */ function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) {\n        action(tree);\n    }\n    treeForEachChild(tree, (child)=>{\n        treeForEachDescendant(child, action, true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) {\n        action(tree);\n    }\n}\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */ function treeForEachAncestor(tree, action, includeSelf) {\n    let node = includeSelf ? tree : tree.parent;\n    while(node !== null){\n        if (action(node)) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */ function treeGetPath(tree) {\n    return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + \"/\" + tree.name);\n}\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */ function treeUpdateParents(tree) {\n    if (tree.parent !== null) {\n        treeUpdateChild(tree.parent, tree.name, tree);\n    }\n}\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */ function treeUpdateChild(tree, childName, child) {\n    const childEmpty = treeIsEmpty(child);\n    const childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(tree.node.children, childName);\n    if (childEmpty && childExists) {\n        delete tree.node.children[childName];\n        tree.node.childCount--;\n        treeUpdateParents(tree);\n    } else if (!childEmpty && !childExists) {\n        tree.node.children[childName] = child.node;\n        tree.node.childCount++;\n        treeUpdateParents(tree);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * True for invalid Firebase keys\r\n */ const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */ const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\r\n * Maximum number of characters to allow in leaf value\r\n */ const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\nconst isValidKey = function(key) {\n    return typeof key === \"string\" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);\n};\nconst isValidPathString = function(pathString) {\n    return typeof pathString === \"string\" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);\n};\nconst isValidRootPathString = function(pathString) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    return isValidPathString(pathString);\n};\nconst isValidPriority = function(priority) {\n    return priority === null || typeof priority === \"string\" || typeof priority === \"number\" && !isInvalidJSONNumber(priority) || priority && typeof priority === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(priority, \".sv\");\n};\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */ const validateFirebaseDataArg = function(fnName, value, path, optional) {\n    if (optional && value === undefined) {\n        return;\n    }\n    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"value\"), value, path);\n};\n/**\r\n * Validate a data object client-side before sending to server.\r\n */ const validateFirebaseData = function(errorPrefix, data, path_) {\n    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n    if (data === undefined) {\n        throw new Error(errorPrefix + \"contains undefined \" + validationPathToErrorString(path));\n    }\n    if (typeof data === \"function\") {\n        throw new Error(errorPrefix + \"contains a function \" + validationPathToErrorString(path) + \" with contents = \" + data.toString());\n    }\n    if (isInvalidJSONNumber(data)) {\n        throw new Error(errorPrefix + \"contains \" + data.toString() + \" \" + validationPathToErrorString(path));\n    }\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\n    if (typeof data === \"string\" && data.length > MAX_LEAF_SIZE_ / 3 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(data) > MAX_LEAF_SIZE_) {\n        throw new Error(errorPrefix + \"contains a string greater than \" + MAX_LEAF_SIZE_ + \" utf8 bytes \" + validationPathToErrorString(path) + \" ('\" + data.substring(0, 50) + \"...')\");\n    }\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n    // to save extra walking of large objects.\n    if (data && typeof data === \"object\") {\n        let hasDotValue = false;\n        let hasActualChild = false;\n        each(data, (key, value)=>{\n            if (key === \".value\") {\n                hasDotValue = true;\n            } else if (key !== \".priority\" && key !== \".sv\") {\n                hasActualChild = true;\n                if (!isValidKey(key)) {\n                    throw new Error(errorPrefix + \" contains an invalid key (\" + key + \") \" + validationPathToErrorString(path) + \".  Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n                }\n            }\n            validationPathPush(path, key);\n            validateFirebaseData(errorPrefix, value, path);\n            validationPathPop(path);\n        });\n        if (hasDotValue && hasActualChild) {\n            throw new Error(errorPrefix + ' contains \".value\" child ' + validationPathToErrorString(path) + \" in addition to actual children.\");\n        }\n    }\n};\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n */ const validateFirebaseMergePaths = function(errorPrefix, mergePaths) {\n    let i, curPath;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        const keys = pathSlice(curPath);\n        for(let j = 0; j < keys.length; j++){\n            if (keys[j] === \".priority\" && j === keys.length - 1) ;\n            else if (!isValidKey(keys[j])) {\n                throw new Error(errorPrefix + \"contains an invalid key (\" + keys[j] + \") in path \" + curPath.toString() + \". Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n            }\n        }\n    }\n    // Check that update keys are not descendants of each other.\n    // We rely on the property that sorting guarantees that ancestors come\n    // right before descendants.\n    mergePaths.sort(pathCompare);\n    let prevPath = null;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        if (prevPath !== null && pathContains(prevPath, curPath)) {\n            throw new Error(errorPrefix + \"contains a path \" + prevPath.toString() + \" that is ancestor of another path \" + curPath.toString());\n        }\n        prevPath = curPath;\n    }\n};\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */ const validateFirebaseMergeDataArg = function(fnName, data, path, optional) {\n    if (optional && data === undefined) {\n        return;\n    }\n    const errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"values\");\n    if (!(data && typeof data === \"object\") || Array.isArray(data)) {\n        throw new Error(errorPrefix$1 + \" must be an object containing the children to replace.\");\n    }\n    const mergePaths = [];\n    each(data, (key, value)=>{\n        const curPath = new Path(key);\n        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));\n        if (pathGetBack(curPath) === \".priority\") {\n            if (!isValidPriority(value)) {\n                throw new Error(errorPrefix$1 + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + \"Firebase priority (a string, finite number, server value, or null).\");\n            }\n        }\n        mergePaths.push(curPath);\n    });\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\n};\nconst validatePriority = function(fnName, priority, optional) {\n    if (optional && priority === undefined) {\n        return;\n    }\n    if (isInvalidJSONNumber(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"is \" + priority.toString() + \", but must be a valid Firebase priority (a string, finite number, \" + \"server value, or null).\");\n    }\n    // Special case to allow importing data with a .sv.\n    if (!isValidPriority(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"must be a valid Firebase priority \" + \"(a string, finite number, server value, or null).\");\n    }\n};\nconst validateKey = function(fnName, argumentName, key, optional) {\n    if (optional && key === undefined) {\n        return;\n    }\n    if (!isValidKey(key)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n    }\n};\n/**\r\n * @internal\r\n */ const validatePathString = function(fnName, argumentName, pathString, optional) {\n    if (optional && pathString === undefined) {\n        return;\n    }\n    if (!isValidPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n    }\n};\nconst validateRootPathString = function(fnName, argumentName, pathString, optional) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    validatePathString(fnName, argumentName, pathString, optional);\n};\n/**\r\n * @internal\r\n */ const validateWritablePath = function(fnName, path) {\n    if (pathGetFront(path) === \".info\") {\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n    }\n};\nconst validateUrl = function(fnName, parsedUrl) {\n    // TODO = Validate server better.\n    const pathString = parsedUrl.path.toString();\n    if (!(typeof parsedUrl.repoInfo.host === \"string\") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(\":\")[0] !== \"localhost\" || pathString.length !== 0 && !isValidRootPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"url\") + \"must be a valid firebase URL and \" + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n    }\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */ class EventQueue {\n    constructor(){\n        this.eventLists_ = [];\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */ this.recursionDepth_ = 0;\n    }\n}\n/**\r\n * @param eventDataList - The new events to queue.\r\n */ function eventQueueQueueEvents(eventQueue, eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for(let i = 0; i < eventDataList.length; i++){\n        const data = eventDataList[i];\n        const path = data.getPath();\n        if (currList !== null && !pathEquals(path, currList.path)) {\n            eventQueue.eventLists_.push(currList);\n            currList = null;\n        }\n        if (currList === null) {\n            currList = {\n                events: [],\n                path\n            };\n        }\n        currList.events.push(data);\n    }\n    if (currList) {\n        eventQueue.eventLists_.push(currList);\n    }\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */ function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathEquals(eventPath, path));\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */ function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));\n}\nfunction eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {\n    eventQueue.recursionDepth_++;\n    let sentAll = true;\n    for(let i = 0; i < eventQueue.eventLists_.length; i++){\n        const eventList = eventQueue.eventLists_[i];\n        if (eventList) {\n            const eventPath = eventList.path;\n            if (predicate(eventPath)) {\n                eventListRaise(eventQueue.eventLists_[i]);\n                eventQueue.eventLists_[i] = null;\n            } else {\n                sentAll = false;\n            }\n        }\n    }\n    if (sentAll) {\n        eventQueue.eventLists_ = [];\n    }\n    eventQueue.recursionDepth_--;\n}\n/**\r\n * Iterates through the list and raises each event\r\n */ function eventListRaise(eventList) {\n    for(let i = 0; i < eventList.events.length; i++){\n        const eventData = eventList.events[i];\n        if (eventData !== null) {\n            eventList.events[i] = null;\n            const eventFn = eventData.getEventRunner();\n            if (logger) {\n                log(\"event: \" + eventData.toString());\n            }\n            exceptionGuard(eventFn);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const INTERRUPT_REASON = \"repo_interrupt\";\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */ const MAX_TRANSACTION_RETRIES = 25;\n/**\r\n * A connection to a single data repository.\r\n */ class Repo {\n    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_){\n        this.repoInfo_ = repoInfo_;\n        this.forceRestClient_ = forceRestClient_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckProvider_ = appCheckProvider_;\n        this.dataUpdateCount = 0;\n        this.statsListener_ = null;\n        this.eventQueue_ = new EventQueue();\n        this.nextWriteId_ = 1;\n        this.interceptServerDataCallback_ = null;\n        /** A list of data pieces and paths to be set when this client disconnects. */ this.onDisconnect_ = newSparseSnapshotTree();\n        /** Stores queues of outstanding transactions for Firebase locations. */ this.transactionQueueTree_ = new Tree();\n        // TODO: This should be @private but it's used by test_access.js and internal.js\n        this.persistentConnection_ = null;\n        // This key is intentionally not updated if RepoInfo is later changed or replaced\n        this.key = this.repoInfo_.toURLString();\n    }\n    /**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */ toString() {\n        return (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host;\n    }\n}\nfunction repoStart(repo, appId, authOverride) {\n    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);\n    if (repo.forceRestClient_ || beingCrawled()) {\n        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, repo.authTokenProvider_, repo.appCheckProvider_);\n        // Minor hack: Fire onConnect immediately, since there's no actual connection.\n        setTimeout(()=>repoOnConnectStatus(repo, /* connectStatus= */ true), 0);\n    } else {\n        // Validate authOverride\n        if (typeof authOverride !== \"undefined\" && authOverride !== null) {\n            if (typeof authOverride !== \"object\") {\n                throw new Error(\"Only objects are supported for option databaseAuthVariableOverride\");\n            }\n            try {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(authOverride);\n            } catch (e) {\n                throw new Error(\"Invalid authOverride provided: \" + e);\n            }\n        }\n        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, (connectStatus)=>{\n            repoOnConnectStatus(repo, connectStatus);\n        }, (updates)=>{\n            repoOnServerInfoUpdate(repo, updates);\n        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);\n        repo.server_ = repo.persistentConnection_;\n    }\n    repo.authTokenProvider_.addTokenChangeListener((token)=>{\n        repo.server_.refreshAuthToken(token);\n    });\n    repo.appCheckProvider_.addTokenChangeListener((result)=>{\n        repo.server_.refreshAppCheckToken(result.token);\n    });\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, ()=>new StatsReporter(repo.stats_, repo.server_));\n    // Used for .info.\n    repo.infoData_ = new SnapshotHolder();\n    repo.infoSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            let infoEvents = [];\n            const node = repo.infoData_.getNode(query._path);\n            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n            // on initial data...\n            if (!node.isEmpty()) {\n                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);\n                setTimeout(()=>{\n                    onComplete(\"ok\");\n                }, 0);\n            }\n            return infoEvents;\n        },\n        stopListening: ()=>{}\n    });\n    repoUpdateInfo(repo, \"connected\", false);\n    repo.serverSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            repo.server_.listen(query, currentHashFn, tag, (status, data)=>{\n                const events = onComplete(status, data);\n                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n            });\n            // No synchronous events for network-backed sync trees\n            return [];\n        },\n        stopListening: (query, tag)=>{\n            repo.server_.unlisten(query, tag);\n        }\n    });\n}\n/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */ function repoServerTime(repo) {\n    const offsetNode = repo.infoData_.getNode(new Path(\".info/serverTimeOffset\"));\n    const offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n}\n/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */ function repoGenerateServerValues(repo) {\n    return generateWithValues({\n        timestamp: repoServerTime(repo)\n    });\n}\n/**\r\n * Called by realtime when we get new messages from the server.\r\n */ function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {\n    // For testing.\n    repo.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;\n    let events = [];\n    if (tag) {\n        if (isMerge) {\n            const taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);\n        } else {\n            const taggedSnap = nodeFromJSON(data);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);\n        }\n    } else if (isMerge) {\n        const changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);\n    } else {\n        const snap = nodeFromJSON(data);\n        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n        // Since we have a listener outstanding for each transaction, receiving any events\n        // is a proxy for some change having occurred.\n        affectedPath = repoRerunTransactions(repo, path);\n    }\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);\n}\nfunction repoOnConnectStatus(repo, connectStatus) {\n    repoUpdateInfo(repo, \"connected\", connectStatus);\n    if (connectStatus === false) {\n        repoRunOnDisconnectEvents(repo);\n    }\n}\nfunction repoOnServerInfoUpdate(repo, updates) {\n    each(updates, (key, value)=>{\n        repoUpdateInfo(repo, key, value);\n    });\n}\nfunction repoUpdateInfo(repo, pathString, value) {\n    const path = new Path(\"/.info/\" + pathString);\n    const newNode = nodeFromJSON(value);\n    repo.infoData_.updateSnapshot(path, newNode);\n    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n}\nfunction repoGetNextWriteId(repo) {\n    return repo.nextWriteId_++;\n}\n/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will wait until the\r\n *  repo has established a connection and then request the value for `query`.\r\n * If the client is not able to retrieve the query result for another reason,\r\n * it reports an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */ function repoGetValue(repo, query, eventRegistration) {\n    // Only active queries are cached. There is no persisted cache.\n    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);\n    if (cached != null) {\n        return Promise.resolve(cached);\n    }\n    return repo.server_.get(query).then((payload)=>{\n        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());\n        /**\r\n         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:\r\n         * Add an event registration,\r\n         * Update data at the path,\r\n         * Raise any events,\r\n         * Cleanup the SyncTree\r\n         */ syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);\n        let events;\n        if (query._queryParams.loadsAllData()) {\n            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);\n        } else {\n            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);\n        }\n        /*\r\n         * We need to raise events in the scenario where `get()` is called at a parent path, and\r\n         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting\r\n         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree\r\n         * and its corresponding serverCache, including the child location where `onValue` is called. Then,\r\n         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received\r\n         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.\r\n         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and\r\n         * ensure the corresponding child events will get fired.\r\n         */ eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);\n        return node;\n    }, (err)=>{\n        repoLog(repo, \"get for query \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(query) + \" failed: \" + err);\n        return Promise.reject(new Error(err));\n    });\n}\nfunction repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {\n    repoLog(repo, \"set\", {\n        path: path.toString(),\n        value: newVal,\n        priority: newPriority\n    });\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = repoGenerateServerValues(repo);\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\n    const writeId = repoGetNextWriteId(repo);\n    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);\n    eventQueueQueueEvents(repo.eventQueue_, events);\n    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason)=>{\n        const success = status === \"ok\";\n        if (!success) {\n            warn(\"set at \" + path + \" failed: \" + status);\n        }\n        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n    const affectedPath = repoAbortTransactions(repo, path);\n    repoRerunTransactions(repo, affectedPath);\n    // We queued the events above, so just flush the queue here\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);\n}\nfunction repoUpdate(repo, path, childrenToMerge, onComplete) {\n    repoLog(repo, \"update\", {\n        path: path.toString(),\n        value: childrenToMerge\n    });\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = repoGenerateServerValues(repo);\n    const changedChildren = {};\n    each(childrenToMerge, (changedKey, changedValue)=>{\n        empty = false;\n        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);\n    });\n    if (!empty) {\n        const writeId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);\n        eventQueueQueueEvents(repo.eventQueue_, events);\n        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason)=>{\n            const success = status === \"ok\";\n            if (!success) {\n                warn(\"update at \" + path + \" failed: \" + status);\n            }\n            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);\n            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n        });\n        each(childrenToMerge, (changedPath)=>{\n            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));\n            repoRerunTransactions(repo, affectedPath);\n        });\n        // We queued the events above, so just flush the queue here\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);\n    } else {\n        log(\"update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n    }\n}\n/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */ function repoRunOnDisconnectEvents(repo) {\n    repoLog(repo, \"onDisconnectEvents\");\n    const serverValues = repoGenerateServerValues(repo);\n    const resolvedOnDisconnectTree = newSparseSnapshotTree();\n    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node)=>{\n        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);\n        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);\n    });\n    let events = [];\n    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap)=>{\n        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));\n        const affectedPath = repoAbortTransactions(repo, path);\n        repoRerunTransactions(repo, affectedPath);\n    });\n    repo.onDisconnect_ = newSparseSnapshotTree();\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);\n}\nfunction repoOnDisconnectCancel(repo, path, onComplete) {\n    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeForget(repo.onDisconnect_, path);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSet(repo, path, value, onComplete) {\n    const newNode = nodeFromJSON(value);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {\n    const newNode = nodeFromJSON(value, priority);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(childrenToMerge)) {\n        log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n        return;\n    }\n    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason)=>{\n        if (status === \"ok\") {\n            each(childrenToMerge, (childName, childNode)=>{\n                const newChildNode = nodeFromJSON(childNode);\n                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);\n            });\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoAddEventCallbackForQuery(repo, query, eventRegistration) {\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoInterrupt(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n}\nfunction repoResume(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n}\nfunction repoLog(repo, ...varArgs) {\n    let prefix = \"\";\n    if (repo.persistentConnection_) {\n        prefix = repo.persistentConnection_.id + \":\";\n    }\n    log(prefix, ...varArgs);\n}\nfunction repoCallOnCompleteCallback(repo, callback, status, errorReason) {\n    if (callback) {\n        exceptionGuard(()=>{\n            if (status === \"ok\") {\n                callback(null);\n            } else {\n                const code = (status || \"error\").toUpperCase();\n                let message = code;\n                if (errorReason) {\n                    message += \": \" + errorReason;\n                }\n                const error = new Error(message);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.code = code;\n                callback(error);\n            }\n        });\n    }\n}\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */ function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {\n    repoLog(repo, \"transaction on \" + path);\n    // Initialize transaction.\n    const transaction = {\n        path,\n        update: transactionUpdate,\n        onComplete,\n        // One of TransactionStatus enums.\n        status: null,\n        // Used when combining transactions at different locations to figure out\n        // which one goes first.\n        order: LUIDGenerator(),\n        // Whether to raise local events for this transaction.\n        applyLocally,\n        // Count of how many times we've retried the transaction.\n        retryCount: 0,\n        // Function to call to clean up our .on() listener.\n        unwatcher,\n        // Stores why a transaction was aborted.\n        abortReason: null,\n        currentWriteId: null,\n        currentInputSnapshot: null,\n        currentOutputSnapshotRaw: null,\n        currentOutputSnapshotResolved: null\n    };\n    // Run transaction initially.\n    const currentState = repoGetLatestState(repo, path, undefined);\n    transaction.currentInputSnapshot = currentState;\n    const newVal = transaction.update(currentState.val());\n    if (newVal === undefined) {\n        // Abort transaction.\n        transaction.unwatcher();\n        transaction.currentOutputSnapshotRaw = null;\n        transaction.currentOutputSnapshotResolved = null;\n        if (transaction.onComplete) {\n            transaction.onComplete(null, false, transaction.currentInputSnapshot);\n        }\n    } else {\n        validateFirebaseData(\"transaction failed: Data returned \", newVal, transaction.path);\n        // Mark as run and add to our queue.\n        transaction.status = 0 /* TransactionStatus.RUN */ ;\n        const queueNode = treeSubTree(repo.transactionQueueTree_, path);\n        const nodeQueue = treeGetValue(queueNode) || [];\n        nodeQueue.push(transaction);\n        treeSetValue(queueNode, nodeQueue);\n        // Update visibleData and raise events\n        // Note: We intentionally raise events after updating all of our\n        // transaction state, since the user could start new transactions from the\n        // event callbacks.\n        let priorityForNode;\n        if (typeof newVal === \"object\" && newVal !== null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newVal, \".priority\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(newVal, \".priority\");\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(isValidPriority(priorityForNode), \"Invalid priority returned by transaction. \" + \"Priority must be a valid string, finite number, server value, or null.\");\n        } else {\n            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;\n            priorityForNode = currentNode.getPriority().val();\n        }\n        const serverValues = repoGenerateServerValues(repo);\n        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n        transaction.currentOutputSnapshotResolved = newNode;\n        transaction.currentWriteId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n    }\n}\n/**\r\n * @param excludeSets - A specific set to exclude\r\n */ function repoGetLatestState(repo, path, excludeSets) {\n    return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;\n}\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */ function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {\n    // Before recursing, make sure any completed transactions are removed.\n    if (!node) {\n        repoPruneCompletedTransactionsBelowNode(repo, node);\n    }\n    if (treeGetValue(node)) {\n        const queue = repoBuildTransactionQueue(repo, node);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue.length > 0, \"Sending zero length transaction queue\");\n        const allRun = queue.every((transaction)=>transaction.status === 0 /* TransactionStatus.RUN */ );\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\n        if (allRun) {\n            repoSendTransactionQueue(repo, treeGetPath(node), queue);\n        }\n    } else if (treeHasChildren(node)) {\n        treeForEachChild(node, (childNode)=>{\n            repoSendReadyTransactions(repo, childNode);\n        });\n    }\n}\n/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */ function repoSendTransactionQueue(repo, path, queue) {\n    // Mark transactions as sent and increment retry count!\n    const setsToIgnore = queue.map((txn)=>{\n        return txn.currentWriteId;\n    });\n    const latestState = repoGetLatestState(repo, path, setsToIgnore);\n    let snapToSend = latestState;\n    const latestHash = latestState.hash();\n    for(let i = 0; i < queue.length; i++){\n        const txn = queue[i];\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(txn.status === 0 /* TransactionStatus.RUN */ , \"tryToSendTransactionQueue_: items in queue should all be run.\");\n        txn.status = 1 /* TransactionStatus.SENT */ ;\n        txn.retryCount++;\n        const relativePath = newRelativePath(path, txn.path);\n        // If we've gotten to this point, the output snapshot must be defined.\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */ , txn.currentOutputSnapshotRaw);\n    }\n    const dataToSend = snapToSend.val(true);\n    const pathToSend = path;\n    // Send the put.\n    repo.server_.put(pathToSend.toString(), dataToSend, (status)=>{\n        repoLog(repo, \"transaction put response\", {\n            path: pathToSend.toString(),\n            status\n        });\n        let events = [];\n        if (status === \"ok\") {\n            // Queue up the callbacks and fire them after cleaning up all of our\n            // transaction state, since the callback could trigger more\n            // transactions or sets.\n            const callbacks = [];\n            for(let i = 0; i < queue.length; i++){\n                queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));\n                if (queue[i].onComplete) {\n                    // We never unset the output snapshot, and given that this\n                    // transaction is complete, it should be set\n                    callbacks.push(()=>queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));\n                }\n                queue[i].unwatcher();\n            }\n            // Now remove the completed transactions.\n            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));\n            // There may be pending transactions that we can now send.\n            repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n            // Finally, trigger onComplete callbacks.\n            for(let i = 0; i < callbacks.length; i++){\n                exceptionGuard(callbacks[i]);\n            }\n        } else {\n            // transactions are no longer sent.  Update their status appropriately.\n            if (status === \"datastale\") {\n                for(let i = 0; i < queue.length; i++){\n                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) {\n                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    } else {\n                        queue[i].status = 0 /* TransactionStatus.RUN */ ;\n                    }\n                }\n            } else {\n                warn(\"transaction at \" + pathToSend.toString() + \" failed: \" + status);\n                for(let i = 0; i < queue.length; i++){\n                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    queue[i].abortReason = status;\n                }\n            }\n            repoRerunTransactions(repo, path);\n        }\n    }, latestHash);\n}\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */ function repoRerunTransactions(repo, changedPath) {\n    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);\n    const path = treeGetPath(rootMostTransactionNode);\n    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);\n    repoRerunTransactionQueue(repo, queue, path);\n    return path;\n}\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */ function repoRerunTransactionQueue(repo, queue, path) {\n    if (queue.length === 0) {\n        return; // Nothing to do!\n    }\n    // Queue up the callbacks and fire them after cleaning up all of our\n    // transaction state, since the callback could trigger more transactions or\n    // sets.\n    const callbacks = [];\n    let events = [];\n    // Ignore all of the sets we're going to re-run.\n    const txnsToRerun = queue.filter((q)=>{\n        return q.status === 0 /* TransactionStatus.RUN */ ;\n    });\n    const setsToIgnore = txnsToRerun.map((q)=>{\n        return q.currentWriteId;\n    });\n    for(let i = 0; i < queue.length; i++){\n        const transaction = queue[i];\n        const relativePath = newRelativePath(path, transaction.path);\n        let abortTransaction = false, abortReason;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(relativePath !== null, \"rerunTransactionsUnderNode_: relativePath should not be null.\");\n        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */ ) {\n            abortTransaction = true;\n            abortReason = transaction.abortReason;\n            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n        } else if (transaction.status === 0 /* TransactionStatus.RUN */ ) {\n            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {\n                abortTransaction = true;\n                abortReason = \"maxretry\";\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n            } else {\n                // This code reruns a transaction\n                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);\n                transaction.currentInputSnapshot = currentNode;\n                const newData = queue[i].update(currentNode.val());\n                if (newData !== undefined) {\n                    validateFirebaseData(\"transaction failed: Data returned \", newData, transaction.path);\n                    let newDataNode = nodeFromJSON(newData);\n                    const hasExplicitPriority = typeof newData === \"object\" && newData != null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newData, \".priority\");\n                    if (!hasExplicitPriority) {\n                        // Keep the old priority if there wasn't a priority explicitly specified.\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n                    }\n                    const oldWriteId = transaction.currentWriteId;\n                    const serverValues = repoGenerateServerValues(repo);\n                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\n                    transaction.currentOutputSnapshotRaw = newDataNode;\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\n                    transaction.currentWriteId = repoGetNextWriteId(repo);\n                    // Mutates setsToIgnore in place\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));\n                } else {\n                    abortTransaction = true;\n                    abortReason = \"nodata\";\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n                }\n            }\n        }\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        events = [];\n        if (abortTransaction) {\n            // Abort.\n            queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n            // Removing a listener can trigger pruning which can muck with\n            // mergedData/visibleData (as it prunes data). So defer the unwatcher\n            // until we're done.\n            (function(unwatcher) {\n                setTimeout(unwatcher, Math.floor(0));\n            })(queue[i].unwatcher);\n            if (queue[i].onComplete) {\n                if (abortReason === \"nodata\") {\n                    callbacks.push(()=>queue[i].onComplete(null, false, queue[i].currentInputSnapshot));\n                } else {\n                    callbacks.push(()=>queue[i].onComplete(new Error(abortReason), false, null));\n                }\n            }\n        }\n    }\n    // Clean up completed transactions.\n    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);\n    // Now fire callbacks, now that we're in a good, known state.\n    for(let i = 0; i < callbacks.length; i++){\n        exceptionGuard(callbacks[i]);\n    }\n    // Try to send the transaction result to the server.\n    repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n}\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */ function repoGetAncestorTransactionNode(repo, path) {\n    let front;\n    // Start at the root and walk deeper into the tree towards path until we\n    // find a node with pending transactions.\n    let transactionNode = repo.transactionQueueTree_;\n    front = pathGetFront(path);\n    while(front !== null && treeGetValue(transactionNode) === undefined){\n        transactionNode = treeSubTree(transactionNode, front);\n        path = pathPopFront(path);\n        front = pathGetFront(path);\n    }\n    return transactionNode;\n}\n/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */ function repoBuildTransactionQueue(repo, transactionNode) {\n    // Walk any child transaction queues and aggregate them into a single queue.\n    const transactionQueue = [];\n    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);\n    // Sort them by the order the transactions were created.\n    transactionQueue.sort((a, b)=>a.order - b.order);\n    return transactionQueue;\n}\nfunction repoAggregateTransactionQueuesForNode(repo, node, queue) {\n    const nodeQueue = treeGetValue(node);\n    if (nodeQueue) {\n        for(let i = 0; i < nodeQueue.length; i++){\n            queue.push(nodeQueue[i]);\n        }\n    }\n    treeForEachChild(node, (child)=>{\n        repoAggregateTransactionQueuesForNode(repo, child, queue);\n    });\n}\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */ function repoPruneCompletedTransactionsBelowNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        let to = 0;\n        for(let from = 0; from < queue.length; from++){\n            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */ ) {\n                queue[to] = queue[from];\n                to++;\n            }\n        }\n        queue.length = to;\n        treeSetValue(node, queue.length > 0 ? queue : undefined);\n    }\n    treeForEachChild(node, (childNode)=>{\n        repoPruneCompletedTransactionsBelowNode(repo, childNode);\n    });\n}\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */ function repoAbortTransactions(repo, path) {\n    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));\n    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);\n    treeForEachAncestor(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    repoAbortTransactionsOnNode(repo, transactionNode);\n    treeForEachDescendant(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    return affectedPath;\n}\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */ function repoAbortTransactionsOnNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        // Queue up the callbacks and fire them after cleaning up all of our\n        // transaction state, since the callback could trigger more transactions\n        // or sets.\n        const callbacks = [];\n        // Go through queue.  Any already-sent transactions must be marked for\n        // abort, while the unsent ones can be immediately aborted and removed.\n        let events = [];\n        let lastSent = -1;\n        for(let i = 0; i < queue.length; i++){\n            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) ;\n            else if (queue[i].status === 1 /* TransactionStatus.SENT */ ) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(lastSent === i - 1, \"All SENT items should be at beginning of queue.\");\n                lastSent = i;\n                // Mark transaction for abort when it comes back.\n                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ;\n                queue[i].abortReason = \"set\";\n            } else {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue[i].status === 0 /* TransactionStatus.RUN */ , \"Unexpected transaction status in abort\");\n                // We can abort it immediately.\n                queue[i].unwatcher();\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));\n                if (queue[i].onComplete) {\n                    callbacks.push(queue[i].onComplete.bind(null, new Error(\"set\"), false, null));\n                }\n            }\n        }\n        if (lastSent === -1) {\n            // We're not waiting for any sent transactions.  We can clear the queue.\n            treeSetValue(node, undefined);\n        } else {\n            // Remove the transactions we aborted.\n            queue.length = lastSent + 1;\n        }\n        // Now fire the callbacks.\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);\n        for(let i = 0; i < callbacks.length; i++){\n            exceptionGuard(callbacks[i]);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function decodePath(pathString) {\n    let pathStringDecoded = \"\";\n    const pieces = pathString.split(\"/\");\n    for(let i = 0; i < pieces.length; i++){\n        if (pieces[i].length > 0) {\n            let piece = pieces[i];\n            try {\n                piece = decodeURIComponent(piece.replace(/\\+/g, \" \"));\n            } catch (e) {}\n            pathStringDecoded += \"/\" + piece;\n        }\n    }\n    return pathStringDecoded;\n}\n/**\r\n * @returns key value hash\r\n */ function decodeQuery(queryString) {\n    const results = {};\n    if (queryString.charAt(0) === \"?\") {\n        queryString = queryString.substring(1);\n    }\n    for (const segment of queryString.split(\"&\")){\n        if (segment.length === 0) {\n            continue;\n        }\n        const kv = segment.split(\"=\");\n        if (kv.length === 2) {\n            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n        } else {\n            warn(`Invalid query segment '${segment}' in query '${queryString}'`);\n        }\n    }\n    return results;\n}\nconst parseRepoInfo = function(dataURL, nodeAdmin) {\n    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\n    if (parsedUrl.domain === \"firebase.com\") {\n        fatal(parsedUrl.host + \" is no longer supported. \" + \"Please use <YOUR FIREBASE>.firebaseio.com instead\");\n    }\n    // Catch common error of uninitialized namespace value.\n    if ((!namespace || namespace === \"undefined\") && parsedUrl.domain !== \"localhost\") {\n        fatal(\"Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com\");\n    }\n    if (!parsedUrl.secure) {\n        warnIfPageIsSecure();\n    }\n    const webSocketOnly = parsedUrl.scheme === \"ws\" || parsedUrl.scheme === \"wss\";\n    return {\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, /*persistenceKey=*/ \"\", /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\n        path: new Path(parsedUrl.pathString)\n    };\n};\nconst parseDatabaseURL = function(dataURL) {\n    // Default to empty strings in the event of a malformed string.\n    let host = \"\", domain = \"\", subdomain = \"\", pathString = \"\", namespace = \"\";\n    // Always default to SSL, unless otherwise specified.\n    let secure = true, scheme = \"https\", port = 443;\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\n    if (typeof dataURL === \"string\") {\n        // Parse scheme.\n        let colonInd = dataURL.indexOf(\"//\");\n        if (colonInd >= 0) {\n            scheme = dataURL.substring(0, colonInd - 1);\n            dataURL = dataURL.substring(colonInd + 2);\n        }\n        // Parse host, path, and query string.\n        let slashInd = dataURL.indexOf(\"/\");\n        if (slashInd === -1) {\n            slashInd = dataURL.length;\n        }\n        let questionMarkInd = dataURL.indexOf(\"?\");\n        if (questionMarkInd === -1) {\n            questionMarkInd = dataURL.length;\n        }\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n        if (slashInd < questionMarkInd) {\n            // For pathString, questionMarkInd will always come after slashInd\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n        }\n        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\n        // If we have a port, use scheme for determining if it's secure.\n        colonInd = host.indexOf(\":\");\n        if (colonInd >= 0) {\n            secure = scheme === \"https\" || scheme === \"wss\";\n            port = parseInt(host.substring(colonInd + 1), 10);\n        } else {\n            colonInd = host.length;\n        }\n        const hostWithoutPort = host.slice(0, colonInd);\n        if (hostWithoutPort.toLowerCase() === \"localhost\") {\n            domain = \"localhost\";\n        } else if (hostWithoutPort.split(\".\").length <= 2) {\n            domain = hostWithoutPort;\n        } else {\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\n            const dotInd = host.indexOf(\".\");\n            subdomain = host.substring(0, dotInd).toLowerCase();\n            domain = host.substring(dotInd + 1);\n            // Normalize namespaces to lowercase to share storage / connection.\n            namespace = subdomain;\n        }\n        // Always treat the value of the `ns` as the namespace name if it is present.\n        if (\"ns\" in queryParams) {\n            namespace = queryParams[\"ns\"];\n        }\n    }\n    return {\n        host,\n        port,\n        domain,\n        subdomain,\n        secure,\n        scheme,\n        pathString,\n        namespace\n    };\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Modeled after base64 web-safe chars, but ordered by ASCII.\nconst PUSH_CHARS = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */ const nextPushId = function() {\n    // Timestamp of last push, used to prevent local collisions if you push twice\n    // in one ms.\n    let lastPushTime = 0;\n    // We generate 72-bits of randomness which get turned into 12 characters and\n    // appended to the timestamp to prevent collisions with other clients. We\n    // store the last characters we generated because in the event of a collision,\n    // we'll use those same characters except \"incremented\" by one.\n    const lastRandChars = [];\n    return function(now) {\n        const duplicateTime = now === lastPushTime;\n        lastPushTime = now;\n        let i;\n        const timeStampChars = new Array(8);\n        for(i = 7; i >= 0; i--){\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n            // NOTE: Can't use << here because javascript will convert to int and lose\n            // the upper bits.\n            now = Math.floor(now / 64);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(now === 0, \"Cannot push at time == 0\");\n        let id = timeStampChars.join(\"\");\n        if (!duplicateTime) {\n            for(i = 0; i < 12; i++){\n                lastRandChars[i] = Math.floor(Math.random() * 64);\n            }\n        } else {\n            // If the timestamp hasn't changed since last push, use the same random\n            // number, except incremented by 1.\n            for(i = 11; i >= 0 && lastRandChars[i] === 63; i--){\n                lastRandChars[i] = 0;\n            }\n            lastRandChars[i]++;\n        }\n        for(i = 0; i < 12; i++){\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(id.length === 20, \"nextPushId: Length should be 20.\");\n        return id;\n    };\n}();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Encapsulates the data needed to raise an event\r\n */ class DataEvent {\n    /**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */ constructor(eventType, eventRegistration, snapshot, prevName){\n        this.eventType = eventType;\n        this.eventRegistration = eventRegistration;\n        this.snapshot = snapshot;\n        this.prevName = prevName;\n    }\n    getPath() {\n        const ref = this.snapshot.ref;\n        if (this.eventType === \"value\") {\n            return ref._path;\n        } else {\n            return ref.parent._path;\n        }\n    }\n    getEventType() {\n        return this.eventType;\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.getPath().toString() + \":\" + this.eventType + \":\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(this.snapshot.exportVal());\n    }\n}\nclass CancelEvent {\n    constructor(eventRegistration, error, path){\n        this.eventRegistration = eventRegistration;\n        this.error = error;\n        this.path = path;\n    }\n    getPath() {\n        return this.path;\n    }\n    getEventType() {\n        return \"cancel\";\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.path.toString() + \":cancel\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */ class CallbackContext {\n    constructor(snapshotCallback, cancelCallback){\n        this.snapshotCallback = snapshotCallback;\n        this.cancelCallback = cancelCallback;\n    }\n    onValue(expDataSnapshot, previousChildName) {\n        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);\n    }\n    onCancel(error) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.hasCancelCallback, \"Raising a cancel event on a listener with no cancel callback\");\n        return this.cancelCallback.call(null, error);\n    }\n    get hasCancelCallback() {\n        return !!this.cancelCallback;\n    }\n    matches(other) {\n        return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== undefined && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */ class OnDisconnect {\n    /** @hideconstructor */ constructor(_repo, _path){\n        this._repo = _repo;\n        this._path = _path;\n    }\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ cancel() {\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ remove() {\n        validateWritablePath(\"OnDisconnect.remove\", this._path);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ set(value) {\n        validateWritablePath(\"OnDisconnect.set\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.set\", value, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ setWithPriority(value, priority) {\n        validateWritablePath(\"OnDisconnect.setWithPriority\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.setWithPriority\", value, this._path, false);\n        validatePriority(\"OnDisconnect.setWithPriority\", priority, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ update(values) {\n        validateWritablePath(\"OnDisconnect.update\", this._path);\n        validateFirebaseMergeDataArg(\"OnDisconnect.update\", values, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ class QueryImpl {\n    /**\r\n     * @hideconstructor\r\n     */ constructor(_repo, _path, _queryParams, _orderByCalled){\n        this._repo = _repo;\n        this._path = _path;\n        this._queryParams = _queryParams;\n        this._orderByCalled = _orderByCalled;\n    }\n    get key() {\n        if (pathIsEmpty(this._path)) {\n            return null;\n        } else {\n            return pathGetBack(this._path);\n        }\n    }\n    get ref() {\n        return new ReferenceImpl(this._repo, this._path);\n    }\n    get _queryIdentifier() {\n        const obj = queryParamsGetQueryObject(this._queryParams);\n        const id = ObjectToUniqueKey(obj);\n        return id === \"{}\" ? \"default\" : id;\n    }\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     */ get _queryObject() {\n        return queryParamsGetQueryObject(this._queryParams);\n    }\n    isEqual(other) {\n        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(other);\n        if (!(other instanceof QueryImpl)) {\n            return false;\n        }\n        const sameRepo = this._repo === other._repo;\n        const samePath = pathEquals(this._path, other._path);\n        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;\n        return sameRepo && samePath && sameQueryIdentifier;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toString() {\n        return this._repo.toString() + pathToUrlEncodedString(this._path);\n    }\n}\n/**\r\n * Validates that no other order by call has been made\r\n */ function validateNoPreviousOrderByCall(query, fnName) {\n    if (query._orderByCalled === true) {\n        throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n}\n/**\r\n * Validates start/end values for queries.\r\n */ function validateQueryEndpoints(params) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n        startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n        endNode = params.getIndexEndValue();\n    }\n    if (params.getIndex() === KEY_INDEX) {\n        const tooManyArgsError = \"Query: When ordering by key, you may only pass one argument to \" + \"startAt(), endAt(), or equalTo().\";\n        const wrongArgTypeError = \"Query: When ordering by key, the argument passed to startAt(), startAfter(), \" + \"endAt(), endBefore(), or equalTo() must be a string.\";\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            if (startName !== MIN_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof startNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            if (endName !== MAX_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof endNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {\n            throw new Error(\"Query: When ordering by priority, the first argument passed to startAt(), \" + \"startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value \" + \"(null, a number, or a string).\");\n        }\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, \"unknown index type.\");\n        if (startNode != null && typeof startNode === \"object\" || endNode != null && typeof endNode === \"object\") {\n            throw new Error(\"Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or \" + \"equalTo() cannot be an object.\");\n        }\n    }\n}\n/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */ function validateLimit(params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n        throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \" + \"limitToFirst() or limitToLast() instead.\");\n    }\n}\n/**\r\n * @internal\r\n */ class ReferenceImpl extends QueryImpl {\n    /** @hideconstructor */ constructor(repo, path){\n        super(repo, path, new QueryParams(), false);\n    }\n    get parent() {\n        const parentPath = pathParent(this._path);\n        return parentPath === null ? null : new ReferenceImpl(this._repo, parentPath);\n    }\n    get root() {\n        let ref = this;\n        while(ref.parent !== null){\n            ref = ref.parent;\n        }\n        return ref;\n    }\n}\n/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */ class DataSnapshot {\n    /**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */ constructor(_node, /**\r\n     * The location of this DataSnapshot.\r\n     */ ref, _index){\n        this._node = _node;\n        this.ref = ref;\n        this._index = _index;\n    }\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */ get priority() {\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n        return this._node.getPriority().val();\n    }\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */ get key() {\n        return this.ref.key;\n    }\n    /** Returns the number of child properties of this `DataSnapshot`. */ get size() {\n        return this._node.numChildren();\n    }\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */ child(path) {\n        const childPath = new Path(path);\n        const childRef = child(this.ref, path);\n        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);\n    }\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */ exists() {\n        return !this._node.isEmpty();\n    }\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    exportVal() {\n        return this._node.val(true);\n    }\n    /**\r\n     * Enumerates the top-level children in the `DataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */ forEach(action) {\n        if (this._node.isLeafNode()) {\n            return false;\n        }\n        const childrenNode = this._node;\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n        return !!childrenNode.forEachChild(this._index, (key, node)=>{\n            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));\n        });\n    }\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */ hasChild(path) {\n        const childPath = new Path(path);\n        return !this._node.getChild(childPath).isEmpty();\n    }\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */ hasChildren() {\n        if (this._node.isLeafNode()) {\n            return false;\n        } else {\n            return !this._node.isEmpty();\n        }\n    }\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */ toJSON() {\n        return this.exportVal();\n    }\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    val() {\n        return this._node.val();\n    }\n}\n/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */ function ref(db, path) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"ref\");\n    return path !== undefined ? child(db._root, path) : db._root;\n}\n/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */ function refFromURL(db, url) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"refFromURL\");\n    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);\n    validateUrl(\"refFromURL\", parsedURL);\n    const repoInfo = parsedURL.repoInfo;\n    if (!db._repo.repoInfo_.isCustomHost() && repoInfo.host !== db._repo.repoInfo_.host) {\n        fatal(\"refFromURL\" + \": Host name does not match the current database: \" + \"(found \" + repoInfo.host + \" but expected \" + db._repo.repoInfo_.host + \")\");\n    }\n    return ref(db, parsedURL.path.toString());\n}\n/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */ function child(parent, path) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    if (pathGetFront(parent._path) === null) {\n        validateRootPathString(\"child\", \"path\", path, false);\n    } else {\n        validatePathString(\"child\", \"path\", path, false);\n    }\n    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));\n}\n/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */ function onDisconnect(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return new OnDisconnect(ref._repo, ref._path);\n}\n/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.\r\n * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */ function push(parent, value) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    validateWritablePath(\"push\", parent._path);\n    validateFirebaseDataArg(\"push\", value, parent._path, true);\n    const now = repoServerTime(parent._repo);\n    const name = nextPushId(now);\n    // push() returns a ThennableReference whose promise is fulfilled with a\n    // regular Reference. We use child() to create handles to two different\n    // references. The first is turned into a ThennableReference below by adding\n    // then() and catch() methods and is used as the return value of push(). The\n    // second remains a regular Reference and is used as the fulfilled value of\n    // the first ThennableReference.\n    const thennablePushRef = child(parent, name);\n    const pushRef = child(parent, name);\n    let promise;\n    if (value != null) {\n        promise = set(pushRef, value).then(()=>pushRef);\n    } else {\n        promise = Promise.resolve(pushRef);\n    }\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n    return thennablePushRef;\n}\n/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */ function remove(ref) {\n    validateWritablePath(\"remove\", ref._path);\n    return set(ref, null);\n}\n/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function set(ref, value) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"set\", ref._path);\n    validateFirebaseDataArg(\"set\", value, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, /*priority=*/ null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setPriority(ref, priority) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"setPriority\", ref._path);\n    validatePriority(\"setPriority\", priority, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, pathChild(ref._path, \".priority\"), priority, null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setWithPriority(ref, value, priority) {\n    validateWritablePath(\"setWithPriority\", ref._path);\n    validateFirebaseDataArg(\"setWithPriority\", value, ref._path, false);\n    validatePriority(\"setWithPriority\", priority, false);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"setWithPriority failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */ function update(ref, values) {\n    validateFirebaseMergeDataArg(\"update\", values, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */ function get(query) {\n    query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query);\n    const callbackContext = new CallbackContext(()=>{});\n    const container = new ValueEventRegistration(callbackContext);\n    return repoGetValue(query._repo, query, container).then((node)=>{\n        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());\n    });\n}\n/**\r\n * Represents registration for 'value' events.\r\n */ class ValueEventRegistration {\n    constructor(callbackContext){\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        return eventType === \"value\";\n    }\n    createEvent(change, query) {\n        const index = query._queryParams.getIndex();\n        return new DataEvent(\"value\", this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, null);\n        }\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    matches(other) {\n        if (!(other instanceof ValueEventRegistration)) {\n            return false;\n        } else if (!other.callbackContext || !this.callbackContext) {\n            // If no callback specified, we consider it to match any callback.\n            return true;\n        } else {\n            return other.callbackContext.matches(this.callbackContext);\n        }\n    }\n    hasAnyCallback() {\n        return this.callbackContext !== null;\n    }\n}\n/**\r\n * Represents the registration of a child_x event.\r\n */ class ChildEventRegistration {\n    constructor(eventType, callbackContext){\n        this.eventType = eventType;\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        let eventToCheck = eventType === \"children_added\" ? \"child_added\" : eventType;\n        eventToCheck = eventToCheck === \"children_removed\" ? \"child_removed\" : eventToCheck;\n        return this.eventType === eventToCheck;\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    createEvent(change, query) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(change.childName != null, \"Child events should have a childName.\");\n        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);\n        const index = query._queryParams.getIndex();\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, eventData.prevName);\n        }\n    }\n    matches(other) {\n        if (other instanceof ChildEventRegistration) {\n            return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));\n        }\n        return false;\n    }\n    hasAnyCallback() {\n        return !!this.callbackContext;\n    }\n}\nfunction addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {\n    let cancelCallback;\n    if (typeof cancelCallbackOrListenOptions === \"object\") {\n        cancelCallback = undefined;\n        options = cancelCallbackOrListenOptions;\n    }\n    if (typeof cancelCallbackOrListenOptions === \"function\") {\n        cancelCallback = cancelCallbackOrListenOptions;\n    }\n    if (options && options.onlyOnce) {\n        const userCallback = callback;\n        const onceCallback = (dataSnapshot, previousChildName)=>{\n            repoRemoveEventCallbackForQuery(query._repo, query, container);\n            userCallback(dataSnapshot, previousChildName);\n        };\n        onceCallback.userCallback = callback.userCallback;\n        onceCallback.context = callback.context;\n        callback = onceCallback;\n    }\n    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);\n    const container = eventType === \"value\" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);\n    repoAddEventCallbackForQuery(query._repo, query, container);\n    return ()=>repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\nfunction onValue(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"value\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_added\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_changed\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_moved\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_removed\", callback, cancelCallbackOrListenOptions, options);\n}\n/**\r\n * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.\r\n * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from\r\n * the respective `on*` callbacks.\r\n *\r\n * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */ function off(query, eventType, callback) {\n    let container = null;\n    const expCallback = callback ? new CallbackContext(callback) : null;\n    if (eventType === \"value\") {\n        container = new ValueEventRegistration(expCallback);\n    } else if (eventType) {\n        container = new ChildEventRegistration(eventType, expCallback);\n    }\n    repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */ class QueryConstraint {\n}\nclass QueryEndAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endAt\", this._value, query._path, true);\n        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endAt: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */ function endAt(value, key) {\n    validateKey(\"endAt\", \"key\", key, true);\n    return new QueryEndAtConstraint(value, key);\n}\nclass QueryEndBeforeConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endBefore\", this._value, query._path, false);\n        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endBefore: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value less than or equal\r\n * to the specified value and a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function endBefore(value, key) {\n    validateKey(\"endBefore\", \"key\", key, true);\n    return new QueryEndBeforeConstraint(value, key);\n}\nclass QueryStartAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAt\", this._value, query._path, true);\n        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAt: Starting point was already set (by another call to startAt, \" + \"startBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAt(value = null, key) {\n    validateKey(\"startAt\", \"key\", key, true);\n    return new QueryStartAtConstraint(value, key);\n}\nclass QueryStartAfterConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAfter\", this._value, query._path, false);\n        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAfter: Starting point was already set (by another call to startAt, \" + \"startAfter, or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAfter(value, key) {\n    validateKey(\"startAfter\", \"key\", key, true);\n    return new QueryStartAfterConstraint(value, key);\n}\nclass QueryLimitToFirstConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToFirst: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToFirst(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToFirst: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToFirstConstraint(limit);\n}\nclass QueryLimitToLastConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToLast: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToLast(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToLast: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToLastConstraint(limit);\n}\nclass QueryOrderByChildConstraint extends QueryConstraint {\n    constructor(_path){\n        super();\n        this._path = _path;\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByChild\");\n        const parsedPath = new Path(this._path);\n        if (pathIsEmpty(parsedPath)) {\n            throw new Error(\"orderByChild: cannot pass in empty path. Use orderByValue() instead.\");\n        }\n        const index = new PathIndex(parsedPath);\n        const newParams = queryParamsOrderBy(query._queryParams, index);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */ function orderByChild(path) {\n    if (path === \"$key\") {\n        throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');\n    } else if (path === \"$priority\") {\n        throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');\n    } else if (path === \"$value\") {\n        throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');\n    }\n    validatePathString(\"orderByChild\", \"path\", path, false);\n    return new QueryOrderByChildConstraint(path);\n}\nclass QueryOrderByKeyConstraint extends QueryConstraint {\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByKey\");\n        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByKey() {\n    return new QueryOrderByKeyConstraint();\n}\nclass QueryOrderByPriorityConstraint extends QueryConstraint {\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByPriority\");\n        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */ function orderByPriority() {\n    return new QueryOrderByPriorityConstraint();\n}\nclass QueryOrderByValueConstraint extends QueryConstraint {\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByValue\");\n        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByValue() {\n    return new QueryOrderByValueConstraint();\n}\nclass QueryEqualToValueConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"equalTo\", this._value, query._path, false);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"equalTo: Starting point was already set (by another call to startAt/startAfter or \" + \"equalTo).\");\n        }\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"equalTo: Ending point was already set (by another call to endAt/endBefore or \" + \"equalTo).\");\n        }\n        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));\n    }\n}\n/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function equalTo(value, key) {\n    validateKey(\"equalTo\", \"key\", key, true);\n    return new QueryEqualToValueConstraint(value, key);\n}\n/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */ function query(query1, ...queryConstraints) {\n    let queryImpl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query1);\n    for (const constraint of queryConstraints){\n        queryImpl = constraint._apply(queryImpl);\n    }\n    return queryImpl;\n}\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */ syncPointSetReferenceConstructor(ReferenceImpl);\nsyncTreeSetReferenceConstructor(ReferenceImpl);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */ const FIREBASE_DATABASE_EMULATOR_HOST_VAR = \"FIREBASE_DATABASE_EMULATOR_HOST\";\n/**\r\n * Creates and caches `Repo` instances.\r\n */ const repos = {};\n/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */ let useRestClient = false;\n/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */ function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {\n    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, /*isUsingEmulator=*/ true);\n    if (tokenProvider) {\n        repo.authTokenProvider_ = tokenProvider;\n    }\n}\n/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */ function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {\n    let dbUrl = url || app.options.databaseURL;\n    if (dbUrl === undefined) {\n        if (!app.options.projectId) {\n            fatal(\"Can't determine Firebase Database URL. Be sure to include \" + \" a Project ID when calling firebase.initializeApp().\");\n        }\n        log(\"Using default host for project \", app.options.projectId);\n        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;\n    }\n    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n    let repoInfo = parsedUrl.repoInfo;\n    let isEmulator;\n    let dbEmulatorHost = undefined;\n    if (typeof process !== \"undefined\" && process.env) {\n        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\n    }\n    if (dbEmulatorHost) {\n        isEmulator = true;\n        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\n        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n        repoInfo = parsedUrl.repoInfo;\n    } else {\n        isEmulator = !parsedUrl.repoInfo.secure;\n    }\n    const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);\n    validateUrl(\"Invalid Firebase Database URL\", parsedUrl);\n    if (!pathIsEmpty(parsedUrl.path)) {\n        fatal(\"Database URL must point to the root of a Firebase Database \" + \"(not including a child path).\");\n    }\n    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));\n    return new Database(repo, app);\n}\n/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */ function repoManagerDeleteRepo(repo, appName) {\n    const appRepos = repos[appName];\n    // This should never happen...\n    if (!appRepos || appRepos[repo.key] !== repo) {\n        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);\n    }\n    repoInterrupt(repo);\n    delete appRepos[repo.key];\n}\n/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */ function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {\n    let appRepos = repos[app.name];\n    if (!appRepos) {\n        appRepos = {};\n        repos[app.name] = appRepos;\n    }\n    let repo = appRepos[repoInfo.toURLString()];\n    if (repo) {\n        fatal(\"Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.\");\n    }\n    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);\n    appRepos[repoInfo.toURLString()] = repo;\n    return repo;\n}\n/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */ function repoManagerForceRestClient(forceRestClient) {\n    useRestClient = forceRestClient;\n}\n/**\r\n * Class representing a Firebase Realtime Database.\r\n */ class Database {\n    /** @hideconstructor */ constructor(_repoInternal, /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */ app){\n        this._repoInternal = _repoInternal;\n        this.app = app;\n        /** Represents a `Database` instance. */ this[\"type\"] = \"database\";\n        /** Track if the instance has been used (root or repo accessed) */ this._instanceStarted = false;\n    }\n    get _repo() {\n        if (!this._instanceStarted) {\n            repoStart(this._repoInternal, this.app.options.appId, this.app.options[\"databaseAuthVariableOverride\"]);\n            this._instanceStarted = true;\n        }\n        return this._repoInternal;\n    }\n    get _root() {\n        if (!this._rootInternal) {\n            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());\n        }\n        return this._rootInternal;\n    }\n    _delete() {\n        if (this._rootInternal !== null) {\n            repoManagerDeleteRepo(this._repo, this.app.name);\n            this._repoInternal = null;\n            this._rootInternal = null;\n        }\n        return Promise.resolve();\n    }\n    _checkNotDeleted(apiName) {\n        if (this._rootInternal === null) {\n            fatal(\"Cannot call \" + apiName + \" on a deleted database.\");\n        }\n    }\n}\nfunction checkTransportInit() {\n    if (TransportManager.IS_TRANSPORT_INITIALIZED) {\n        warn(\"Transport has already been initialized. Please call this function before calling ref or setting up a listener\");\n    }\n}\n/**\r\n * Force the use of websockets instead of longPolling.\r\n */ function forceWebSockets() {\n    checkTransportInit();\n    BrowserPollConnection.forceDisallow();\n}\n/**\r\n * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.\r\n */ function forceLongPolling() {\n    checkTransportInit();\n    WebSocketConnection.forceDisallow();\n    BrowserPollConnection.forceAllow();\n}\n/**\r\n * Returns the instance of the Realtime Database SDK that is associated\r\n * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with\r\n * with default settings if no instance exists or if the existing instance uses\r\n * a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */ function getDatabase(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.getApp)(), url) {\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._getProvider)(app, \"database\").getImmediate({\n        identifier: url\n    });\n    if (!db._instanceStarted) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)(\"database\");\n        if (emulator) {\n            connectDatabaseEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */ function connectDatabaseEmulator(db, host, port, options = {}) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"useEmulator\");\n    if (db._instanceStarted) {\n        fatal(\"Cannot call useEmulator() after instance has already been initialized.\");\n    }\n    const repo = db._repoInternal;\n    let tokenProvider = undefined;\n    if (repo.repoInfo_.nodeAdmin) {\n        if (options.mockUserToken) {\n            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');\n        }\n        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);\n    } else if (options.mockUserToken) {\n        const token = typeof options.mockUserToken === \"string\" ? options.mockUserToken : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(options.mockUserToken, db.app.options.projectId);\n        tokenProvider = new EmulatorTokenProvider(token);\n    }\n    // Modify the repo to apply emulator settings\n    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);\n}\n/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */ function goOffline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOffline\");\n    repoInterrupt(db._repo);\n}\n/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */ function goOnline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOnline\");\n    repoResume(db._repo);\n}\nfunction enableLogging(logger, persistent) {\n    enableLogging$1(logger, persistent);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerDatabase(variant) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_3__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"database\", (container, { instanceIdentifier: url })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const authProvider = container.getProvider(\"auth-internal\");\n        const appCheckProvider = container.getProvider(\"app-check-internal\");\n        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ ).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const SERVER_TIMESTAMP = {\n    \".sv\": \"timestamp\"\n};\n/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */ function serverTimestamp() {\n    return SERVER_TIMESTAMP;\n}\n/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */ function increment(delta) {\n    return {\n        \".sv\": {\n            \"increment\": delta\n        }\n    };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */ class TransactionResult {\n    /** @hideconstructor */ constructor(/** Whether the transaction was successfully committed. */ committed, /** The resulting data snapshot. */ snapshot){\n        this.committed = committed;\n        this.snapshot = snapshot;\n    }\n    /** Returns a JSON-serializable representation of this object. */ toJSON() {\n        return {\n            committed: this.committed,\n            snapshot: this.snapshot.toJSON()\n        };\n    }\n}\n/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */ function runTransaction(ref, // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransactionUpdate, options) {\n    var _a;\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"Reference.transaction\", ref._path);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"Reference.transaction failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    const promiseComplete = (error, committed, node)=>{\n        let dataSnapshot = null;\n        if (error) {\n            deferred.reject(error);\n        } else {\n            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);\n            deferred.resolve(new TransactionResult(committed, dataSnapshot));\n        }\n    };\n    // Add a watch to make sure we get server updates.\n    const unwatcher = onValue(ref, ()=>{});\n    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);\n    return deferred.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ PersistentConnection;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.simpleListen = function(pathString, onComplete) {\n    this.sendRequest(\"q\", {\n        p: pathString\n    }, onComplete);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.echo = function(data, onEcho) {\n    this.sendRequest(\"echo\", {\n        d: data\n    }, onEcho);\n};\n// RealTimeConnection properties that we use in tests.\nConnection;\n/**\r\n * @internal\r\n */ const hijackHash = function(newHash) {\n    const oldPut = PersistentConnection.prototype.put;\n    PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {\n        if (hash !== undefined) {\n            hash = newHash();\n        }\n        oldPut.call(this, pathString, data, onComplete, hash);\n    };\n    return function() {\n        PersistentConnection.prototype.put = oldPut;\n    };\n};\nRepoInfo;\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */ const forceRestClient = function(forceRestClient) {\n    repoManagerForceRestClient(forceRestClient);\n};\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ setWebSocketImpl(faye_websocket__WEBPACK_IMPORTED_MODULE_0__.Client);\nregisterDatabase(\"node\");\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNpVTtBQUNwVDtBQUNvRTtBQUN4RTtBQUVoRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNbUMsbUJBQW1CO0FBQ3pCLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQywwQkFBMEI7QUFDaEMsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLFlBQVk7QUFDbEIsOEVBQThFO0FBQzlFLDJCQUEyQjtBQUMzQixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxlQUFlO0FBRXJCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUM7SUFDRjs7S0FFQyxHQUNEQyxZQUFZQyxXQUFXLENBQUU7UUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLHNFQUFzRTtRQUN0RSxJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNuQjtJQUNBOzs7S0FHQyxHQUNEQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUNaLElBQUlBLFNBQVMsTUFBTTtZQUNmLElBQUksQ0FBQ0osV0FBVyxDQUFDSyxVQUFVLENBQUMsSUFBSSxDQUFDQyxhQUFhLENBQUNIO1FBQ25ELE9BQ0s7WUFDRCxJQUFJLENBQUNILFdBQVcsQ0FBQ08sT0FBTyxDQUFDLElBQUksQ0FBQ0QsYUFBYSxDQUFDSCxNQUFNbEQseURBQVNBLENBQUNtRDtRQUNoRTtJQUNKO0lBQ0E7O0tBRUMsR0FDREksSUFBSUwsR0FBRyxFQUFFO1FBQ0wsTUFBTU0sWUFBWSxJQUFJLENBQUNULFdB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QUN4RCxJQUFJLENBQUM5MEMsV0FBVyxDQUFDLFFBQVE7UUFBRWhGLEdBQUdwVTtJQUFLLEdBQUdrdUQ7QUFDMUM7QUFDQSxzREFBc0Q7QUFDdEQ3MkM7QUFDQTs7Q0FFQyxHQUNELE1BQU04MkMsYUFBYSxTQUFVQyxPQUFPO0lBQ2hDLE1BQU1DLFNBQVM3c0MscUJBQXFCdXNDLFNBQVMsQ0FBQ3p5QyxHQUFHO0lBQ2pEa0cscUJBQXFCdXNDLFNBQVMsQ0FBQ3p5QyxHQUFHLEdBQUcsU0FBVUMsVUFBVSxFQUFFdmIsSUFBSSxFQUFFd2IsVUFBVSxFQUFFQyxJQUFJO1FBQzdFLElBQUlBLFNBQVNtTCxXQUFXO1lBQ3BCbkwsT0FBTzJ5QztRQUNYO1FBQ0FDLE9BQU8xSSxJQUFJLENBQUMsSUFBSSxFQUFFcHFDLFlBQVl2YixNQUFNd2IsWUFBWUM7SUFDcEQ7SUFDQSxPQUFPO1FBQ0grRixxQkFBcUJ1c0MsU0FBUyxDQUFDenlDLEdBQUcsR0FBRyt5QztJQUN6QztBQUNKO0FBQ0E1b0Q7QUFDQTs7O0NBR0MsR0FDRCxNQUFNeW1ELGtCQUFrQixTQUFVQSxlQUFlO0lBQzdDRCwyQkFBMkJDO0FBQy9CO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Rqa0QsaUJBQWlCaFAsa0RBQWdCO0FBQ2pDazBELGlCQUFpQjtBQUUwM0IsQ0FDMzRCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbXllZW1hbi5jb20vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/MTc4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2Vic29ja2V0IGZyb20gJ2ZheWUtd2Vic29ja2V0JztcbmltcG9ydCB7IHN0cmluZ2lmeSwganNvbkV2YWwsIGNvbnRhaW5zLCBhc3NlcnQsIGlzTm9kZVNkaywgc3RyaW5nVG9CeXRlQXJyYXksIFNoYTEsIGJhc2U2NCwgZGVlcENvcHksIGJhc2U2NEVuY29kZSwgaXNNb2JpbGVDb3Jkb3ZhLCBzdHJpbmdMZW5ndGgsIERlZmVycmVkLCBzYWZlR2V0LCBpc0FkbWluLCBpc1ZhbGlkRm9ybWF0LCBpc0VtcHR5LCBpc1JlYWN0TmF0aXZlLCBhc3NlcnRpb25FcnJvciwgbWFwLCBxdWVyeXN0cmluZywgZXJyb3JQcmVmaXgsIGdldE1vZHVsYXJJbnN0YW5jZSwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBjcmVhdGVNb2NrVXNlclRva2VuIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIFNES19WRVJTSU9OIGFzIFNES19WRVJTSU9OJDEsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUFJPVE9DT0xfVkVSU0lPTiA9ICc1JztcclxuY29uc3QgVkVSU0lPTl9QQVJBTSA9ICd2JztcclxuY29uc3QgVFJBTlNQT1JUX1NFU1NJT05fUEFSQU0gPSAncyc7XHJcbmNvbnN0IFJFRkVSRVJfUEFSQU0gPSAncic7XHJcbmNvbnN0IEZPUkdFX1JFRiA9ICdmJztcclxuLy8gTWF0Y2hlcyBjb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20sIGZpcmViYXNlLWNvbnNvbGUtKi5jb3JwLmdvb2dsZS5jb20gYW5kXHJcbi8vIGZpcmViYXNlLmNvcnAuZ29vZ2xlLmNvbVxyXG5jb25zdCBGT1JHRV9ET01BSU5fUkUgPSAvKGNvbnNvbGVcXC5maXJlYmFzZXxmaXJlYmFzZS1jb25zb2xlLVxcdytcXC5jb3JwfGZpcmViYXNlXFwuY29ycClcXC5nb29nbGVcXC5jb20vO1xyXG5jb25zdCBMQVNUX1NFU1NJT05fUEFSQU0gPSAnbHMnO1xyXG5jb25zdCBBUFBMSUNBVElPTl9JRF9QQVJBTSA9ICdwJztcclxuY29uc3QgQVBQX0NIRUNLX1RPS0VOX1BBUkFNID0gJ2FjJztcclxuY29uc3QgV0VCU09DS0VUID0gJ3dlYnNvY2tldCc7XHJcbmNvbnN0IExPTkdfUE9MTElORyA9ICdsb25nX3BvbGxpbmcnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogV3JhcHMgYSBET00gU3RvcmFnZSBvYmplY3QgYW5kOlxyXG4gKiAtIGF1dG9tYXRpY2FsbHkgZW5jb2RlIG9iamVjdHMgYXMgSlNPTiBzdHJpbmdzIGJlZm9yZSBzdG9yaW5nIHRoZW0gdG8gYWxsb3cgdXMgdG8gc3RvcmUgYXJiaXRyYXJ5IHR5cGVzLlxyXG4gKiAtIHByZWZpeGVzIG5hbWVzIHdpdGggXCJmaXJlYmFzZTpcIiB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggYXBwIGRhdGEuXHJcbiAqXHJcbiAqIFdlIGF1dG9tYXRpY2FsbHkgKHNlZSBzdG9yYWdlLmpzKSBjcmVhdGUgdHdvIHN1Y2ggd3JhcHBlcnMsIG9uZSBmb3Igc2Vzc2lvblN0b3JhZ2UsXHJcbiAqIGFuZCBvbmUgZm9yIGxvY2FsU3RvcmFnZS5cclxuICpcclxuICovXHJcbmNsYXNzIERPTVN0b3JhZ2VXcmFwcGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGRvbVN0b3JhZ2VfIC0gVGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3QgKGUuZy4gbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihkb21TdG9yYWdlXykge1xyXG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8gPSBkb21TdG9yYWdlXztcclxuICAgICAgICAvLyBVc2UgYSBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIG90aGVyIHN0dWZmIHNhdmVkIGJ5IHRoZSBhcHAuXHJcbiAgICAgICAgdGhpcy5wcmVmaXhfID0gJ2ZpcmViYXNlOic7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNhdmUgdGhlIHZhbHVlIHVuZGVyXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgc3RvcmVkLCBvciBudWxsIHRvIHJlbW92ZSB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnNldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSksIHN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHRoYXQgd2FzIHN0b3JlZCB1bmRlciB0aGlzIGtleSwgb3IgbnVsbFxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICBpZiAoc3RvcmVkVmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbkV2YWwoc3RvcmVkVmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgIH1cclxuICAgIHByZWZpeGVkTmFtZV8obmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tU3RvcmFnZV8udG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdGhhdCBtYXRjaGVzIHRoZSBBUEkgb2YgRE9NU3RvcmFnZVdyYXBwZXJcclxuICogKFRPRE86IGNyZWF0ZSBpbnRlcmZhY2UgZm9yIGJvdGggdG8gaW1wbGVtZW50KS5cclxuICovXHJcbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZV8gPSB7fTtcclxuICAgICAgICB0aGlzLmlzSW5NZW1vcnlTdG9yYWdlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlX1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGlmIChjb250YWlucyh0aGlzLmNhY2hlXywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxyXG4gKiBUT0RPOiBPbmNlIE1lbW9yeVN0b3JhZ2UgYW5kIERPTVN0b3JhZ2VXcmFwcGVyIGhhdmUgYSBzaGFyZWQgaW50ZXJmYWNlIHRoaXMgbWV0aG9kIGFubm90YXRpb24gc2hvdWxkIGNoYW5nZVxyXG4gKiB0byByZWZsZWN0IHRoaXMgdHlwZVxyXG4gKlxyXG4gKiBAcGFyYW0gZG9tU3RvcmFnZU5hbWUgLSBOYW1lIG9mIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0XHJcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXHJcbiAqIEByZXR1cm5zIFR1cm5pbmcgb2ZmIHR5cGUgaW5mb3JtYXRpb24gdW50aWwgYSBjb21tb24gaW50ZXJmYWNlIGlzIGRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVTdG9yYWdlZm9yID0gZnVuY3Rpb24gKGRvbVN0b3JhZ2VOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIE5PVEU6IGp1c3QgYWNjZXNzaW5nIFwibG9jYWxTdG9yYWdlXCIgb3IgXCJ3aW5kb3dbJ2xvY2FsU3RvcmFnZSddXCIgbWF5IHRocm93IGEgc2VjdXJpdHkgZXhjZXB0aW9uLFxyXG4gICAgICAgIC8vIHNvIGl0IG11c3QgYmUgaW5zaWRlIHRoZSB0cnkvY2F0Y2guXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIHRlc3QgY2FjaGUuIEp1c3QgYmVjYXVzZSBpdCdzIGhlcmUgZG9lc24ndCBtZWFuIGl0IHdvcmtzXHJcbiAgICAgICAgICAgIGNvbnN0IGRvbVN0b3JhZ2UgPSB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdO1xyXG4gICAgICAgICAgICBkb21TdG9yYWdlLnNldEl0ZW0oJ2ZpcmViYXNlOnNlbnRpbmVsJywgJ2NhY2hlJyk7XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2UucmVtb3ZlSXRlbSgnZmlyZWJhc2U6c2VudGluZWwnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAvLyBGYWlsZWQgdG8gY3JlYXRlIHdyYXBwZXIuICBKdXN0IHJldHVybiBpbi1tZW1vcnkgc3RvcmFnZS5cclxuICAgIC8vIFRPRE86IGxvZz9cclxuICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xyXG59O1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IGxhc3RzIGFjcm9zcyBzZXNzaW9ucyAqL1xyXG5jb25zdCBQZXJzaXN0ZW50U3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ2xvY2FsU3RvcmFnZScpO1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cclxuY29uc3QgU2Vzc2lvblN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdzZXNzaW9uU3RvcmFnZScpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZGF0YWJhc2UnKTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBsb2NhbGx5LXVuaXF1ZSBJRCAoZ2VuZXJhdGVkIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHVwIGZyb20gMCBlYWNoIHRpbWUgaXRzIGNhbGxlZCkuXHJcbiAqL1xyXG5jb25zdCBMVUlER2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBpZCA9IDE7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpZCsrO1xyXG4gICAgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIFNoYTEgaGFzaCBvZiB0aGUgaW5wdXQgc3RyaW5nXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIGhhc2hcclxuICogQHJldHVybnMgeyFzdHJpbmd9IFRoZSByZXN1bHRpbmcgaGFzaFxyXG4gKi9cclxuY29uc3Qgc2hhMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XHJcbiAgICBjb25zdCBzaGExID0gbmV3IFNoYTEoKTtcclxuICAgIHNoYTEudXBkYXRlKHV0ZjhCeXRlcyk7XHJcbiAgICBjb25zdCBzaGExQnl0ZXMgPSBzaGExLmRpZ2VzdCgpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkoc2hhMUJ5dGVzKTtcclxufTtcclxuY29uc3QgYnVpbGRMb2dNZXNzYWdlXyA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJBcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJnID0gdmFyQXJnc1tpXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8XHJcbiAgICAgICAgICAgIChhcmcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZy5sZW5ndGggPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHJpbmdpZnkoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlICs9ICcgJztcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59O1xyXG4vKipcclxuICogVXNlIHRoaXMgZm9yIGFsbCBkZWJ1ZyBtZXNzYWdlcyBpbiBGaXJlYmFzZS5cclxuICovXHJcbmxldCBsb2dnZXIgPSBudWxsO1xyXG4vKipcclxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxyXG4gKi9cclxubGV0IGZpcnN0TG9nXyA9IHRydWU7XHJcbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWJhc2UuZW5hYmxlTG9nZ2luZyAoZGVmaW5lZCBoZXJlIHRvIGJyZWFrIGRlcGVuZGVuY2llcylcclxuICogQHBhcmFtIGxvZ2dlcl8gLSBBIGZsYWcgdG8gdHVybiBvbiBsb2dnaW5nLCBvciBhIGN1c3RvbSBsb2dnZXJcclxuICogQHBhcmFtIHBlcnNpc3RlbnQgLSBXaGV0aGVyIG9yIG5vdCB0byBwZXJzaXN0IGxvZ2dpbmcgc2V0dGluZ3MgYWNyb3NzIHJlZnJlc2hlc1xyXG4gKi9cclxuY29uc3QgZW5hYmxlTG9nZ2luZyQxID0gZnVuY3Rpb24gKGxvZ2dlcl8sIHBlcnNpc3RlbnQpIHtcclxuICAgIGFzc2VydCghcGVyc2lzdGVudCB8fCBsb2dnZXJfID09PSB0cnVlIHx8IGxvZ2dlcl8gPT09IGZhbHNlLCBcIkNhbid0IHR1cm4gb24gY3VzdG9tIGxvZ2dlcnMgcGVyc2lzdGVudGx5LlwiKTtcclxuICAgIGlmIChsb2dnZXJfID09PSB0cnVlKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50LmxvZ0xldmVsID0gTG9nTGV2ZWwuVkVSQk9TRTtcclxuICAgICAgICBsb2dnZXIgPSBsb2dDbGllbnQubG9nLmJpbmQobG9nQ2xpZW50KTtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgICBTZXNzaW9uU3RvcmFnZS5zZXQoJ2xvZ2dpbmdfZW5hYmxlZCcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dnZXJfID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbG9nZ2VyXztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlciA9IG51bGw7XHJcbiAgICAgICAgU2Vzc2lvblN0b3JhZ2UucmVtb3ZlKCdsb2dnaW5nX2VuYWJsZWQnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGlmIChmaXJzdExvZ18gPT09IHRydWUpIHtcclxuICAgICAgICBmaXJzdExvZ18gPSBmYWxzZTtcclxuICAgICAgICBpZiAobG9nZ2VyID09PSBudWxsICYmIFNlc3Npb25TdG9yYWdlLmdldCgnbG9nZ2luZ19lbmFibGVkJykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZW5hYmxlTG9nZ2luZyQxKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsb2dnZXIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCB2YXJBcmdzKTtcclxuICAgICAgICBsb2dnZXIobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGxvZ1dyYXBwZXIgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgICAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IGVycm9yID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgSU5URVJOQUwgRVJST1I6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCBmYXRhbCA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVCQVNFIEZBVEFMIEVSUk9SOiAke2J1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyl9YDtcclxuICAgIGxvZ0NsaWVudC5lcnJvcihtZXNzYWdlKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufTtcclxuY29uc3Qgd2FybiA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0ZJUkVCQVNFIFdBUk5JTkc6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50Lndhcm4obWVzc2FnZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcclxuICogZG9lcyBub3QgdXNlIGh0dHBzLlxyXG4gKi9cclxuY29uc3Qgd2FybklmUGFnZUlzU2VjdXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQmUgdmVyeSBjYXJlZnVsIGFjY2Vzc2luZyBicm93c2VyIGdsb2JhbHMuIFdobyBrbm93cyB3aGF0IG1heSBvciBtYXkgbm90IGV4aXN0LlxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHBzOicpICE9PSAtMSkge1xyXG4gICAgICAgIHdhcm4oJ0luc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwcyBpbiBjYWxscyB0byBuZXcgRmlyZWJhc2UoKS4nKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBkYXRhIGlzIE5hTiwgb3IgKy8tIEluZmluaXR5LlxyXG4gKi9cclxuY29uc3QgaXNJbnZhbGlkSlNPTk51bWJlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIChkYXRhICE9PSBkYXRhIHx8IC8vIE5hTlxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcclxuICAgICAgICAgICAgZGF0YSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSk7XHJcbn07XHJcbmNvbnN0IGV4ZWN1dGVXaGVuRE9NUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIGlmIChpc05vZGVTZGsoKSB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE1vZGVsZWQgYWZ0ZXIgalF1ZXJ5LiBUcnkgRE9NQ29udGVudExvYWRlZCBhbmQgb25yZWFkeXN0YXRlY2hhbmdlICh3aGljaFxyXG4gICAgICAgIC8vIGZpcmUgYmVmb3JlIG9ubG9hZCksIGJ1dCBmYWxsIGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh3cmFwcGVkRm4sIE1hdGguZmxvb3IoMTApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBJRS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25sb2FkJywgd3JhcHBlZEZuKTtcclxuICAgICAgICAgICAgLy8galF1ZXJ5IGhhcyBhbiBleHRyYSBoYWNrIGZvciBJRSB0aGF0IHdlIGNvdWxkIGVtcGxveSAoYmFzZWQgb25cclxuICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC8pIEJ1dCBpdCBsb29rcyByZWFsbHkgb2xkLlxyXG4gICAgICAgICAgICAvLyBJJ20gaG9waW5nIHdlIGRvbid0IG5lZWQgaXQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogTWluaW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBiZWZvcmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNSU5fTkFNRSA9ICdbTUlOX05BTUVdJztcclxuLyoqXHJcbiAqIE1heGltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYWJvdmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNQVhfTkFNRSA9ICdbTUFYX05BTUVdJztcclxuLyoqXHJcbiAqIENvbXBhcmVzIHZhbGlkIEZpcmViYXNlIGtleSBuYW1lcywgcGx1cyBtaW4gYW5kIG1heCBuYW1lXHJcbiAqL1xyXG5jb25zdCBuYW1lQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA9PT0gTUlOX05BTUUgfHwgYiA9PT0gTUFYX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiID09PSBNSU5fTkFNRSB8fCBhID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYUFzSW50ID0gdHJ5UGFyc2VJbnQoYSksIGJBc0ludCA9IHRyeVBhcnNlSW50KGIpO1xyXG4gICAgICAgIGlmIChhQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFBc0ludCAtIGJBc0ludCA9PT0gMCA/IGEubGVuZ3RoIC0gYi5sZW5ndGggOiBhQXNJbnQgLSBiQXNJbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHshbnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdC5cclxuICovXHJcbmNvbnN0IHN0cmluZ0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlcXVpcmVLZXkgPSBmdW5jdGlvbiAoa2V5LCBvYmopIHtcclxuICAgIGlmIChvYmogJiYga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBrZXkgKCcgKyBrZXkgKyAnKSBpbiBvYmplY3Q6ICcgKyBzdHJpbmdpZnkob2JqKSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IE9iamVjdFRvVW5pcXVlS2V5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkob2JqKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcclxuICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICB9XHJcbiAgICAvLyBFeHBvcnQgYXMganNvbiwgYnV0IHdpdGggdGhlIGtleXMgc29ydGVkLlxyXG4gICAga2V5cy5zb3J0KCk7XHJcbiAgICBsZXQga2V5ID0gJ3snO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAga2V5ICs9ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5ICs9IHN0cmluZ2lmeShrZXlzW2ldKTtcclxuICAgICAgICBrZXkgKz0gJzonO1xyXG4gICAgICAgIGtleSArPSBPYmplY3RUb1VuaXF1ZUtleShvYmpba2V5c1tpXV0pO1xyXG4gICAgfVxyXG4gICAga2V5ICs9ICd9JztcclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcbi8qKlxyXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhIG51bWJlciBvZiBzbWFsbGVyIHNlZ21lbnRzIG9mIG1heGltdW0gc2l6ZVxyXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZ1xyXG4gKiBAcGFyYW0gc2Vnc2l6ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFycyBpbiB0aGUgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLCBzcGxpdCBpbnRvIGFwcHJvcHJpYXRlbHktc2l6ZWQgY2h1bmtzXHJcbiAqL1xyXG5jb25zdCBzcGxpdFN0cmluZ0J5U2l6ZSA9IGZ1bmN0aW9uIChzdHIsIHNlZ3NpemUpIHtcclxuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICBpZiAobGVuIDw9IHNlZ3NpemUpIHtcclxuICAgICAgICByZXR1cm4gW3N0cl07XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhU2VncyA9IFtdO1xyXG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBsZW47IGMgKz0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIGlmIChjICsgc2Vnc2l6ZSA+IGxlbikge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgbGVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgYyArIHNlZ3NpemUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVNlZ3M7XHJcbn07XHJcbi8qKlxyXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGtleSwgdmFsdWUpIHBhaXIgaW4gYW4gb2JqZWN0IG9yXHJcbiAqIGFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoaW5kZXgsIHZhbHVlKSBwYWlyIGluIGFuIGFycmF5XHJcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQm9ycm93ZWQgZnJvbSBodHRwOi8vaGcuc2Vjb25kbGlmZS5jb20vbGxzZC9zcmMvdGlwL2pzL3R5cGVkYXJyYXkuanMgKE1JVCBMaWNlbnNlKVxyXG4gKiBJIG1hZGUgb25lIG1vZGlmaWNhdGlvbiBhdCB0aGUgZW5kIGFuZCByZW1vdmVkIHRoZSBOYU4gLyBJbmZpbml0eVxyXG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxyXG4gKiBAcGFyYW0gdiAtIEEgZG91YmxlXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBkb3VibGVUb0lFRUU3NTRTdHJpbmcgPSBmdW5jdGlvbiAodikge1xyXG4gICAgYXNzZXJ0KCFpc0ludmFsaWRKU09OTnVtYmVyKHYpLCAnSW52YWxpZCBKU09OIG51bWJlcicpOyAvLyBNSkxcclxuICAgIGNvbnN0IGViaXRzID0gMTEsIGZiaXRzID0gNTI7XHJcbiAgICBjb25zdCBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcclxuICAgIGxldCBzLCBlLCBmLCBsbiwgaTtcclxuICAgIC8vIENvbXB1dGUgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICAvLyBTa2lwIE5hTiAvIEluZmluaXR5IGhhbmRsaW5nIC0tTUpMLlxyXG4gICAgaWYgKHYgPT09IDApIHtcclxuICAgICAgICBlID0gMDtcclxuICAgICAgICBmID0gMDtcclxuICAgICAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcyA9IHYgPCAwO1xyXG4gICAgICAgIHYgPSBNYXRoLmFicyh2KTtcclxuICAgICAgICBpZiAodiA+PSBNYXRoLnBvdygyLCAxIC0gYmlhcykpIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplZFxyXG4gICAgICAgICAgICBsbiA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2codikgLyBNYXRoLkxOMiksIGJpYXMpO1xyXG4gICAgICAgICAgICBlID0gbG4gKyBiaWFzO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikgLSBNYXRoLnBvdygyLCBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGVub3JtYWxpemVkXHJcbiAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2IC8gTWF0aC5wb3coMiwgMSAtIGJpYXMgLSBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFBhY2sgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICBjb25zdCBiaXRzID0gW107XHJcbiAgICBmb3IgKGkgPSBmYml0czsgaTsgaSAtPSAxKSB7XHJcbiAgICAgICAgYml0cy5wdXNoKGYgJSAyID8gMSA6IDApO1xyXG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IGViaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZSA9IE1hdGguZmxvb3IoZSAvIDIpO1xyXG4gICAgfVxyXG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XHJcbiAgICBiaXRzLnJldmVyc2UoKTtcclxuICAgIGNvbnN0IHN0ciA9IGJpdHMuam9pbignJyk7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGRhdGEgYXMgYSBoZXggc3RyaW5nLiAtLU1KTFxyXG4gICAgbGV0IGhleEJ5dGVTdHJpbmcgPSAnJztcclxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSArPSA4KSB7XHJcbiAgICAgICAgbGV0IGhleEJ5dGUgPSBwYXJzZUludChzdHIuc3Vic3RyKGksIDgpLCAyKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgaWYgKGhleEJ5dGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoZXhCeXRlU3RyaW5nID0gaGV4Qnl0ZVN0cmluZyArIGhleEJ5dGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4Qnl0ZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xyXG59O1xyXG4vKipcclxuICogVXNlZCB0byBkZXRlY3QgaWYgd2UncmUgaW4gYSBDaHJvbWUgY29udGVudCBzY3JpcHQgKHdoaWNoIGV4ZWN1dGVzIGluIGFuXHJcbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxyXG4gKi9cclxuY29uc3QgaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXSAmJlxyXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ11bJ2V4dGVuc2lvbiddICYmXHJcbiAgICAgICAgIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIFdpbmRvd3MgOCBTdG9yZSBhcHAuXHJcbiAqL1xyXG5jb25zdCBpc1dpbmRvd3NTdG9yZUFwcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIENoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjb3VwbGUgV2luUlQgZ2xvYmFsc1xyXG4gICAgcmV0dXJuIHR5cGVvZiBXaW5kb3dzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2luZG93cy5VSSA9PT0gJ29iamVjdCc7XHJcbn07XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHNlcnZlciBlcnJvciBjb2RlIHRvIGEgSmF2YXNjcmlwdCBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3JGb3JTZXJ2ZXJDb2RlKGNvZGUsIHF1ZXJ5KSB7XHJcbiAgICBsZXQgcmVhc29uID0gJ1Vua25vd24gRXJyb3InO1xyXG4gICAgaWYgKGNvZGUgPT09ICd0b29fYmlnJykge1xyXG4gICAgICAgIHJlYXNvbiA9XHJcbiAgICAgICAgICAgICdUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplICcgK1xyXG4gICAgICAgICAgICAgICAgJ3RoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC4nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgIHJlYXNvbiA9IFwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xyXG4gICAgICAgIHJlYXNvbiA9ICdUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjb2RlICsgJyBhdCAnICsgcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICc6ICcgKyByZWFzb24pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGVycm9yLmNvZGUgPSBjb2RlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuLyoqXHJcbiAqIFVzZWQgdG8gdGVzdCBmb3IgaW50ZWdlci1sb29raW5nIHN0cmluZ3NcclxuICovXHJcbmNvbnN0IElOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tPygwKilcXFxcZHsxLDEwfSQnKTtcclxuLyoqXHJcbiAqIEZvciB1c2UgaW4ga2V5cywgdGhlIG1pbmltdW0gcG9zc2libGUgMzItYml0IGludGVnZXIuXHJcbiAqL1xyXG5jb25zdCBJTlRFR0VSXzMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBreWVzLCB0aGUgbWF4aW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUFYID0gMjE0NzQ4MzY0NztcclxuLyoqXHJcbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgYSAzMi1iaXQgaW50ZWdlciwgcmV0dXJuIGl0LiAgRWxzZSByZXR1cm4gbnVsbC5cclxuICovXHJcbmNvbnN0IHRyeVBhcnNlSW50ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKElOVEVHRVJfUkVHRVhQXy50ZXN0KHN0cikpIHtcclxuICAgICAgICBjb25zdCBpbnRWYWwgPSBOdW1iZXIoc3RyKTtcclxuICAgICAgICBpZiAoaW50VmFsID49IElOVEVHRVJfMzJfTUlOICYmIGludFZhbCA8PSBJTlRFR0VSXzMyX01BWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogSGVscGVyIHRvIHJ1biBzb21lIGNvZGUgYnV0IGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCByZS10aHJvdyB0aGVtIGxhdGVyLlxyXG4gKiBVc2VmdWwgZm9yIHByZXZlbnRpbmcgdXNlciBjYWxsYmFja3MgZnJvbSBicmVha2luZyBpbnRlcm5hbCBjb2RlLlxyXG4gKlxyXG4gKiBSZS10aHJvd2luZyB0aGUgZXhjZXB0aW9uIGZyb20gYSBzZXRUaW1lb3V0IGlzIGEgbGl0dGxlIGV2aWwsIGJ1dCBpdCdzIHZlcnlcclxuICogY29udmVuaWVudCAod2UgZG9uJ3QgaGF2ZSB0byB0cnkgdG8gZmlndXJlIG91dCB3aGVuIGlzIGEgc2FmZSBwb2ludCB0b1xyXG4gKiByZS10aHJvdyBpdCksIGFuZCB0aGUgYmVoYXZpb3Igc2VlbXMgcmVhc29uYWJsZTpcclxuICpcclxuICogKiBJZiB5b3UgYXJlbid0IHBhdXNpbmcgb24gZXhjZXB0aW9ucywgeW91IGdldCBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aXRoXHJcbiAqICAgdGhlIGNvcnJlY3Qgc3RhY2sgdHJhY2UuXHJcbiAqICogSWYgeW91J3JlIHBhdXNpbmcgb24gYWxsIGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIHBhdXNlIG9uIHlvdXJcclxuICogICBleGNlcHRpb24gYW5kIHRoZW4gYWdhaW4gd2hlbiB3ZSByZXRocm93IGl0LlxyXG4gKiAqIElmIHlvdSdyZSBvbmx5IHBhdXNpbmcgb24gdW5jYXVnaHQgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgb25seSBwYXVzZVxyXG4gKiAgIG9uIHVzIHJlLXRocm93aW5nIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgY29kZSB0byBndWFyZC5cclxuICovXHJcbmNvbnN0IGV4Y2VwdGlvbkd1YXJkID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFJlLXRocm93IGV4Y2VwdGlvbiB3aGVuIGl0J3Mgc2FmZS5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IFwidGhyb3cgZVwiIHdvdWxkIHJlc3VsdCBpbiBhIGdvb2QgY29uc29sZSBlcnJvciB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbGV2YW50IGNvbnRleHQsIGJ1dCBhcyBvZiBDaHJvbWUgMzksIHlvdSBqdXN0IGdldCB0aGUgZmlyZWJhc2UuanNcclxuICAgICAgICAgICAgLy8gZmlsZS9saW5lIG51bWJlciB3aGVyZSB3ZSByZS10aHJvdyBpdCwgd2hpY2ggaXMgdXNlbGVzcy4gU28gd2UgbG9nXHJcbiAgICAgICAgICAgIC8vIGUuc3RhY2sgZXhwbGljaXRseS5cclxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBlLnN0YWNrIHx8ICcnO1xyXG4gICAgICAgICAgICB3YXJuKCdFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLicsIHN0YWNrKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHdlIHRoaW5rIHdlJ3JlIGN1cnJlbnRseSBiZWluZyBjcmF3bGVkLlxyXG4gKi9cclxuY29uc3QgYmVpbmdDcmF3bGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxyXG4gICAgICAgIHdpbmRvd1snbmF2aWdhdG9yJ11bJ3VzZXJBZ2VudCddKSB8fFxyXG4gICAgICAgICcnO1xyXG4gICAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXHJcbiAgICAvLyBiZWxpZXZlIHRvIHN1cHBvcnQgSmF2YVNjcmlwdC9BSkFYIHJlbmRlcmluZy5cclxuICAgIC8vIE5PVEU6IEdvb2dsZSBXZWJtYXN0ZXIgVG9vbHMgZG9lc24ndCByZWFsbHkgYmVsb25nLCBidXQgdGhlaXIgXCJUaGlzIGlzIGhvdyBhIHZpc2l0b3IgdG8geW91ciB3ZWJzaXRlXHJcbiAgICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXHJcbiAgICByZXR1cm4gKHVzZXJBZ2VudC5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKSA+PSAwKTtcclxufTtcclxuLyoqXHJcbiAqIFNhbWUgYXMgc2V0VGltZW91dCgpIGV4Y2VwdCBvbiBOb2RlLkpTIGl0IHdpbGwgL25vdC8gcHJldmVudCB0aGUgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXHJcbiAqXHJcbiAqIEl0IGlzIHJlbW92ZWQgd2l0aCBjbGVhclRpbWVvdXQoKSBhcyBub3JtYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIEZ1bmN0aW9uIHRvIHJ1bi5cclxuICogQHBhcmFtIHRpbWUgLSBNaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcnVubmluZy5cclxuICogQHJldHVybnMgVGhlIHNldFRpbWVvdXQoKSByZXR1cm4gdmFsdWUuXHJcbiAqL1xyXG5jb25zdCBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCB0aW1lKTtcclxuICAgIC8vIE5vdGU6IGF0IHRoZSB0aW1lIG9mIHRoaXMgY29tbWVudCwgdW5yZWZUaW1lciBpcyB1bmRlciB0aGUgdW5zdGFibGUgc2V0IG9mIEFQSXMuIFJ1biB3aXRoIC0tdW5zdGFibGUgdG8gZW5hYmxlIHRoZSBBUEkuXHJcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBJcyBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgdHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVub1sndW5yZWZUaW1lciddKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpbWVvdXQpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgJiYgdGltZW91dFsndW5yZWYnXSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGltZW91dFsndW5yZWYnXSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpbWVvdXQ7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxyXG4gKi9cclxuY2xhc3MgUmVwb0luZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSBzZWN1cmUgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcclxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gd2ViU29ja2V0T25seSAtIFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cclxuICAgICAqIEBwYXJhbSBub2RlQWRtaW4gLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgdXNlcyBBZG1pbiBTREsgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiA9IGZhbHNlLCBwZXJzaXN0ZW5jZUtleSA9ICcnLCBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGZhbHNlLCBpc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlO1xyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG4gICAgICAgIHRoaXMud2ViU29ja2V0T25seSA9IHdlYlNvY2tldE9ubHk7XHJcbiAgICAgICAgdGhpcy5ub2RlQWRtaW4gPSBub2RlQWRtaW47XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMgPSBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IGlzVXNpbmdFbXVsYXRvcjtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHRoaXMuX2RvbWFpbiA9IHRoaXMuX2hvc3Quc3Vic3RyKHRoaXMuX2hvc3QuaW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPVxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ2hvc3Q6JyArIGhvc3QpIHx8IHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBpc0NhY2hlYWJsZUhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcclxuICAgIH1cclxuICAgIGlzQ3VzdG9tSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8uY29tJyAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kb21haW4gIT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgaG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIHNldCBob3N0KG5ld0hvc3QpIHtcclxuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBuZXdIb3N0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhY2hlYWJsZUhvc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLl9ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy50b1VSTFN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgdG9VUkxTdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zXHJcbiAgICAgICAgICAgID8gYD9ucz0ke3RoaXMubmFtZXNwYWNlfWBcclxuICAgICAgICAgICAgOiAnJztcclxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt0aGlzLmhvc3R9LyR7cXVlcnl9YDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykge1xyXG4gICAgcmV0dXJuIChyZXBvSW5mby5ob3N0ICE9PSByZXBvSW5mby5pbnRlcm5hbEhvc3QgfHxcclxuICAgICAgICByZXBvSW5mby5pc0N1c3RvbUhvc3QoKSB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqIEBwYXJhbSByZXBvSW5mbyAtIFJlcG9JbmZvIG9iamVjdFxyXG4gKiBAcGFyYW0gdHlwZSAtIG9mIGNvbm5lY3Rpb25cclxuICogQHBhcmFtIHBhcmFtcyAtIGxpc3RcclxuICogQHJldHVybnMgVGhlIFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIHR5cGUsIHBhcmFtcykge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ3R5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nJyk7XHJcbiAgICBhc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XHJcbiAgICBsZXQgY29ublVSTDtcclxuICAgIGlmICh0eXBlID09PSBXRUJTT0NLRVQpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyByZXBvSW5mby5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gTE9OR19QT0xMSU5HKSB7XHJcbiAgICAgICAgY29ublVSTCA9XHJcbiAgICAgICAgICAgIChyZXBvSW5mby5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXHJcbiAgICAgICAgICAgICAgICByZXBvSW5mby5pbnRlcm5hbEhvc3QgK1xyXG4gICAgICAgICAgICAgICAgJy8ubHA/JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxuICAgIGlmIChyZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykpIHtcclxuICAgICAgICBwYXJhbXNbJ25zJ10gPSByZXBvSW5mby5uYW1lc3BhY2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWlycyA9IFtdO1xyXG4gICAgZWFjaChwYXJhbXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY291bnRlcnNfID0ge307XHJcbiAgICB9XHJcbiAgICBpbmNyZW1lbnRDb3VudGVyKG5hbWUsIGFtb3VudCA9IDEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuY291bnRlcnNfLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gZGVlcENvcHkodGhpcy5jb3VudGVyc18pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGNvbGxlY3Rpb25zID0ge307XHJcbmNvbnN0IHJlcG9ydGVycyA9IHt9O1xyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKSB7XHJcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcclxuICAgIGlmICghY29sbGVjdGlvbnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSA9IG5ldyBTdGF0c0NvbGxlY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXTtcclxufVxyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyKHJlcG9JbmZvLCBjcmVhdG9yRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFyZXBvcnRlcnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICByZXBvcnRlcnNbaGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvcnRlcnNbaGFzaFN0cmluZ107XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFRoZSBzZW12ZXIgKHd3dy5zZW12ZXIub3JnKSB2ZXJzaW9uIG9mIHRoZSBTREsuICovXHJcbmxldCBTREtfVkVSU0lPTiA9ICcnO1xyXG4vKipcclxuICogU0RLX1ZFUlNJT04gc2hvdWxkIGJlIHNldCBiZWZvcmUgYW55IGRhdGFiYXNlIGluc3RhbmNlIGlzIGNyZWF0ZWRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcclxuICAgIFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUgPSAxNjM4NDtcclxuY29uc3QgV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCA9IDQ1MDAwO1xyXG5sZXQgV2ViU29ja2V0SW1wbCA9IG51bGw7XHJcbmlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgV2ViU29ja2V0SW1wbCA9IE1veldlYlNvY2tldDtcclxufVxyXG5lbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgV2ViU29ja2V0SW1wbCA9IFdlYlNvY2tldDtcclxufVxyXG5mdW5jdGlvbiBzZXRXZWJTb2NrZXRJbXBsKGltcGwpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBpbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2tzLlxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0Q29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb25uSWQgaWRlbnRpZmllciBmb3IgdGhpcyB0cmFuc3BvcnRcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cclxuICAgICAqIEBwYXJhbSBhcHBsaWNhdGlvbklkIFRoZSBGaXJlYmFzZSBBcHAgSUQgZm9yIHRoaXMgcHJvamVjdC5cclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuIFRoZSBBcHAgQ2hlY2sgVG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiBUaGUgQXV0aCBUb2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25JZCBpZiB0aGlzIGlzIGNvbm5lY3RpbmdcclxuICAgICAqIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydCBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzXHJcbiAgICAgKiBjb25uZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbm5JZCwgcmVwb0luZm8sIGFwcGxpY2F0aW9uSWQsIGFwcENoZWNrVG9rZW4sIGF1dGhUb2tlbiwgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uSWQgPSBjb25uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklkID0gYXBwbGljYXRpb25JZDtcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW4gPSBhcHBDaGVja1Rva2VuO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuID0gYXV0aFRva2VuO1xyXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKHRoaXMuY29ubklkKTtcclxuICAgICAgICB0aGlzLnN0YXRzXyA9IHN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24ocmVwb0luZm8pO1xyXG4gICAgICAgIHRoaXMuY29ublVSTCA9IFdlYlNvY2tldENvbm5lY3Rpb24uY29ubmVjdGlvblVSTF8ocmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXBwbGljYXRpb25JZCk7XHJcbiAgICAgICAgdGhpcy5ub2RlQWRtaW4gPSByZXBvSW5mby5ub2RlQWRtaW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyAtIFRoZSBpbmZvIGZvciB0aGUgd2Vic29ja2V0IGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCAtIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25JZCBpZiB0aGlzIGlzIGNvbm5lY3RpbmcgdG8gYW4gZXhpc3RpbmcgdHJhbnNwb3J0XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgLSBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGNvbm5lY3Rpb25cclxuICAgICAqIEByZXR1cm5zIGNvbm5lY3Rpb24gdXJsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkLCBhcHBDaGVja1Rva2VuLCBhcHBsaWNhdGlvbklkKSB7XHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdXJsUGFyYW1zW1ZFUlNJT05fUEFSQU1dID0gUFJPVE9DT0xfVkVSU0lPTjtcclxuICAgICAgICBpZiAoIWlzTm9kZVNkaygpICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgbG9jYXRpb24uaG9zdG5hbWUgJiZcclxuICAgICAgICAgICAgRk9SR0VfRE9NQUlOX1JFLnRlc3QobG9jYXRpb24uaG9zdG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tSRUZFUkVSX1BBUkFNXSA9IEZPUkdFX1JFRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYW5zcG9ydFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbVFJBTlNQT1JUX1NFU1NJT05fUEFSQU1dID0gdHJhbnNwb3J0U2Vzc2lvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbTEFTVF9TRVNTSU9OX1BBUkFNXSA9IGxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tBUFBfQ0hFQ0tfVE9LRU5fUEFSQU1dID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0FQUExJQ0FUSU9OX0lEX1BBUkFNXSA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIFdFQlNPQ0tFVCwgdXJsUGFyYW1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZSAtIENhbGxiYWNrIHdoZW4gbWVzc2FnZXMgYXJyaXZlXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gQ2FsbGJhY2sgd2l0aCBjb25uZWN0aW9uIGxvc3QuXHJcbiAgICAgKi9cclxuICAgIG9wZW4ob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG9uTWVzc2FnZTtcclxuICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW5nIHRvICcgKyB0aGlzLmNvbm5VUkwpO1xyXG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvLyBBc3N1bWUgZmFpbHVyZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLlxyXG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnLCB0cnVlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLm5vZGVBZG1pbiA/ICdBZG1pbk5vZGUnIDogJ05vZGUnO1xyXG4gICAgICAgICAgICAgICAgLy8gVUEgRm9ybWF0OiBGaXJlYmFzZS88d2lyZV9wcm90b2NvbD4vPHNka192ZXJzaW9uPi88cGxhdGZvcm0+LzxkZXZpY2U+XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBgRmlyZWJhc2UvJHtQUk9UT0NPTF9WRVJTSU9OfS8ke1NES19WRVJTSU9OfS8ke3Byb2Nlc3MucGxhdGZvcm19LyR7ZGV2aWNlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUZpcmViYXNlLUdNUElEJzogdGhpcy5hcHBsaWNhdGlvbklkIHx8ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIE5vZGUgd2l0aCBhZG1pbiBjcmVkcywgQXBwQ2hlY2stcmVsYXRlZCBjaGVja3MgYXJlIHVubmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHNlbmQgdGhlIGNyZWRlbnRpYWxzIGhlcmUgZXZlbiBpZiB0aGV5IGFyZW4ndCBhZG1pbiBjcmVkZW50aWFscywgd2hpY2ggaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIHByb2JsZW0uXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBoZWFkZXIgaXMganVzdCB1c2VkIHRvIGJ5cGFzcyBhcHBjaGVjaywgYW5kIHRoZSB0b2tlbiBzaG91bGQgc3RpbGwgYmUgc2VudFxyXG4gICAgICAgICAgICAgICAgLy8gdGhyb3VnaCB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gb25jZSBpdCBpcyBlc3RhYmxpc2hlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3RoaXMuYXV0aFRva2VufWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydYLUZpcmViYXNlLUFwcENoZWNrJ10gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQbHVtYiBhcHByb3ByaWF0ZSBodHRwX3Byb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIGludG8gZmF5ZS13ZWJzb2NrZXQgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZW52ID0gcHJvY2Vzc1snZW52J107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9IHRoaXMuY29ublVSTC5pbmRleE9mKCd3c3M6Ly8nKSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gZW52WydIVFRQU19QUk9YWSddIHx8IGVudlsnaHR0cHNfcHJveHknXVxyXG4gICAgICAgICAgICAgICAgICAgIDogZW52WydIVFRQX1BST1hZJ10gfHwgZW52WydodHRwX3Byb3h5J107XHJcbiAgICAgICAgICAgICAgICBpZiAocHJveHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zWydwcm94eSddID0geyBvcmlnaW46IHByb3h5IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBuZXcgV2ViU29ja2V0SW1wbCh0aGlzLmNvbm5VUkwsIFtdLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdFcnJvciBpbnN0YW50aWF0aW5nIFdlYlNvY2tldC4nKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15U29jay5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm15U29jay5vbmNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ubWVzc2FnZSA9IG0gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nRnJhbWUobSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm15U29jay5vbmVycm9yID0gZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGVycm9yLiAgQ2xvc2luZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vLW9wIGZvciB3ZWJzb2NrZXRzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgY29uZmlybWVkIGFzIG9wZW5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7IH1cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGxldCBpc09sZEFuZHJvaWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRBbmRyb2lkUmVnZXggPSAvQW5kcm9pZCAoWzAtOV17MCx9XFwuWzAtOV17MCx9KS87XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gob2xkQW5kcm9pZFJlZ2V4KTtcclxuICAgICAgICAgICAgaWYgKG9sZEFuZHJvaWRNYXRjaCAmJiBvbGRBbmRyb2lkTWF0Y2gubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQob2xkQW5kcm9pZE1hdGNoWzFdKSA8IDQuNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzT2xkQW5kcm9pZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICghaXNPbGRBbmRyb2lkICYmXHJcbiAgICAgICAgICAgIFdlYlNvY2tldEltcGwgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgIVdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgd2UgcHJldmlvdXNseSBmYWlsZWQgdG8gY29ubmVjdCB3aXRoIHRoaXMgdHJhbnNwb3J0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcHJldmlvdXNseUZhaWxlZCgpIHtcclxuICAgICAgICAvLyBJZiBvdXIgcGVyc2lzdGVudCBzdG9yYWdlIGlzIGFjdHVhbGx5IG9ubHkgaW4tbWVtb3J5IHN0b3JhZ2UsXHJcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byBhc3N1bWluZyB0aGF0IGl0IHByZXZpb3VzbHkgZmFpbGVkIHRvIGJlIHNhZmUuXHJcbiAgICAgICAgcmV0dXJuIChQZXJzaXN0ZW50U3RvcmFnZS5pc0luTWVtb3J5U3RvcmFnZSB8fFxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJykgPT09IHRydWUpO1xyXG4gICAgfVxyXG4gICAgbWFya0Nvbm5lY3Rpb25IZWFsdGh5KCkge1xyXG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKTtcclxuICAgIH1cclxuICAgIGFwcGVuZEZyYW1lXyhkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMucHVzaChkYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSB0aGlzLnRvdGFsRnJhbWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNZXNzID0gdGhpcy5mcmFtZXMuam9pbignJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QganNvbk1lc3MgPSBqc29uRXZhbChmdWxsTWVzcyk7XHJcbiAgICAgICAgICAgIC8vaGFuZGxlIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGpzb25NZXNzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmcmFtZUNvdW50IC0gVGhlIG51bWJlciBvZiBmcmFtZXMgd2UgYXJlIGV4cGVjdGluZyBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgaGFuZGxlTmV3RnJhbWVDb3VudF8oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBmcmFtZUNvdW50O1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgZnJhbWUgY291bnQgb3V0IG9mIHNvbWUgdGV4dC4gSWYgaXQgY2FuJ3QsIGFzc3VtZXMgYSB2YWx1ZSBvZiAxXHJcbiAgICAgKiBAcmV0dXJucyBBbnkgcmVtYWluaW5nIGRhdGEgdG8gYmUgcHJvY2Vzcywgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lXHJcbiAgICAgKi9cclxuICAgIGV4dHJhY3RGcmFtZUNvdW50XyhkYXRhKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZnJhbWVzID09PSBudWxsLCAnV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyJyk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhlIHNlcnZlciBpcyBvbmx5IHN1cHBvc2VkIHRvIHNlbmQgdXAgdG8gOTk5OSBmcmFtZXMgKGkuZS4gbGVuZ3RoIDw9IDQpLCBidXQgdGhhdCBpc24ndCBiZWluZyBlbmZvcmNlZFxyXG4gICAgICAgIC8vIGN1cnJlbnRseS4gIFNvIGFsbG93aW5nIGxhcmdlciBmcmFtZSBjb3VudHMgKGxlbmd0aCA8PSA2KS4gIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC9zZWFyY2gvODY4ODU5ODk5ODM4MC84MjM3NjA4MDQyNTA4XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDYpIHtcclxuICAgICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IE51bWJlcihkYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihmcmFtZUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oMSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgYSB3ZWJzb2NrZXQgZnJhbWUgdGhhdCBoYXMgYXJyaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzcyAtIFRoZSBmcmFtZSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUluY29taW5nRnJhbWUobWVzcykge1xyXG4gICAgICAgIGlmICh0aGlzLm15U29jayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIENocm9tZSBhcHBhcmVudGx5IGRlbGl2ZXJzIGluY29taW5nIHBhY2tldHMgZXZlbiBhZnRlciB3ZSAuY2xvc2UoKSB0aGUgY29ubmVjdGlvbiBzb21ldGltZXMuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzWydkYXRhJ107XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgYnVmZmVyaW5nXHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIHBhcnNlIG91dCBhIGZyYW1lIGNvdW50LCBvdGhlcndpc2UsIGFzc3VtZSAxIGFuZCBwcm9jZXNzIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGEgPSB0aGlzLmV4dHJhY3RGcmFtZUNvdW50XyhkYXRhKTtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKHJlbWFpbmluZ0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBKU09OIG9iamVjdCB0byB0cmFuc21pdFxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IHN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCArPSBkYXRhU3RyLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19zZW50JywgZGF0YVN0ci5sZW5ndGgpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCB3ZWJzb2NrZXQgZnJhbWUsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGRhdGFTdHIsIFdFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSk7XHJcbiAgICAgICAgLy9TZW5kIHRoZSBsZW5ndGggaGVhZGVyXHJcbiAgICAgICAgaWYgKGRhdGFTZWdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXyhTdHJpbmcoZGF0YVNlZ3MubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vU2VuZCB0aGUgYWN0dWFsIGRhdGEgaW4gc2VnbWVudHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKGRhdGFTZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bl8oKSB7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGNsb3NpbmcgaXRzZWxmJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25fKCk7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYW4gaW50ZXJuYWwgY2xvc2UsIHRyaWdnZXIgdGhlIGNsb3NlIGxpc3RlbmVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QodGhpcy5ldmVyQ29ubmVjdGVkXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVybmFsLWZhY2luZyBjbG9zZSBoYW5kbGVyLlxyXG4gICAgICogQ2xvc2UgdGhlIHdlYnNvY2tldCBhbmQga2lsbCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBpcyBiZWluZyBjbG9zZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEtpbGwgdGhlIGN1cnJlbnQga2VlcGFsaXZlIHRpbWVyIGFuZCBzdGFydCBhIG5ldyBvbmUsIHRvIGVuc3VyZSB0aGF0IGl0IGFsd2F5cyBmaXJlcyBOIHNlY29uZHMgYWZ0ZXJcclxuICAgICAqIHRoZSBsYXN0IGFjdGl2aXR5LlxyXG4gICAgICovXHJcbiAgICByZXNldEtlZXBBbGl2ZSgpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xyXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vSWYgdGhlcmUgaGFzIGJlZW4gbm8gd2Vic29ja2V0IGFjdGl2aXR5IGZvciBhIHdoaWxlLCBzZW5kIGEgbm8tb3BcclxuICAgICAgICAgICAgaWYgKHRoaXMubXlTb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKCcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH0sIE1hdGguZmxvb3IoV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgc3RyaW5nIG92ZXIgdGhlIHdlYnNvY2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIHNlbmRTdHJpbmdfKHN0cikge1xyXG4gICAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gc29tZXRpbWVzIHRocm93IGV4Y2VwdGlvbnMgKE5TX0VSUk9SX1VORVhQRUNURUQpIGZyb20gd2Vic29ja2V0IC5zZW5kKClcclxuICAgICAgICAvLyBjYWxscyBmb3Igc29tZSB1bmtub3duIHJlYXNvbi4gIFdlIHRyZWF0IHRoZXNlIGFzIGFuIGVycm9yIGFuZCBkaXNjb25uZWN0LlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC81ODkyNjExMTQwMjI5Mi82ODAyMTM0MDI1MDQxMFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrLnNlbmQoc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdFeGNlcHRpb24gdGhyb3duIGZyb20gV2ViU29ja2V0LnNlbmQoKTonLCBlLm1lc3NhZ2UgfHwgZS5kYXRhLCAnQ2xvc2luZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMub25DbG9zZWRfLmJpbmQodGhpcyksIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogTnVtYmVyIG9mIHJlc3BvbnNlIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBcImhlYWx0aHkuXCJcclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24ucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSA9IDI7XHJcbi8qKlxyXG4gKiBUaW1lIHRvIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRlIGJlY29tZSBoZWFsdGh5IGJlZm9yZSBnaXZpbmcgdXAuXHJcbiAqL1xyXG5XZWJTb2NrZXRDb25uZWN0aW9uLmhlYWx0aHlUaW1lb3V0ID0gMzAwMDA7XG5cbmNvbnN0IG5hbWUgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xNC40XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgQXBwQ2hlY2sncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwTmFtZV8sIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcE5hbWVfID0gYXBwTmFtZV87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBcHBDaGVjay4gVGhpcyBhbGxvd3Mgb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBjdXN0b21lcnMgdG8gaW5pdGlhbGl6ZSB0aGUgUlREQiBTREsgYmVmb3JlIGluaXRpYWxpemluZyBGaXJlYmFzZVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwQ2hlY2sgYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKS50aGVuKGFwcENoZWNrID0+IGFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICB3YXJuKGBQcm92aWRlZCBBcHBDaGVjayBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIiR7dGhpcy5hcHBOYW1lX31cIiBgICtcclxuICAgICAgICAgICAgJ2FyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBmaXJlYmFzZU9wdGlvbnNfLCBhdXRoUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuZmlyZWJhc2VPcHRpb25zXyA9IGZpcmViYXNlT3B0aW9uc187XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfID0gYXV0aFByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmF1dGhfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhfID0gYXV0aFByb3ZpZGVyXy5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyXy5vbkluaXQoYXV0aCA9PiAodGhpcy5hdXRoXyA9IGF1dGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUF1dGguIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEF1dGggYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBlbnN1cmVzIHRoZSBwYWNrZXRzIGZyb20gdGhlIHNlcnZlciBhcnJpdmUgaW4gb3JkZXJcclxuICogVGhpcyBjbGFzcyB0YWtlcyBkYXRhIGZyb20gdGhlIHNlcnZlciBhbmQgZW5zdXJlcyBpdCBnZXRzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja3MgaW4gb3JkZXIuXHJcbiAqL1xyXG5jbGFzcyBQYWNrZXRSZWNlaXZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9uTWVzc2FnZV8pIHtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID0gMDtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IC0xO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbG9zZUFmdGVyKHJlc3BvbnNlTnVtLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlID0gcmVzcG9uc2VOdW07XHJcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlIDwgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0pIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyIGNvbWVzIHdpdGggYSByZXNwb25zZSBudW1iZXIsIGFuZCBhbiBhcnJheSBvZiBkYXRhLiBUaGUgcmVzcG9uc2VOdW1iZXJcclxuICAgICAqIGFsbG93cyB1cyB0byBlbnN1cmUgdGhhdCB3ZSBwcm9jZXNzIHRoZW0gaW4gdGhlIHJpZ2h0IG9yZGVyLCBzaW5jZSB3ZSBjYW4ndCBiZSBndWFyYW50ZWVkIHRoYXQgYWxsXHJcbiAgICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcclxuICAgICAqL1xyXG4gICAgaGFuZGxlUmVzcG9uc2UocmVxdWVzdE51bSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1tyZXF1ZXN0TnVtXSA9IGRhdGE7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9Qcm9jZXNzID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3RoaXMuY3VycmVudFJlc3BvbnNlTnVtXTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Qcm9jZXNzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9Qcm9jZXNzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZV8odG9Qcm9jZXNzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzcG9uc2VOdW0gPT09IHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBsb25ncG9sbGluZ1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSA9ICdzdGFydCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQgPSAnY2xvc2UnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgPSAncExQQ29tbWFuZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSA9ICdwUlRMUENCJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU0gPSAnaWQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSA9ICdwdyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTSA9ICdzZXInO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DQUxMQkFDS19JRF9QQVJBTSA9ICdjYic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNID0gJ3NlZyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCA9ICd0cyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0gPSAnZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTSA9ICdkZnJhbWUnO1xyXG4vL0RhdGEgc2l6ZSBjb25zdGFudHMuXHJcbi8vVE9ETzogUGVyZjogdGhlIG1heGltdW0gbGVuZ3RoIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIuXHJcbi8vIFdlIHNob3VsZCBjaGVjayB3aGF0IGJyb3dzZXIgd2UncmUgb24gYW5kIHNldCBhY2NvcmRpbmdseS5cclxuY29uc3QgTUFYX1VSTF9EQVRBX1NJWkUgPSAxODcwO1xyXG5jb25zdCBTRUdfSEVBREVSX1NJWkUgPSAzMDsgLy9pZTogJnNlZz04Mjk5MjM0JnRzPTk4MjM4OTEyMyZkPVxyXG5jb25zdCBNQVhfUEFZTE9BRF9TSVpFID0gTUFYX1VSTF9EQVRBX1NJWkUgLSBTRUdfSEVBREVSX1NJWkU7XHJcbi8qKlxyXG4gKiBLZWVwYWxpdmUgcGVyaW9kXHJcbiAqIHNlbmQgYSBmcmVzaCByZXF1ZXN0IGF0IG1pbmltdW0gZXZlcnkgMjUgc2Vjb25kcy4gT3BlcmEgaGFzIGEgbWF4aW11bSByZXF1ZXN0XHJcbiAqIGxlbmd0aCBvZiAzMCBzZWNvbmRzIHRoYXQgd2UgY2FuJ3QgZXhjZWVkLlxyXG4gKi9cclxuY29uc3QgS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwgPSAyNTAwMDtcclxuLyoqXHJcbiAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGFib3J0aW5nIGEgbG9uZy1wb2xsaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdC5cclxuICovXHJcbmNvbnN0IExQX0NPTk5FQ1RfVElNRU9VVCA9IDMwMDAwO1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGEgc2luZ2xlIGxvbmctcG9sbGluZyBjb25uZWN0aW9uLlxyXG4gKi9cclxuY2xhc3MgQnJvd3NlclBvbGxDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBBbiBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24sIHVzZWQgZm9yIGxvZ2dpbmdcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqIEBwYXJhbSBhcHBsaWNhdGlvbklkIFRoZSBGaXJlYmFzZSBBcHAgSUQgZm9yIHRoaXMgcHJvamVjdC5cclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuIFRoZSBBcHBDaGVjayB0b2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoVG9rZW4gdG8gdXNlIGZvciB0aGlzIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25pZCBpZiB3ZSBhcmVcclxuICAgICAqIHJlY29ubmVjdGluZyBmb3IgYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlIFBlcnNpc3RlbnRDb25uZWN0aW9uIGhhc1xyXG4gICAgICogYWxyZWFkeSBjcmVhdGVkIGEgY29ubmVjdGlvbiBwcmV2aW91c2x5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbm5JZCwgcmVwb0luZm8sIGFwcGxpY2F0aW9uSWQsIGFwcENoZWNrVG9rZW4sIGF1dGhUb2tlbiwgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uSWQgPSBjb25uSWQ7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mbyA9IHJlcG9JbmZvO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IGF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCA9IHRyYW5zcG9ydFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmxhc3RTZXNzaW9uSWQgPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKGNvbm5JZCk7XHJcbiAgICAgICAgdGhpcy5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcclxuICAgICAgICB0aGlzLnVybEZuID0gKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgYWRkIHRoZSB0b2tlbiBpZiB3ZSBoYXZlIG9uZS5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgTE9OR19QT0xMSU5HLCBwYXJhbXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxyXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxyXG4gICAgICovXHJcbiAgICBvcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtID0gMDtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIgPSBuZXcgUGFja2V0UmVjZWl2ZXIob25NZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuJyk7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKExQX0NPTk5FQ1RfVElNRU9VVCkpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkZWxheSB0aGUgY3JlYXRpb24gb2YgdGhlIGlmcmFtZSB1bnRpbCB0aGUgRE9NIGlzIGxvYWRlZC5cclxuICAgICAgICBleGVjdXRlV2hlbkRPTVJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9TZXQgdXAgYSBjYWxsYmFjayB0aGF0IGdldHMgdHJpZ2dlcmVkIG9uY2UgYSBjb25uZWN0aW9uIGlzIHNldCB1cC5cclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBuZXcgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIoKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtjb21tYW5kLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0XSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gd2UgY2xvc2VkIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09PSBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBhcmcxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBhcmcyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBob3N0IGNhY2hlLiBXZSBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGtub3cgaXQncyByZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgZXhwZWN0aW5nIGFueSBtb3JlIGRhdGEgKG90aGVyIHRoYW4gd2hhdCB0aGUgc2VydmVyJ3MgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiBzZW5kaW5nIHVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggb3VyIGFscmVhZHkgb3BlbiBwb2xscyksIHNvIGRvbid0IHNlbmQgYW55IG1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZSByZXNwb25zZXMgdXAgdG8gdGhpcyBvbmUgYmVmb3JlIGNsb3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogJyArIGNvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3BOLCBkYXRhXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xyXG4gICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLnVybEZuKTtcclxuICAgICAgICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcclxuICAgICAgICAgICAgLy9mcm9tIGNhY2hlLlxyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1dID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci51bmlxdWVDYWxsYmFja0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJsUGFyYW1zW1ZFUlNJT05fUEFSQU1dID0gUFJPVE9DT0xfVkVSU0lPTjtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbVFJBTlNQT1JUX1NFU1NJT05fUEFSQU1dID0gdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSB0aGlzLmxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUExJQ0FUSU9OX0lEX1BBUkFNXSA9IHRoaXMuYXBwbGljYXRpb25JZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbQVBQX0NIRUNLX1RPS0VOX1BBUkFNXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaG9zdG5hbWUgJiZcclxuICAgICAgICAgICAgICAgIEZPUkdFX0RPTUFJTl9SRS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGluZyB2aWEgbG9uZy1wb2xsIHRvICcgKyBjb25uZWN0VVJMKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuYWRkVGFnKGNvbm5lY3RVUkwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGwgdGhpcyB3aGVuIGEgaGFuZHNoYWtlIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCB3ZSB3YW50IHRvIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnN0YXJ0TG9uZ1BvbGwodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XHJcbiAgICAgICAgdGhpcy5hZGREaXNjb25uZWN0UGluZ0ZyYW1lKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZyBwb2xsaW5nIHRvIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZUFsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBsb25ncG9sbGluZyB0byBub3QgYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIFN0YXRpYyBtZXRob2QsIHVzZSBzdHJpbmcgbGl0ZXJhbCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgaW4gYSBnZW5lcmljIHdheVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB0aGVyZSdzIG5vcm1hbGx5IG5vICdkb2N1bWVudCcsIGJ1dCBpZiB5b3UgZGVidWcgYSBSZWFjdC1OYXRpdmUgYXBwIGluXHJcbiAgICAgICAgICAgIC8vIHRoZSBDaHJvbWUgZGVidWdnZXIsICdkb2N1bWVudCcgaXMgZGVmaW5lZCwgYnV0IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgbnVsbCAoMjAxNS8wNi8wOCkuXHJcbiAgICAgICAgICAgIHJldHVybiAoIUJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0KCkgJiZcclxuICAgICAgICAgICAgICAgICFpc1dpbmRvd3NTdG9yZUFwcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vLW9wIGZvciBwb2xsaW5nXHJcbiAgICAgKi9cclxuICAgIG1hcmtDb25uZWN0aW9uSGVhbHRoeSgpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBwb2xsaW5nIGFuZCBjbGVhbnMgdXAgdGhlIGlmcmFtZVxyXG4gICAgICovXHJcbiAgICBzaHV0ZG93bl8oKSB7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmVtb3ZlIHRoZSBkaXNjb25uZWN0IGZyYW1lLCB3aGljaCB3aWxsIHRyaWdnZXIgYW4gWEhSIGNhbGwgdG8gdGhlIHNlcnZlciB0byB0ZWxsIGl0IHdlJ3JlIGxlYXZpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMubXlEaXNjb25uRnJhbWUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHRyYW5zcG9ydCBpcyBjbG9zZWRcclxuICAgICAqL1xyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8odGhpcy5ldmVyQ29ubmVjdGVkXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci4gUmVhbFRpbWUgaGFzIHJlcXVlc3RlZCB3ZSBzaHV0IGRvd24uIEtpbGwgb3VyIGNvbm5lY3Rpb24gYW5kIHRlbGwgdGhlIHNlcnZlclxyXG4gICAgICogdGhhdCB3ZSd2ZSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCB0aGUgSlNPTiBvYmplY3QgZG93biB0byB0aGUgc2VydmVyLiBJdCB3aWxsIG5lZWQgdG8gYmUgc3RyaW5naWZpZWQsIGJhc2U2NCBlbmNvZGVkLCBhbmQgdGhlblxyXG4gICAgICogYnJva2VuIGludG8gY2h1bmtzIChzaW5jZSBVUkxzIGhhdmUgYSBzbWFsbCBtYXhpbXVtIGxlbmd0aCkuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBKU09OIGRhdGEgdG8gdHJhbnNtaXQuXHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcclxuICAgICAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxyXG4gICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSBiYXNlNjRFbmNvZGUoZGF0YVN0cik7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIFVSTCwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoYmFzZTY0ZGF0YSwgTUFYX1BBWUxPQURfU0laRSk7XHJcbiAgICAgICAgLy9FbnF1ZXVlIGVhY2ggc2VnbWVudCBmb3IgdHJhbnNtaXNzaW9uLiBXZSBhc3NpZ24gZWFjaCBjaHVuayBhIHNlcXVlbnRpYWwgSUQgYW5kIGEgdG90YWwgbnVtYmVyXHJcbiAgICAgICAgLy9vZiBzZWdtZW50cyBzbyB0aGF0IHdlIGNhbiByZWFzc2VtYmxlIHRoZSBwYWNrZXQgb24gdGhlIHNlcnZlci5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmVucXVldWVTZWdtZW50KHRoaXMuY3VyU2VnbWVudE51bSwgZGF0YVNlZ3MubGVuZ3RoLCBkYXRhU2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICogV2UgYXJlbid0IGFibGUgdG8gc2VuZCByZXF1ZXN0cyB3aXRoIERIVE1MIG9uIGEgd2luZG93IGNsb3NlIGV2ZW50LCBidXQgd2UgY2FuXHJcbiAgICAgKiB0cmlnZ2VyIFhIUiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzIChldmVyeXRoaW5nIGJ1dCBPcGVyYSBiYXNpY2FsbHkpLlxyXG4gICAgICovXHJcbiAgICBhZGREaXNjb25uZWN0UGluZ0ZyYW1lKGlkLCBwdykge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gaWQ7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHB3O1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3JjID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHRyYWNrIHRoZSBieXRlcyByZWNlaXZlZCBieSB0aGlzIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKSB7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhbiBhbm5veWluZyBwZXJmIGhpdCBqdXN0IHRvIHRyYWNrIHRoZSBudW1iZXIgb2YgaW5jb21pbmcgYnl0ZXMuICBNYXliZSBpdCBzaG91bGQgYmUgb3B0LWluLlxyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVjZWl2ZWQgPSBzdHJpbmdpZnkoYXJncykubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBieXRlc1JlY2VpdmVkO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgYnl0ZXNSZWNlaXZlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIGlmcmFtZSB0aGF0IGlzIHVzZWQgYXMgYSBsb25nLXBvbGxpbmcgc2NyaXB0IGhvbGRlci5cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuY2xhc3MgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VDQiAtIFRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiByZXNwb25zZXMgYXJyaXZlIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyB0YWcgaG9sZGVyIGlzIGNsb3NlZFxyXG4gICAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZENCLCBvbk1lc3NhZ2VDQiwgb25EaXNjb25uZWN0LCB1cmxGbikge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMudXJsRm4gPSB1cmxGbjtcclxuICAgICAgICAvL1dlIG1haW50YWluIGEgY291bnQgb2YgYWxsIG9mIHRoZSBvdXRzdGFuZGluZyByZXF1ZXN0cywgYmVjYXVzZSBpZiB3ZSBoYXZlIHRvbyBtYW55IGFjdGl2ZSBhdCBvbmNlIGl0IGNhbiBjYXVzZVxyXG4gICAgICAgIC8vcHJvYmxlbXMgaW4gc29tZSBicm93c2Vycy5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy9BIHF1ZXVlIG9mIHRoZSBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ3MgPSBbXTtcclxuICAgICAgICAvL0Egc2VyaWFsIG51bWJlci4gV2UgdXNlIHRoaXMgZm9yIHR3byB0aGluZ3M6XHJcbiAgICAgICAgLy8gMSkgQSB3YXkgdG8gZW5zdXJlIHRoZSBicm93c2VyIGRvZXNuJ3QgY2FjaGUgcmVzcG9uc2VzIHRvIHBvbGxzXHJcbiAgICAgICAgLy8gMikgQSB3YXkgdG8gbWFrZSB0aGUgc2VydmVyIGF3YXJlIHdoZW4gbG9uZy1wb2xscyBhcnJpdmUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgdGhhbiB3ZSBzdGFydGVkIHRoZW0uIFRoZVxyXG4gICAgICAgIC8vICAgIHNlcnZlciBuZWVkcyB0byByZWxlYXNlIGJvdGggcG9sbHMgaW4gdGhpcyBjYXNlIG9yIGl0IHdpbGwgY2F1c2UgcHJvYmxlbXMgaW4gT3BlcmEgc2luY2UgT3BlcmEgY2FuIG9ubHkgZXhlY3V0ZVxyXG4gICAgICAgIC8vICAgIEpTT05QIGNvZGUgaW4gdGhlIG9yZGVyIGl0IHdhcyBhZGRlZCB0byB0aGUgaWZyYW1lLlxyXG4gICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XHJcbiAgICAgICAgLy8gVGhpcyBnZXRzIHNldCB0byBmYWxzZSB3aGVuIHdlJ3JlIFwiY2xvc2luZyBkb3duXCIgdGhlIGNvbm5lY3Rpb24gKGUuZy4gd2UncmUgc3dpdGNoaW5nIHRyYW5zcG9ydHMgYnV0IHRoZXJlJ3Mgc3RpbGxcclxuICAgICAgICAvLyBpbmNvbWluZyBkYXRhIGZyb20gdGhlIHNlcnZlciB0aGF0IHdlJ3JlIHdhaXRpbmcgZm9yKS5cclxuICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICAvL0VhY2ggc2NyaXB0IGhvbGRlciByZWdpc3RlcnMgYSBjb3VwbGUgb2YgdW5pcXVlbHkgbmFtZWQgY2FsbGJhY2tzIHdpdGggdGhlIHdpbmRvdy4gVGhlc2UgYXJlIGNhbGxlZCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcclxuICAgICAgICAgICAgLy8gICAxKSBDb21tYW5kIENhbGxiYWNrIC0gVHJpZ2dlcmVkIGZvciBjb250cm9sIGlzc3VlcywgbGlrZSBzdGFydGluZyBhIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICAgIC8vICAgMikgTWVzc2FnZSBDYWxsYmFjayAtIFRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGFycml2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gTFVJREdlbmVyYXRvcigpO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID1cclxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZUNCO1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhbiBpZnJhbWUgZm9yIHVzIHRvIGFkZCBzY3JpcHQgdGFncyB0by5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZSA9IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLmNyZWF0ZUlGcmFtZV8oKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpZnJhbWUncyBjb250ZW50cy5cclxuICAgICAgICAgICAgbGV0IHNjcmlwdCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBzZXQgYSBqYXZhc2NyaXB0IHVybCwgaXQncyBJRSBhbmQgd2UgbmVlZCB0byBzZXQgdGhlIGRvY3VtZW50IGRvbWFpbi4gVGhlIGphdmFzY3JpcHQgdXJsIGlzIHN1ZmZpY2llbnRcclxuICAgICAgICAgICAgLy8gZm9yIGllOSwgYnV0IGllOCBuZWVkcyB0byBkbyBpdCBhZ2FpbiBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5teUlGcmFtZS5zcmMgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuc3JjLnN1YnN0cigwLCAnamF2YXNjcmlwdDonLmxlbmd0aCkgPT09ICdqYXZhc2NyaXB0OicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgY3VycmVudERvbWFpbiArICdcIjs8L3NjcmlwdD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZUNvbnRlbnRzID0gJzxodG1sPjxib2R5PicgKyBzY3JpcHQgKyAnPC9ib2R5PjwvaHRtbD4nO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mud3JpdGUoaWZyYW1lQ29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nKCdmcmFtZSB3cml0aW5nIGV4Y2VwdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coZS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2coZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZENCID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUNCID0gb25NZXNzYWdlQ0I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIGJyb3dzZXIgaGFzIGl0cyBvd24gZnVubnkgd2F5IHRvIGhhbmRsZSBpZnJhbWVzLiBIZXJlIHdlIG11c2ggdGhlbSBhbGwgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0IHRoYXQgSSBjYW5cclxuICAgICAqIGFjdHVhbGx5IHVzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlGcmFtZV8oKSB7XHJcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgaW5zaWRlIHRoZSBpZnJhbWVcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gbW9kaWZpZWQgaW4gSUUsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciwgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZG9tYWluIG9mIHRoZSBpZnJhbWUncyBkb2N1bWVudCBtYW51YWxseS4gV2UgY2FuIGRvIHRoaXMgdmlhIGEgamF2YXNjcmlwdDogdXJsIGFzIHRoZSBzcmMgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCB3ZSBtdXN0IGRvIHRoaXMgKmFmdGVyKiB0aGUgaWZyYW1lIGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBwYWdlLiBPdGhlcndpc2UgaXQgZG9lc24ndCB3b3JrLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBvbG9naWVzIGZvciB0aGUgbG9nLXNwYW0sIEkgbmVlZCB0byBkbyBzb21ldGhpbmcgdG8ga2VlcCBjbG9zdXJlIGZyb20gb3B0aW1pemluZyBvdXQgdGhlIGFzc2lnbm1lbnQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3JjID1cclxuICAgICAgICAgICAgICAgICAgICBcImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExvbmdQb2xsQ29ubmVjdGlvbiBhdHRlbXB0cyB0byBkZWxheSBpbml0aWFsaXphdGlvbiB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIHNvIGhvcGVmdWxseSB0aGlzXHJcbiAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgaGl0LlxyXG4gICAgICAgICAgICB0aHJvdyAnRG9jdW1lbnQgYm9keSBoYXMgbm90IGluaXRpYWxpemVkLiBXYWl0IHRvIGluaXRpYWxpemUgRmlyZWJhc2UgdW50aWwgYWZ0ZXIgdGhlIGRvY3VtZW50IGlzIHJlYWR5Lic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCB0aGUgZG9jdW1lbnQgb2YgdGhlIGlmcmFtZSBpbiBhIGJyb3dzZXItc3BlY2lmaWMgd2F5LlxyXG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50OyAvLyBGaXJlZm94LCBPcGVyYSwgU2FmYXJpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5jb250ZW50V2luZG93KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWZyYW1lLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuZG9jdW1lbnQ7IC8vb3RoZXJzP1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWZyYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIC8vTWFyayB0aGlzIGlmcmFtZSBhcyBkZWFkLCBzbyBubyBuZXcgcmVxdWVzdHMgYXJlIHNlbnQuXHJcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XHJcbiAgICAgICAgICAgIC8vV2UgaGF2ZSB0byBhY3R1YWxseSByZW1vdmUgYWxsIG9mIHRoZSBodG1sIGluc2lkZSB0aGlzIGlmcmFtZSBiZWZvcmUgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy93aW5kb3csIG9yIElFIHdpbGwgY29udGludWUgbG9hZGluZyBhbmQgZXhlY3V0aW5nIHRoZSBzY3JpcHQgdGFncyB3ZSd2ZSBhbHJlYWR5IGFkZGVkLCB3aGljaFxyXG4gICAgICAgICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyB0ZXh0Q29udGVudCBzZWVtcyB0byBiZSB0aGUgc2FmZXN0IHdheSB0byBkbyB0aGlzLlxyXG4gICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LnRleHRDb250ZW50ID0gJyc7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubXlJRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvdGVjdCBmcm9tIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseS5cclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdDtcclxuICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBzdGFydCB0aGUgbG9uZy1wb2xsaW5nIHNlc3Npb24gYnkgYWRkaW5nIHRoZSBmaXJzdCBzY3JpcHQgdGFnKHMpIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcHcgLSBUaGUgcGFzc3dvcmQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBzdGFydExvbmdQb2xsKGlkLCBwdykge1xyXG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xyXG4gICAgICAgIHRoaXMubXlQVyA9IHB3O1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8vc2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0LiBJZiB0aGVyZSBhcmUgcmVxdWVzdHMgcXVldWVkLCBtYWtlIHN1cmUgdGhhdCB3ZSB0cmFuc21pdCBhcyBtYW55IGFzIHdlIGFyZSBjdXJyZW50bHkgYWJsZSB0by5cclxuICAgICAgICB3aGlsZSAodGhpcy5uZXdSZXF1ZXN0XygpKSB7IH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYW55IHRpbWUgc29tZW9uZSBtaWdodCB3YW50IGEgc2NyaXB0IHRhZyB0byBiZSBhZGRlZC4gSXQgYWRkcyBhIHNjcmlwdCB0YWcgd2hlbiB0aGVyZSBhcmVuJ3RcclxuICAgICAqIHRvbyBtYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzIGFuZCB3ZSBhcmUgc3RpbGwgYWxpdmUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlcmUgYXJlIG91dHN0YW5kaW5nIHBhY2tldCBzZWdtZW50cyB0byBzZW5kLCBpdCBzZW5kcyBvbmUuIElmIHRoZXJlIGFyZW4ndCwgaXQgc2VuZHMgYSBsb25nLXBvbGwgYW55d2F5cyBpZlxyXG4gICAgICogbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBuZXdSZXF1ZXN0XygpIHtcclxuICAgICAgICAvLyBXZSBrZWVwIG9uZSBvdXRzdGFuZGluZyByZXF1ZXN0IG9wZW4gYWxsIHRoZSB0aW1lIHRvIHJlY2VpdmUgZGF0YSwgYnV0IGlmIHdlIG5lZWQgdG8gc2VuZCBkYXRhXHJcbiAgICAgICAgLy8gKHBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHRoZW4gd2UgY3JlYXRlIGEgbmV3IHJlcXVlc3QgdG8gc2VuZCB0aGUgZGF0YS4gIFRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgLy8gY2xvc2UgdGhlIG9sZCByZXF1ZXN0LlxyXG4gICAgICAgIGlmICh0aGlzLmFsaXZlICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE5ld1BvbGxzICYmXHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5zaXplIDwgKHRoaXMucGVuZGluZ1NlZ3MubGVuZ3RoID4gMCA/IDIgOiAxKSkge1xyXG4gICAgICAgICAgICAvL2NvbnN0cnVjdCBvdXIgdXJsXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCsrO1xyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IHRoaXMubXlJRDtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHRoaXMubXlQVztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSB0aGlzLmN1cnJlbnRTZXJpYWw7XHJcbiAgICAgICAgICAgIGxldCB0aGVVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIC8vTm93IGFkZCBhcyBtdWNoIGRhdGEgYXMgd2UgY2FuLlxyXG4gICAgICAgICAgICBsZXQgY3VyRGF0YVN0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vZmlyc3QsIGxldHMgc2VlIGlmIHRoZSBuZXh0IHNlZ21lbnQgd2lsbCBmaXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VnID0gdGhpcy5wZW5kaW5nU2Vnc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VnLmQubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICAgICBTRUdfSEVBREVSX1NJWkUgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XHJcbiAgICAgICAgICAgICAgICAgICAgTUFYX1VSTF9EQVRBX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dyZWF0LCB0aGUgc2VnbWVudCB3aWxsIGZpdC4gTGV0cyBhcHBlbmQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlU2VnID0gdGhpcy5wZW5kaW5nU2Vncy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuc2VnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnRzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoZVVSTCA9IHRoZVVSTCArIGN1ckRhdGFTdHJpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTG9uZ1BvbGxUYWdfKHRoZVVSTCwgdGhpcy5jdXJyZW50U2VyaWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZSBhIHBhY2tldCBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gc2VnbnVtIC0gQSBzZXF1ZW50aWFsIGlkIGZvciB0aGlzIHBhY2tldCBzZWdtZW50IHVzZWQgZm9yIHJlYXNzZW1ibHlcclxuICAgICAqIEBwYXJhbSB0b3RhbHNlZ3MgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGFja2V0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVTZWdtZW50KHNlZ251bSwgdG90YWxzZWdzLCBkYXRhKSB7XHJcbiAgICAgICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzLnB1c2goeyBzZWc6IHNlZ251bSwgdHM6IHRvdGFsc2VncywgZDogZGF0YSB9KTtcclxuICAgICAgICAvL3NlbmQgdGhlIGRhdGEgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBkYXRhIGJlaW5nIHRyYW5zbWl0dGVkLCB1bmxlc3NcclxuICAgICAgICAvL3N0YXJ0TG9uZ1BvbGwgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld1JlcXVlc3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY3JpcHQgdGFnIGZvciBhIHJlZ3VsYXIgbG9uZy1wb2xsIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRhZy5cclxuICAgICAqIEBwYXJhbSBzZXJpYWwgLSBUaGUgc2VyaWFsIG51bWJlciBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgYWRkTG9uZ1BvbGxUYWdfKHVybCwgc2VyaWFsKSB7XHJcbiAgICAgICAgLy9yZW1lbWJlciB0aGF0IHdlIHNlbnQgdGhpcyByZXF1ZXN0LlxyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsKTtcclxuICAgICAgICBjb25zdCBkb05ld1JlcXVlc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5kZWxldGUoc2VyaWFsKTtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSWYgdGhpcyByZXF1ZXN0IGRvZXNuJ3QgcmV0dXJuIG9uIGl0cyBvd24gYWNjb3JkIChieSB0aGUgc2VydmVyIHNlbmRpbmcgdXMgc29tZSBkYXRhKSwgd2UnbGxcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxyXG4gICAgICAgIGNvbnN0IGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvTmV3UmVxdWVzdCwgTWF0aC5mbG9vcihLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCkpO1xyXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDQiA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb21wbGV0ZWQuICBDYW5jZWwgdGhlIGtlZXBhbGl2ZS5cclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGEgbmV3IHJlcXVlc3Qgc28gd2UgY2FuIGNvbnRpbnVlIHJlY2VpdmluZyBkYXRhLlxyXG4gICAgICAgICAgICBkb05ld1JlcXVlc3QoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkVGFnKHVybCwgcmVhZHlTdGF0ZUNCKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFyYml0cmFyeSBzY3JpcHQgdGFnIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBmb3IgdGhlIHNjcmlwdCB0YWcgc291cmNlLlxyXG4gICAgICogQHBhcmFtIGxvYWRDQiAtIEEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIHNjcmlwdCBoYXMgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBhZGRUYWcodXJsLCBsb2FkQ0IpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgdGhpcy5kb05vZGVMb25nUG9sbCh1cmwsIGxvYWRDQik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYWxyZWFkeSBjbG9zZWQsIGRvbid0IGFkZCB0aGlzIHBvbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VuZE5ld1BvbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NyaXB0ID0gdGhpcy5teUlGcmFtZS5kb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByc3RhdGUgPSBuZXdTY3JpcHQucmVhZHlTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnN0YXRlIHx8IHJzdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgcnN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NjcmlwdC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDQigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmFwcGVuZENoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3VycmVudGx5IHNpbXBsaXN0aWMsIHRoaXMgY2xhc3MgbWFuYWdlcyB3aGF0IHRyYW5zcG9ydCBhIENvbm5lY3Rpb24gc2hvdWxkIHVzZSBhdCB2YXJpb3VzIHN0YWdlcyBvZiBpdHNcclxuICogbGlmZWN5Y2xlLlxyXG4gKlxyXG4gKiBJdCBzdGFydHMgd2l0aCBsb25ncG9sbGluZyBpbiBhIGJyb3dzZXIsIGFuZCBodHRwcG9sbGluZyBvbiBub2RlLiBJdCB0aGVuIHVwZ3JhZGVzIHRvIHdlYnNvY2tldHMgaWZcclxuICogdGhleSBhcmUgYXZhaWxhYmxlLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNwb3J0TWFuYWdlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyAtIE1ldGFkYXRhIGFyb3VuZCB0aGUgbmFtZXNwYWNlIHdlJ3JlIGNvbm5lY3RpbmcgdG9cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm8pIHtcclxuICAgICAgICB0aGlzLmluaXRUcmFuc3BvcnRzXyhyZXBvSW5mbyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEFMTF9UUkFOU1BPUlRTKCkge1xyXG4gICAgICAgIHJldHVybiBbQnJvd3NlclBvbGxDb25uZWN0aW9uLCBXZWJTb2NrZXRDb25uZWN0aW9uXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRyYW5zcG9ydCBoYXMgYmVlbiBzZWxlY3RlZCB0byBlbnN1cmUgV2ViU29ja2V0Q29ubmVjdGlvbiBvciBCcm93c2VyUG9sbENvbm5lY3Rpb24gYXJlIG5vdCBjYWxsZWQgYWZ0ZXJcclxuICAgICAqIFRyYW5zcG9ydE1hbmFnZXIgaGFzIGFscmVhZHkgc2V0IHVwIHRyYW5zcG9ydHNfXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgSVNfVFJBTlNQT1JUX0lOSVRJQUxJWkVEKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXztcclxuICAgIH1cclxuICAgIGluaXRUcmFuc3BvcnRzXyhyZXBvSW5mbykge1xyXG4gICAgICAgIGNvbnN0IGlzV2ViU29ja2V0c0F2YWlsYWJsZSA9IFdlYlNvY2tldENvbm5lY3Rpb24gJiYgV2ViU29ja2V0Q29ubmVjdGlvblsnaXNBdmFpbGFibGUnXSgpO1xyXG4gICAgICAgIGxldCBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IGlzV2ViU29ja2V0c0F2YWlsYWJsZSAmJiAhV2ViU29ja2V0Q29ubmVjdGlvbi5wcmV2aW91c2x5RmFpbGVkKCk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvLndlYlNvY2tldE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1dlYlNvY2tldHNBdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlzU2tpcFBvbGxDb25uZWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU2tpcFBvbGxDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0c18gPSBbV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnRzID0gKHRoaXMudHJhbnNwb3J0c18gPSBbXSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIFRyYW5zcG9ydE1hbmFnZXIuQUxMX1RSQU5TUE9SVFMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0Wydpc0F2YWlsYWJsZSddKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmFuc3BvcnRNYW5hZ2VyLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBpbml0aWFsIHRyYW5zcG9ydCB0byB1c2VcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbFRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV4dCB0cmFuc3BvcnQsIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgdXBncmFkZVRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIFRyYW5zcG9ydE1hbmFnZXIgaGFzIGFscmVhZHkgY2hvc2VuIGEgdHJhbnNwb3J0IHRvIHVzZVxyXG5UcmFuc3BvcnRNYW5hZ2VyLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXyA9IGZhbHNlO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBBYm9ydCB1cGdyYWRlIGF0dGVtcHQgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gNjBzLlxyXG5jb25zdCBVUEdSQURFX1RJTUVPVVQgPSA2MDAwMDtcclxuLy8gRm9yIHNvbWUgdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gXCJ2YWxpZGF0ZVwiIHRoZSB0cmFuc3BvcnQgYnkgZXhjaGFuZ2luZyBhIGZldyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLlxyXG4vLyBJZiB3ZSBoYXZlbid0IHNlbnQgZW5vdWdoIHJlcXVlc3RzIHdpdGhpbiA1cywgd2UnbGwgc3RhcnQgc2VuZGluZyBub29wIHBpbmcgcmVxdWVzdHMuXHJcbmNvbnN0IERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTID0gNTAwMDtcclxuLy8gSWYgdGhlIGluaXRpYWwgZGF0YSBzZW50IHRyaWdnZXJzIGEgbG90IG9mIGJhbmR3aWR0aCAoaS5lLiBpdCdzIGEgbGFyZ2UgcHV0IG9yIGEgbGlzdGVuIGZvciBhIGxhcmdlIGFtb3VudCBvZiBkYXRhKVxyXG4vLyB0aGVuIHdlIG1heSBub3QgYmUgYWJsZSB0byBleGNoYW5nZSBvdXIgcGluZy9wb25nIHJlcXVlc3RzIHdpdGhpbiB0aGUgaGVhbHRoeSB0aW1lb3V0LiAgU28gaWYgd2UgcmVhY2ggdGhlIHRpbWVvdXRcclxuLy8gYnV0IHdlJ3ZlIHNlbnQvcmVjZWl2ZWQgZW5vdWdoIGJ5dGVzLCB3ZSBkb24ndCBjYW5jZWwgdGhlIGNvbm5lY3Rpb24uXHJcbmNvbnN0IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSA9IDEwICogMTAyNDtcclxuY29uc3QgQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSA9IDEwMCAqIDEwMjQ7XHJcbmNvbnN0IE1FU1NBR0VfVFlQRSA9ICd0JztcclxuY29uc3QgTUVTU0FHRV9EQVRBID0gJ2QnO1xyXG5jb25zdCBDT05UUk9MX1NIVVRET1dOID0gJ3MnO1xyXG5jb25zdCBDT05UUk9MX1JFU0VUID0gJ3InO1xyXG5jb25zdCBDT05UUk9MX0VSUk9SID0gJ2UnO1xyXG5jb25zdCBDT05UUk9MX1BPTkcgPSAnbyc7XHJcbmNvbnN0IFNXSVRDSF9BQ0sgPSAnYSc7XHJcbmNvbnN0IEVORF9UUkFOU01JU1NJT04gPSAnbic7XHJcbmNvbnN0IFBJTkcgPSAncCc7XHJcbmNvbnN0IFNFUlZFUl9IRUxMTyA9ICdoJztcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcmVhbC10aW1lIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciB1c2luZyB3aGljaGV2ZXIgbWV0aG9kIHdvcmtzXHJcbiAqIGJlc3QgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cclxuICovXHJcbmNsYXNzIENvbm5lY3Rpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBhbiBpZCBmb3IgdGhpcyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gdGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBjb25uZWN0IHRvXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZF8gLSB0aGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3RcclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuXyAtIFRoZSBBcHAgQ2hlY2sgVG9rZW4gZm9yIHRoaXMgZGV2aWNlLlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbl8gLSBUaGUgYXV0aCB0b2tlbiBmb3IgdGhpcyBzZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gYSBzZXJ2ZXItcHVzaCBtZXNzYWdlIGFycml2ZXNcclxuICAgICAqIEBwYXJhbSBvblJlYWR5XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIGNvbm5lY3Rpb24gaXMgcmVhZHkgdG8gc2VuZCBtZXNzYWdlcy5cclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3RfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29ubmVjdGlvbiB3YXMgbG9zdFxyXG4gICAgICogQHBhcmFtIG9uS2lsbF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGhhcyBwZXJtYW5lbnRseSBzaHV0IGRvd24uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIGxhc3Qgc2Vzc2lvbiBpZCBpbiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24uIGlzIHVzZWQgdG8gY2xlYW4gdXAgb2xkIHNlc3Npb24gaW4gcmVhbC10aW1lIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcmVwb0luZm9fLCBhcHBsaWNhdGlvbklkXywgYXBwQ2hlY2tUb2tlbl8sIGF1dGhUb2tlbl8sIG9uTWVzc2FnZV8sIG9uUmVhZHlfLCBvbkRpc2Nvbm5lY3RfLCBvbktpbGxfLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gYXBwQ2hlY2tUb2tlbl87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gYXV0aFRva2VuXztcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xyXG4gICAgICAgIHRoaXMub25SZWFkeV8gPSBvblJlYWR5XztcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3RfO1xyXG4gICAgICAgIHRoaXMub25LaWxsXyA9IG9uS2lsbF87XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfID0gbmV3IFRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm9fKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gY3JlYXRlZCcpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFxyXG4gICAgICovXHJcbiAgICBzdGFydF8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8uaW5pdGlhbFRyYW5zcG9ydCgpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBuZXcgY29ubih0aGlzLm5leHRUcmFuc3BvcnRJZF8oKSwgdGhpcy5yZXBvSW5mb18sIHRoaXMuYXBwbGljYXRpb25JZF8sIHRoaXMuYXBwQ2hlY2tUb2tlbl8sIHRoaXMuYXV0aFRva2VuXywgbnVsbCwgdGhpcy5sYXN0U2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPSBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2VSZWNlaXZlZCA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkNvbm5lY3Rpb25Mb3N0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xyXG4gICAgICAgIHRoaXMudHhfID0gdGhpcy5jb25uXztcclxuICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gZmFsc2U7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBGaXJlZm94IGRvZXNuJ3QgbGlrZSB3aGVuIGNvZGUgZnJvbSBvbmUgaWZyYW1lIHRyaWVzIHRvIGNyZWF0ZSBhbm90aGVyIGlmcmFtZSBieSB3YXkgb2YgdGhlIHBhcmVudCBmcmFtZS5cclxuICAgICAgICAgKiBUaGlzIGNhbiBvY2N1ciBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0LCBpLmUuIHdlIGd1ZXNzZWQgd3Jvbmcgb24gd2hhdCBzZXJ2ZXIgdG8gY29ubmVjdCB0byBhbmQgcmVjZWl2ZWQgYSByZXNldC5cclxuICAgICAgICAgKiBTb21laG93LCBzZXRUaW1lb3V0IHNlZW1zIHRvIG1ha2UgdGhpcyBvay4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZnJvbSBhIHNlY3VyaXR5IHBlcnNwZWN0aXZlLCBzaW5jZSB5b3Ugc2hvdWxkXHJcbiAgICAgICAgICogc3RpbGwgaGF2ZSB0aGUgY29udGV4dCBvZiB5b3VyIG9yaWdpbmF0aW5nIGZyYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNvbm5fIGdldHMgc2V0IHRvIG51bGwgaW4gc29tZSBvZiB0aGUgdGVzdHMuIENoZWNrIHRvIG1ha2Ugc3VyZSBpdCBzdGlsbCBleGlzdHMgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gJiYgdGhpcy5jb25uXy5vcGVuKG9uTWVzc2FnZVJlY2VpdmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICBjb25zdCBoZWFsdGh5VGltZW91dE1TID0gY29ublsnaGVhbHRoeVRpbWVvdXQnXSB8fCAwO1xyXG4gICAgICAgIGlmIChoZWFsdGh5VGltZW91dE1TID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IHNldFRpbWVvdXROb25CbG9ja2luZygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5fICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCA+IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCA+IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNTZW50ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IHdhbnQgdG8gbWFyayBpdCBoZWFsdGh5LCBzaW5jZSB3ZSBoYXZlIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBieXRlcyBoYXZlIG1hZGUgaXQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihoZWFsdGh5VGltZW91dE1TKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV4dFRyYW5zcG9ydElkXygpIHtcclxuICAgICAgICByZXR1cm4gJ2M6JyArIHRoaXMuaWQgKyAnOicgKyB0aGlzLmNvbm5lY3Rpb25Db3VudCsrO1xyXG4gICAgfVxyXG4gICAgZGlzY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJDb25uZWN0ZWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29ubiA9PT0gdGhpcy5jb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1NlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2Nsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25uUmVjZWl2ZXJfKGNvbm4pIHtcclxuICAgICAgICByZXR1cm4gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ubiA9PT0gdGhpcy5yeF8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ21lc3NhZ2Ugb24gb2xkIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkYXRhTXNnIC0gQW4gYXJiaXRyYXJ5IGRhdGEgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgc2VuZFJlcXVlc3QoZGF0YU1zZykge1xyXG4gICAgICAgIC8vIHdyYXAgaW4gYSBkYXRhIG1lc3NhZ2UgZW52ZWxvcGUgYW5kIHNlbmQgaXQgb25cclxuICAgICAgICBjb25zdCBtc2cgPSB7IHQ6ICdkJywgZDogZGF0YU1zZyB9O1xyXG4gICAgICAgIHRoaXMuc2VuZERhdGFfKG1zZyk7XHJcbiAgICB9XHJcbiAgICB0cnlDbGVhbnVwQ29ubmVjdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gJiYgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogJyArIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY29ubklkKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgICAgICAvLyB0aGUgc2VydmVyIHdpbGwgc2h1dGRvd24gdGhlIG9sZCBjb25uZWN0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWNvbmRhcnlDb250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGlmIChNRVNTQUdFX1RZUEUgaW4gY29udHJvbERhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgY21kID0gY29udHJvbERhdGFbTUVTU0FHRV9UWVBFXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU1dJVENIX0FDSykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgdGhlIHNlc3Npb24gd2Fzbid0IHZhbGlkLiBBYmFuZG9uIHRoZSBzd2l0Y2ggYXR0ZW1wdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgYWxyZWFkeSB1c2luZyB0aGlzIGNvbm5lY3Rpb24gZm9yIHNvbWV0aGluZywgdGhhbiB3ZSBuZWVkIHRvIGZ1bGx5IGNsb3NlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ4XyA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUE9ORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBzZWNvbmRhcnkuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXy0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKHBhcnNlZERhdGEpIHtcclxuICAgICAgICBjb25zdCBsYXllciA9IHJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gcmVxdWlyZUtleSgnZCcsIHBhcnNlZERhdGEpO1xyXG4gICAgICAgIGlmIChsYXllciA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlDb250cm9sXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT09ICdkJykge1xyXG4gICAgICAgICAgICAvLyBnb3QgYSBkYXRhIG1lc3NhZ2UsIGJ1dCB3ZSdyZSBzdGlsbCBzZWNvbmQgY29ubmVjdGlvbi4gTmVlZCB0byBidWZmZXIgaXQgdXBcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvdG9jb2wgbGF5ZXI6ICcgKyBsYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2NlZWRXaXRoVXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNlbmQgYSBwaW5nIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlxyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2NlZWRXaXRoVXBncmFkZV8oKSB7XHJcbiAgICAgICAgLy8gdGVsbCB0aGlzIGNvbm5lY3Rpb24gdG8gY29uc2lkZXIgaXRzZWxmIG9wZW5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgLy8gc2VuZCBhY2tcclxuICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnknKTtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogU1dJVENIX0FDSywgZDoge30gfSB9KTtcclxuICAgICAgICAvLyBzZW5kIGVuZCBwYWNrZXQgb24gcHJpbWFyeSB0cmFuc3BvcnQsIHN3aXRjaCB0byBzZW5kaW5nIG9uIHRoaXMgb25lXHJcbiAgICAgICAgLy8gY2FuIHJlY2VpdmUgb24gdGhpcyBvbmUsIGJ1ZmZlciByZXNwb25zZXMgdW50aWwgZW5kIHJlY2VpdmVkIG9uIHByaW1hcnkgdHJhbnNwb3J0XHJcbiAgICAgICAgdGhpcy5sb2dfKCdFbmRpbmcgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICB0aGlzLmNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogRU5EX1RSQU5TTUlTU0lPTiwgZDoge30gfSB9KTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XHJcbiAgICAgICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgb25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgLy8gTXVzdCByZWZlciB0byBwYXJzZWREYXRhIHByb3BlcnRpZXMgaW4gcXVvdGVzLCBzbyBjbG9zdXJlIGRvZXNuJ3QgdG91Y2ggdGhlbS5cclxuICAgICAgICBjb25zdCBsYXllciA9IHJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gcmVxdWlyZUtleSgnZCcsIHBhcnNlZERhdGEpO1xyXG4gICAgICAgIGlmIChsYXllciA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT09ICdkJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YU1lc3NhZ2VfKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIHdpdGggZGF0YSBtZXNzYWdlcywganVzdCBraWNrIHRoZW0gdXAgYSBsZXZlbFxyXG4gICAgICAgIHRoaXMub25NZXNzYWdlXyhtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeVJlc3BvbnNlXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbnRyb2xfKGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY21kID0gcmVxdWlyZUtleShNRVNTQUdFX1RZUEUsIGNvbnRyb2xEYXRhKTtcclxuICAgICAgICBpZiAoTUVTU0FHRV9EQVRBIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBjb250cm9sRGF0YVtNRVNTQUdFX0RBVEFdO1xyXG4gICAgICAgICAgICBpZiAoY21kID09PSBTRVJWRVJfSEVMTE8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRzaGFrZVBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5pc1VzaW5nRW11bGF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcG9uIGNvbm5lY3RpbmcsIHRoZSBlbXVsYXRvciB3aWxsIHBhc3MgdGhlIGhvc3RuYW1lIHRoYXQgaXQncyBhd2FyZSBvZiwgYnV0IHdlIHByZWZlciB0aGUgdXNlcidzIHNldCBob3N0bmFtZSB2aWEgYGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yYCBvdmVyIHdoYXQgdGhlIGVtdWxhdG9yIHBhc3Nlcy5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2VQYXlsb2FkLmggPSB0aGlzLnJlcG9JbmZvXy5ob3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRzaGFrZV8oaGFuZHNoYWtlUGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBFTkRfVFJBTlNNSVNTSU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ3JlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yeF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfU0hVVERPV04pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByZXZpb3VzbHkgdGhlICdvbktpbGwnIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUgbG93ZXItbGV2ZWwgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIHJlYXNvbiBmb3IgdGhlIHNodXRkb3duLiBHZW5lcmFsbHkgYSBodW1hbi1yZWFkYWJsZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TaHV0ZG93bl8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1JFU0VUKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgaG9zdCB3ZSBzaG91bGQgY29udGFjdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc2V0XyhwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfRVJST1IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKCdTZXJ2ZXIgRXJyb3I6ICcgKyBwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUE9ORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBwcmltYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKCdVbmtub3duIGNvbnRyb2wgcGFja2V0IGNvbW1hbmQ6ICcgKyBjbWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaGFuZHNoYWtlIC0gVGhlIGhhbmRzaGFrZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBvbkhhbmRzaGFrZV8oaGFuZHNoYWtlKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gaGFuZHNoYWtlLnRzO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBoYW5kc2hha2UudjtcclxuICAgICAgICBjb25zdCBob3N0ID0gaGFuZHNoYWtlLmg7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBoYW5kc2hha2UucztcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ID0gaG9zdDtcclxuICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IGNsb3NlZCB0aGUgY29ubmVjdGlvbiwgdGhlbiBkb24ndCBib3RoZXIgdHJ5aW5nIHRvIHByb2dyZXNzIGZ1cnRoZXJcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8odGhpcy5jb25uXywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgaWYgKFBST1RPQ09MX1ZFUlNJT04gIT09IHZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1Byb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHVwZ3JhZGU/IHdoZW4/IG1heWJlIGEgZGVsYXk/XHJcbiAgICAgICAgICAgIHRoaXMudHJ5U3RhcnRVcGdyYWRlXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyeVN0YXJ0VXBncmFkZV8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8udXBncmFkZVRyYW5zcG9ydCgpO1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRVcGdyYWRlXyhjb25uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydFVwZ3JhZGVfKGNvbm4pIHtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIHRoaXMuc2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9XHJcbiAgICAgICAgICAgIGNvbm5bJ3Jlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHknXSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5vcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHN1Y2Nlc3NmdWxseSB1cGdyYWRlZCBhZnRlciBVUEdSQURFX1RJTUVPVVQsIGdpdmUgdXAgYW5kIGtpbGwgdGhlIHNlY29uZGFyeS5cclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBNYXRoLmZsb29yKFVQR1JBREVfVElNRU9VVCkpO1xyXG4gICAgfVxyXG4gICAgb25SZXNldF8oaG9zdCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6ICcgKyBob3N0KTtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ID0gaG9zdDtcclxuICAgICAgICAvLyBUT0RPOiBpZiB3ZSdyZSBhbHJlYWR5IFwiY29ubmVjdGVkXCIsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGRpc2Nvbm5lY3QgYXQgdGhlIG5leHQgbGF5ZXIgdXAuXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgcmVzZXRzIGFmdGVyIHRoZSBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2xvc2Ugd2hhdGV2ZXIgY29ubmVjdGlvbnMgd2UgaGF2ZSBvcGVuIGFuZCBzdGFydCBhZ2Fpbi5cclxuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb25zXygpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyhjb25uLCB0aW1lc3RhbXApIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuJyk7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IGNvbm47XHJcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovO1xyXG4gICAgICAgIGlmICh0aGlzLm9uUmVhZHlfKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25SZWFkeV8odGltZXN0YW1wLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgIHRoaXMub25SZWFkeV8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhZnRlciA1IHNlY29uZHMgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgY29ubmVjdGlvbiBoZWFsdGh5LFxyXG4gICAgICAgIC8vIHNlbmQgc29tZSBwaW5ncy5cclxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXNuJ3QgY29uc2lkZXJlZCBoZWFsdGh5IHlldCwgd2UnbGwgc2VuZCBhIG5vb3AgcGluZyBwYWNrZXQgcmVxdWVzdC5cclxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5XyAmJiB0aGlzLnN0YXRlXyA9PT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBwcmltYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhXyh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnR4XyA9PT0gY29ubiB8fCB0aGlzLnJ4XyA9PT0gY29ubikge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBzb21lIGNhcGFjaXR5LiBUaGVyZWZvcmUsIGEgZmFpbHVyZSBpcyByZWFsXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBldmVyQ29ubmVjdGVkIC0gV2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gZXZlciByZWFjaGVkIGEgc2VydmVyLiBVc2VkIHRvIGRldGVybWluZSBpZlxyXG4gICAgICogd2Ugc2hvdWxkIGZsdXNoIHRoZSBob3N0IGNhY2hlXHJcbiAgICAgKi9cclxuICAgIG9uQ29ubmVjdGlvbkxvc3RfKGV2ZXJDb25uZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcclxuICAgICAgICAvLyBOT1RFOiBJRiB5b3UncmUgc2VlaW5nIGEgRmlyZWZveCBlcnJvciBmb3IgdGhpcyBsaW5lLCBJIHRoaW5rIGl0IG1pZ2h0IGJlIGJlY2F1c2UgaXQncyBnZXR0aW5nXHJcbiAgICAgICAgLy8gY2FsbGVkIG9uIHdpbmRvdyBjbG9zZSBhbmQgUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HIGlzIG5vIGxvbmdlciBkZWZpbmVkLiAgSnVzdCBhIGd1ZXNzLlxyXG4gICAgICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGZhaWxlZC4nKTtcclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZmFpbGVkIHRvIGNvbm5lY3QgYXQgYWxsLCBjbGVhciBhbnkgY2FjaGVkIGVudHJ5IGZvciB0aGlzIG5hbWVzcGFjZSBpbiBjYXNlIHRoZSBtYWNoaW5lIHdlbnQgYXdheVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNDYWNoZWFibGVIb3N0KCkpIHtcclxuICAgICAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgnaG9zdDonICsgdGhpcy5yZXBvSW5mb18uaG9zdCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgaW50ZXJuYWwgaG9zdCB0byB3aGF0IHdlIHdvdWxkIHNob3cgdGhlIHVzZXIsIGkuZS4gPG5zPi5maXJlYmFzZWlvLmNvbVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18uaW50ZXJuYWxIb3N0ID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlXyA9PT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgb25Db25uZWN0aW9uU2h1dGRvd25fKHJlYXNvbikge1xyXG4gICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uJyk7XHJcbiAgICAgICAgaWYgKHRoaXMub25LaWxsXykge1xyXG4gICAgICAgICAgICB0aGlzLm9uS2lsbF8ocmVhc29uKTtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB3YW50IHRvIGZpcmUgb25EaXNjb25uZWN0IChraWxsIGlzIGEgZGlmZmVyZW50IGNhc2UpLFxyXG4gICAgICAgIC8vIHNvIGNsZWFyIHRoZSBjYWxsYmFjay5cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIHNlbmREYXRhXyhkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50eF8uc2VuZChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyB1cCB0aGlzIGNvbm5lY3Rpb24sIGNhbGxpbmcgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLztcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb25zXygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9zZUNvbm5lY3Rpb25zXygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1NodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoeVRpbWVvdXRfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYWx0aHlUaW1lb3V0Xyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVyZmFjZSBkZWZpbmluZyB0aGUgc2V0IG9mIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIEZpcmViYXNlIHNlcnZlclxyXG4gKiAoYmFzaWNhbGx5IGNvcnJlc3BvbmRzIHRvIG91ciB3aXJlIHByb3RvY29sKS5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgU2VydmVyQWN0aW9ucyB7XHJcbiAgICBwdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhdXRoIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRva2VuIC0gVGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFwcCBjaGVjayB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYXBwIGNoZWNrIHRva2VuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdFB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdE1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHsgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHsgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHsgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIHRvIGJlIHVzZWQgaWYgeW91IHdhbnQgdG8gZW1pdCBldmVudHMuIENhbGwgdGhlIGNvbnN0cnVjdG9yIHdpdGhcclxuICogdGhlIHNldCBvZiBhbGxvd2VkIGV2ZW50IG5hbWVzLlxyXG4gKi9cclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFsbG93ZWRFdmVudHNfKSB7XHJcbiAgICAgICAgdGhpcy5hbGxvd2VkRXZlbnRzXyA9IGFsbG93ZWRFdmVudHNfO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzXyA9IHt9O1xyXG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KGFsbG93ZWRFdmVudHNfKSAmJiBhbGxvd2VkRXZlbnRzXy5sZW5ndGggPiAwLCAnUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXknKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gYmUgY2FsbGVkIGJ5IGRlcml2ZWQgY2xhc3NlcyB0byB0cmlnZ2VyIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgdHJpZ2dlcihldmVudFR5cGUsIC4uLnZhckFyZ3MpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSkpIHtcclxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGxpc3QsIHNpbmNlIGNhbGxiYWNrcyBjb3VsZCBhZGQvcmVtb3ZlIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gWy4uLnRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjay5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgdmFyQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbihldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnB1c2goeyBjYWxsYmFjaywgY29udGV4dCB9KTtcclxuICAgICAgICBjb25zdCBldmVudERhdGEgPSB0aGlzLmdldEluaXRpYWxFdmVudChldmVudFR5cGUpO1xyXG4gICAgICAgIGlmIChldmVudERhdGEpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgZXZlbnREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gfHwgW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgICAgICghY29udGV4dCB8fCBjb250ZXh0ID09PSBsaXN0ZW5lcnNbaV0uY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuYWxsb3dlZEV2ZW50c18uZmluZChldCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBldCA9PT0gZXZlbnRUeXBlO1xyXG4gICAgICAgIH0pLCAnVW5rbm93biBldmVudDogJyArIGV2ZW50VHlwZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXHJcbiAqXHJcbiAqIFRoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHRoaXMgY291bGQgaGF2ZSBtYW55IGZhbHNlIHBvc2l0aXZlcyAodGhpbmtzIHdlIGFyZSBvbmxpbmVcclxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cclxuICogd2UgZGVmaW5pdGVseSBjYW5ub3QgcmVhY2ggdGhlIGludGVybmV0LlxyXG4gKi9cclxuY2xhc3MgT25saW5lTW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ29ubGluZSddKTtcclxuICAgICAgICB0aGlzLm9ubGluZV8gPSB0cnVlO1xyXG4gICAgICAgIC8vIFdlJ3ZlIGhhZCByZXBlYXRlZCBjb21wbGFpbnRzIHRoYXQgQ29yZG92YSBhcHBzIGNhbiBnZXQgc3R1Y2sgXCJvZmZsaW5lXCIsIGUuZy5cclxuICAgICAgICAvLyBodHRwczovL2ZvcnVtLmlvbmljZnJhbWV3b3JrLmNvbS90L2ZpcmViYXNlLWNvbm5lY3Rpb24taXMtbG9zdC1hbmQtbmV2ZXItY29tZS1iYWNrLzQzODEwXHJcbiAgICAgICAgLy8gSXQgd291bGQgc2VlbSB0aGF0IHRoZSAnb25saW5lJyBldmVudCBkb2VzIG5vdCBhbHdheXMgZmlyZSBjb25zaXN0ZW50bHkuIFNvIHdlIGRpc2FibGUgaXRcclxuICAgICAgICAvLyBmb3IgQ29yZG92YS5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAhaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vbmxpbmVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb25saW5lJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT25saW5lTW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICdvbmxpbmUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcclxuICAgICAgICByZXR1cm4gW3RoaXMub25saW5lX107XHJcbiAgICB9XHJcbiAgICBjdXJyZW50bHlPbmxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25saW5lXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogTWF4aW11bSBrZXkgZGVwdGguICovXHJcbmNvbnN0IE1BWF9QQVRIX0RFUFRIID0gMzI7XHJcbi8qKiBNYXhpbXVtIG51bWJlciBvZiAoVVRGOCkgYnl0ZXMgaW4gYSBGaXJlYmFzZSBwYXRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9MRU5HVEhfQllURVMgPSA3Njg7XHJcbi8qKlxyXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcclxuICogY2FuIHBhc3MgdGhlbSBhcm91bmQgdG8gb3RoZXIgZnVuY3Rpb25zIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgdGhlbSBjaGFuZ2luZ1xyXG4gKiBpdC5cclxuICovXHJcbmNsYXNzIFBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aE9yU3RyaW5nIC0gUGF0aCBzdHJpbmcgdG8gcGFyc2UsIG9yIGFub3RoZXIgcGF0aCwgb3IgdGhlIHJhd1xyXG4gICAgICogdG9rZW5zIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGhPclN0cmluZywgcGllY2VOdW0pIHtcclxuICAgICAgICBpZiAocGllY2VOdW0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cclxuICAgICAgICAgICAgbGV0IGNvcHlUbyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpZWNlc19bY29weVRvXSA9IHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5VG8rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18ubGVuZ3RoID0gY29weVRvO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmc7XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VOdW1fID0gcGllY2VOdW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5waWVjZU51bV87IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgdGhpcy5waWVjZXNfW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdFbXB0eVBhdGgoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhdGgoJycpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRGcm9udChwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGgucGllY2VzX1twYXRoLnBpZWNlTnVtX107XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoR2V0TGVuZ3RoKHBhdGgpIHtcclxuICAgIHJldHVybiBwYXRoLnBpZWNlc18ubGVuZ3RoIC0gcGF0aC5waWVjZU51bV87XHJcbn1cclxuZnVuY3Rpb24gcGF0aFBvcEZyb250KHBhdGgpIHtcclxuICAgIGxldCBwaWVjZU51bSA9IHBhdGgucGllY2VOdW1fO1xyXG4gICAgaWYgKHBpZWNlTnVtIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHBpZWNlTnVtKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGF0aC5waWVjZXNfLCBwaWVjZU51bSk7XHJcbn1cclxuZnVuY3Rpb24gcGF0aEdldEJhY2socGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZXNfLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gcGF0aFRvVXJsRW5jb2RlZFN0cmluZyhwYXRoKSB7XHJcbiAgICBsZXQgcGF0aFN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHBhdGgucGllY2VzX1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcclxufVxyXG4vKipcclxuICogU2hhbGxvdyBjb3B5IG9mIHRoZSBwYXJ0cyBvZiB0aGUgcGF0aC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhTbGljZShwYXRoLCBiZWdpbiA9IDApIHtcclxuICAgIHJldHVybiBwYXRoLnBpZWNlc18uc2xpY2UocGF0aC5waWVjZU51bV8gKyBiZWdpbik7XHJcbn1cclxuZnVuY3Rpb24gcGF0aFBhcmVudChwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGllY2VzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV87IGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgcGllY2VzLnB1c2gocGF0aC5waWVjZXNfW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhDaGlsZChwYXRoLCBjaGlsZFBhdGhPYmopIHtcclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcGllY2VzLnB1c2gocGF0aC5waWVjZXNfW2ldKTtcclxuICAgIH1cclxuICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkUGF0aE9iai5waWVjZU51bV87IGkgPCBjaGlsZFBhdGhPYmoucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwaWVjZXMucHVzaChjaGlsZFBhdGhPYmoucGllY2VzX1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQaWVjZXMgPSBjaGlsZFBhdGhPYmouc3BsaXQoJy8nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkUGllY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChjaGlsZFBpZWNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gc2VnbWVudHMgaW4gdGhpcyBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoSXNFbXB0eShwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggZnJvbSBvdXRlclBhdGggdG8gaW5uZXJQYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdSZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLCBpbm5lclBhdGgpIHtcclxuICAgIGNvbnN0IG91dGVyID0gcGF0aEdldEZyb250KG91dGVyUGF0aCksIGlubmVyID0gcGF0aEdldEZyb250KGlubmVyUGF0aCk7XHJcbiAgICBpZiAob3V0ZXIgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gaW5uZXJQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1JlbGF0aXZlUGF0aChwYXRoUG9wRnJvbnQob3V0ZXJQYXRoKSwgcGF0aFBvcEZyb250KGlubmVyUGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoICgnICtcclxuICAgICAgICAgICAgaW5uZXJQYXRoICtcclxuICAgICAgICAgICAgJykgaXMgbm90IHdpdGhpbiAnICtcclxuICAgICAgICAgICAgJ291dGVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIG91dGVyUGF0aCArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIC0xLCAwLCAxIGlmIGxlZnQgaXMgbGVzcywgZXF1YWwsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgcmlnaHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdEtleXMgPSBwYXRoU2xpY2UobGVmdCwgMCk7XHJcbiAgICBjb25zdCByaWdodEtleXMgPSBwYXRoU2xpY2UocmlnaHQsIDApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0S2V5cy5sZW5ndGggJiYgaSA8IHJpZ2h0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IG5hbWVDb21wYXJlKGxlZnRLZXlzW2ldLCByaWdodEtleXNbaV0pO1xyXG4gICAgICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdEtleXMubGVuZ3RoID09PSByaWdodEtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdEtleXMubGVuZ3RoIDwgcmlnaHRLZXlzLmxlbmd0aCA/IC0xIDogMTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgdHJ1ZSBpZiBwYXRocyBhcmUgdGhlIHNhbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoRXF1YWxzKHBhdGgsIG90aGVyKSB7XHJcbiAgICBpZiAocGF0aEdldExlbmd0aChwYXRoKSAhPT0gcGF0aEdldExlbmd0aChvdGhlcikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV8sIGogPSBvdGhlci5waWVjZU51bV87IGkgPD0gcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrLCBqKyspIHtcclxuICAgICAgICBpZiAocGF0aC5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIHBhdGggaXMgYSBwYXJlbnQgb2YgKG9yIHRoZSBzYW1lIGFzKSBvdGhlclxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbnRhaW5zKHBhdGgsIG90aGVyKSB7XHJcbiAgICBsZXQgaSA9IHBhdGgucGllY2VOdW1fO1xyXG4gICAgbGV0IGogPSBvdGhlci5waWVjZU51bV87XHJcbiAgICBpZiAocGF0aEdldExlbmd0aChwYXRoKSA+IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICsraTtcclxuICAgICAgICArK2o7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogRHluYW1pYyAobXV0YWJsZSkgcGF0aCB1c2VkIHRvIGNvdW50IHBhdGggbGVuZ3Rocy5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGVmZmljaWVudGx5IGNoZWNrIHBhdGhzIGZvciB2YWxpZFxyXG4gKiBsZW5ndGggKGluIFVURjggYnl0ZXMpIGFuZCBkZXB0aCAodXNlZCBpbiBwYXRoIHZhbGlkYXRpb24pLlxyXG4gKlxyXG4gKiBUaHJvd3MgRXJyb3IgZXhjZXB0aW9uIGlmIHBhdGggaXMgZXZlciBpbnZhbGlkLlxyXG4gKlxyXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIHBhdGggYWx3YXlzIGJlZ2lucyB3aXRoICcvJy5cclxuICovXHJcbmNsYXNzIFZhbGlkYXRpb25QYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBJbml0aWFsIFBhdGguXHJcbiAgICAgKiBAcGFyYW0gZXJyb3JQcmVmaXhfIC0gUHJlZml4IGZvciBhbnkgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGVycm9yUHJlZml4Xykge1xyXG4gICAgICAgIHRoaXMuZXJyb3JQcmVmaXhfID0gZXJyb3JQcmVmaXhfO1xyXG4gICAgICAgIHRoaXMucGFydHNfID0gcGF0aFNsaWNlKHBhdGgsIDApO1xyXG4gICAgICAgIC8qKiBJbml0aWFsaXplIHRvIG51bWJlciBvZiAnLycgY2hhcnMgbmVlZGVkIGluIHBhdGguICovXHJcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyA9IE1hdGgubWF4KDEsIHRoaXMucGFydHNfLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IHN0cmluZ0xlbmd0aCh0aGlzLnBhcnRzX1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoQ2hlY2tWYWxpZCh0aGlzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFB1c2godmFsaWRhdGlvblBhdGgsIGNoaWxkKSB7XHJcbiAgICAvLyBDb3VudCB0aGUgbmVlZGVkICcvJ1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gKz0gMTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wdXNoKGNoaWxkKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IHN0cmluZ0xlbmd0aChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodmFsaWRhdGlvblBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRpb25QYXRoUG9wKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdmFsaWRhdGlvblBhdGgucGFydHNfLnBvcCgpO1xyXG4gICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gLT0gc3RyaW5nTGVuZ3RoKGxhc3QpO1xyXG4gICAgLy8gVW4tY291bnQgdGhlIHByZXZpb3VzICcvJ1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gLT0gMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodmFsaWRhdGlvblBhdGgpIHtcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyA+IE1BWF9QQVRIX0xFTkdUSF9CWVRFUykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWxpZGF0aW9uUGF0aC5lcnJvclByZWZpeF8gK1xyXG4gICAgICAgICAgICAnaGFzIGEga2V5IHBhdGggbG9uZ2VyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0xFTkdUSF9CWVRFUyArXHJcbiAgICAgICAgICAgICcgYnl0ZXMgKCcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArXHJcbiAgICAgICAgICAgICcpLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiBNQVhfUEFUSF9ERVBUSCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWxpZGF0aW9uUGF0aC5lcnJvclByZWZpeF8gK1xyXG4gICAgICAgICAgICAncGF0aCBzcGVjaWZpZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBkZXB0aCB0aGF0IGNhbiBiZSB3cml0dGVuICgnICtcclxuICAgICAgICAgICAgTUFYX1BBVEhfREVQVEggK1xyXG4gICAgICAgICAgICAnKSBvciBvYmplY3QgY29udGFpbnMgYSBjeWNsZSAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFN0cmluZyBmb3IgdXNlIGluIGVycm9yIG1lc3NhZ2VzIC0gdXNlcyAnLicgbm90YXRpb24gZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcodmFsaWRhdGlvblBhdGgpIHtcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiaW4gcHJvcGVydHkgJ1wiICsgdmFsaWRhdGlvblBhdGgucGFydHNfLmpvaW4oJy4nKSArIFwiJ1wiO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFZpc2liaWxpdHlNb25pdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFsndmlzaWJsZSddKTtcclxuICAgICAgICBsZXQgaGlkZGVuO1xyXG4gICAgICAgIGxldCB2aXNpYmlsaXR5Q2hhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50WydoaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtb3pIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbW96SGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21zSGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnd2Via2l0SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhbHdheXMgYXNzdW1lIHdlIGFyZSB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgdGhhdCBpbiBicm93c2Vyc1xyXG4gICAgICAgIC8vIHdpdGhvdXQgcGFnZSB2aXNpYmlsaXR5IHN1cHBvcnQgb3IgaW4gY2FzZXMgd2hlcmUgd2UgYXJlIG5ldmVyIHZpc2libGVcclxuICAgICAgICAvLyAoZS5nLiBjaHJvbWUgZXh0ZW5zaW9uKSwgd2UgYWN0IGFzIGlmIHdlIGFyZSB2aXNpYmxlLCBpLmUuIGRvbid0IGRlbGF5XHJcbiAgICAgICAgLy8gcmVjb25uZWN0c1xyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh2aXNpYmlsaXR5Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodmlzaWJpbGl0eUNoYW5nZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9ICFkb2N1bWVudFtoaWRkZW5dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUgIT09IHRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3Zpc2libGUnLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZpc2liaWxpdHlNb25pdG9yKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ3Zpc2libGUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcclxuICAgICAgICByZXR1cm4gW3RoaXMudmlzaWJsZV9dO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFJFQ09OTkVDVF9NSU5fREVMQVkgPSAxMDAwO1xyXG5jb25zdCBSRUNPTk5FQ1RfTUFYX0RFTEFZX0RFRkFVTFQgPSA2MCAqIDUgKiAxMDAwOyAvLyA1IG1pbnV0ZXMgaW4gbWlsbGlzZWNvbmRzIChDYXNlOiAxODU4KVxyXG5jb25zdCBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHMgZm9yIGFkbWluIGNsaWVudHMgKGxpa2VseSB0byBiZSBhIGJhY2tlbmQgc2VydmVyKVxyXG5jb25zdCBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUiA9IDEuMztcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQgPSAzMDAwMDsgLy8gUmVzZXQgZGVsYXkgYmFjayB0byBNSU5fREVMQVkgYWZ0ZXIgYmVpbmcgY29ubmVjdGVkIGZvciAzMHNlYy5cclxuY29uc3QgU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiA9ICdzZXJ2ZXJfa2lsbCc7XHJcbi8vIElmIGF1dGggZmFpbHMgcmVwZWF0ZWRseSwgd2UnbGwgYXNzdW1lIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbG9nIGEgd2FybmluZyAvIGJhY2sgb2ZmLlxyXG5jb25zdCBJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCA9IDM7XHJcbi8qKlxyXG4gKiBGaXJlYmFzZSBjb25uZWN0aW9uLiAgQWJzdHJhY3RzIHdpcmUgcHJvdG9jb2wgYW5kIGhhbmRsZXMgcmVjb25uZWN0aW5nLlxyXG4gKlxyXG4gKiBOT1RFOiBBbGwgSlNPTiBvYmplY3RzIHNlbnQgdG8gdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gbXVzdCBoYXZlIHByb3BlcnR5IG5hbWVzIGVuY2xvc2VkXHJcbiAqIGluIHF1b3RlcyB0byBtYWtlIHN1cmUgdGhlIGNsb3N1cmUgY29tcGlsZXIgZG9lcyBub3QgbWluaWZ5IHRoZW0uXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50Q29ubmVjdGlvbiBleHRlbmRzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZF8gLSBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3RcclxuICAgICAqIEBwYXJhbSBvbkRhdGFVcGRhdGVfIC0gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIG9uRGF0YVVwZGF0ZV8sIG9uQ29ubmVjdFN0YXR1c18sIG9uU2VydmVySW5mb1VwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXBwQ2hlY2tUb2tlblByb3ZpZGVyXywgYXV0aE92ZXJyaWRlXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklkXyA9IGFwcGxpY2F0aW9uSWRfO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfID0gb25Db25uZWN0U3RhdHVzXztcclxuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8gPSBvblNlcnZlckluZm9VcGRhdGVfO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXyA9IGFwcENoZWNrVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hdXRoT3ZlcnJpZGVfID0gYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAvLyBVc2VkIGZvciBkaWFnbm9zdGljIGxvZ2dpbmcuXHJcbiAgICAgICAgdGhpcy5pZCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXysrO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIoJ3A6JyArIHRoaXMuaWQgKyAnOicpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc18gPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9IDA7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUO1xyXG4gICAgICAgIHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSBmYWxzZTtcclxuICAgICAgICAvLyBCZWZvcmUgd2UgZ2V0IGNvbm5lY3RlZCwgd2Uga2VlcCBhIHF1ZXVlIG9mIHBlbmRpbmcgbWVzc2FnZXMgdG8gc2VuZC5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0TnVtYmVyXyA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMuZmlyc3RDb25uZWN0aW9uXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgIGlmIChhdXRoT3ZlcnJpZGVfICYmICFpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGggb3ZlcnJpZGUgc3BlY2lmaWVkIGluIG9wdGlvbnMsIGJ1dCBub3Qgc3VwcG9ydGVkIG9uIG5vbiBOb2RlLmpzIHBsYXRmb3JtcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBWaXNpYmlsaXR5TW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCd2aXNpYmxlJywgdGhpcy5vblZpc2libGVfLCB0aGlzKTtcclxuICAgICAgICBpZiAocmVwb0luZm9fLmhvc3QuaW5kZXhPZignZmJsb2NhbCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ29ubGluZScsIHRoaXMub25PbmxpbmVfLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUmVxdWVzdChhY3Rpb24sIGJvZHksIG9uUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBjdXJSZXFOdW0gPSArK3RoaXMucmVxdWVzdE51bWJlcl87XHJcbiAgICAgICAgY29uc3QgbXNnID0geyByOiBjdXJSZXFOdW0sIGE6IGFjdGlvbiwgYjogYm9keSB9O1xyXG4gICAgICAgIHRoaXMubG9nXyhzdHJpbmdpZnkobXNnKSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuY29ubmVjdGVkXywgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uc2VuZFJlcXVlc3QobXNnKTtcclxuICAgICAgICBpZiAob25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfW2N1clJlcU51bV0gPSBvblJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChxdWVyeSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBwOiBxdWVyeS5fcGF0aC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBxOiBxdWVyeS5fcXVlcnlPYmplY3RcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG91dHN0YW5kaW5nR2V0ID0ge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdnJyxcclxuICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgb25Db21wbGV0ZTogKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWydkJ107XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVsncyddID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfLnB1c2gob3V0c3RhbmRpbmdHZXQpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8rKztcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzXy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVucy5oYXMocGF0aFN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5zLnNldChwYXRoU3RyaW5nLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICdsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xyXG4gICAgICAgIGFzc2VydCghdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5oYXMocXVlcnlJZCksIGBsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLmApO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlblNwZWMgPSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUsXHJcbiAgICAgICAgICAgIGhhc2hGbjogY3VycmVudEhhc2hGbixcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHRhZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5zZXQocXVlcnlJZCwgbGlzdGVuU3BlYyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRHZXRfKGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgZ2V0ID0gdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdnJywgZ2V0LnJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nR2V0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0c18gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0Lm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGdldC5vbkNvbXBsZXRlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5TcGVjLnF1ZXJ5O1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICdxJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciB0byBzZW5kIHF1ZXJ5IGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKGxpc3RlblNwZWMudGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnkuX3F1ZXJ5T2JqZWN0O1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IGxpc3RlblNwZWMudGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXFbIC8qaGFzaCovJ2gnXSA9IGxpc3RlblNwZWMuaGFzaEZuKCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2VbIC8qZGF0YSovJ2QnXTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gbWVzc2FnZVsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgIC8vIHByaW50IHdhcm5pbmdzIGluIGFueSBjYXNlLi4uXHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5TcGVjID0gdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxyXG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlblNwZWMgPT09IGxpc3RlblNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlblNwZWMub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlblNwZWMub25Db21wbGV0ZShzdGF0dXMsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2Fybk9uTGlzdGVuV2FybmluZ3NfKHBheWxvYWQsIHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHBheWxvYWQsICd3JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3Qgd2FybmluZ3MgPSBzYWZlR2V0KHBheWxvYWQsICd3Jyk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdhcm5pbmdzKSAmJiB+d2FybmluZ3MuaW5kZXhPZignbm9faW5kZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gJ1wiLmluZGV4T25cIjogXCInICsgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkudG9TdHJpbmcoKSArICdcIic7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFBhdGggPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgd2FybihgVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIFlvdXIgZGF0YSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBmaWx0ZXJlZCBvbiB0aGUgY2xpZW50LiBDb25zaWRlciBhZGRpbmcgJHtpbmRleFNwZWN9IGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAke2luZGV4UGF0aH0gdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbikge1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXV0aCB0b2tlbiByZWZyZXNoZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLiBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlXHJcbiAgICAgICAgICAgIC8vdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWUgYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hdXRoJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyh0b2tlbik7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyhjcmVkZW50aWFsKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpc24ndCBpbnRlbmRlZCB0byBiZSBidWxsZXRwcm9vZiAoYSBtYWxpY2lvdXMgZGV2ZWxvcGVyIGNhbiBhbHdheXMganVzdCBtb2RpZnkgdGhlIGNsaWVudCkuXHJcbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBkb24ndCBib3RoZXIgcmVzZXR0aW5nIHRoZSBtYXggZGVsYXkgYmFjayB0byB0aGUgZGVmYXVsdCBpZiBhdXRoIGZhaWxzIC8gZXhwaXJlcy5cclxuICAgICAgICBjb25zdCBpc0ZpcmViYXNlU2VjcmV0ID0gY3JlZGVudGlhbCAmJiBjcmVkZW50aWFsLmxlbmd0aCA9PT0gNDA7XHJcbiAgICAgICAgaWYgKGlzRmlyZWJhc2VTZWNyZXQgfHwgaXNBZG1pbihjcmVkZW50aWFsKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0FkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEFwcENoZWNrVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gdG9rZW47XHJcbiAgICAgICAgdGhpcy5sb2dfKCdBcHAgY2hlY2sgdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbl8pIHtcclxuICAgICAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLlxyXG4gICAgICAgICAgICAvL0lmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHNpbXBseSBkZWxldGUgdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWVcclxuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hcHBlY2snLCB7fSwgKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLiBJZiB0aGUgYXV0aGVudGljYXRpb24gYXR0ZW1wdCBmYWlscywgaXQncyB0cmlnZ2VyZWQgbGlrZVxyXG4gICAgICogYSBhdXRoIHJldm9rZWQgKHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUF1dGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmF1dGhUb2tlbl8pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmF1dGhUb2tlbl87XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhNZXRob2QgPSBpc1ZhbGlkRm9ybWF0KHRva2VuKSA/ICdhdXRoJyA6ICdnYXV0aCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REYXRhID0geyBjcmVkOiB0b2tlbiB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoT3ZlcnJpZGVfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnbm9hdXRoJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmF1dGhPdmVycmlkZV8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnYXV0aHZhciddID0gdGhpcy5hdXRoT3ZlcnJpZGVfO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYXV0aE1ldGhvZCwgcmVxdWVzdERhdGEsIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhUb2tlbl8gPT09IHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlcnMgcmVjb25uZWN0IGFuZCBmb3JjZSByZWZyZXNoIGZvciBhdXRoIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oc3RhdHVzLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIHRva2VuLiBJZiB0aGUgYXV0aGVudGljYXRpb25cclxuICAgICAqIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2UgdGhlIHRva2VuIHdhcyByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpc1xyXG4gICAgICogY2xvc2VkKS5cclxuICAgICAqL1xyXG4gICAgdHJ5QXBwQ2hlY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2FwcGNoZWNrJywgeyAndG9rZW4nOiB0aGlzLmFwcENoZWNrVG9rZW5fIH0sIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25BcHBDaGVja1Jldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXREb2NcclxuICAgICAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnVW5saXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydChxdWVyeS5fcXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkgfHwgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSwgJ3VubGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5Ll9xdWVyeU9iamVjdCwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5T2JqLCB0YWcpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICduJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciBzZW5kaW5nIHF1ZXJ5SWQgaWYgaXQncyBub24tZGVmYXVsdC5cclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnlPYmo7XHJcbiAgICAgICAgICAgIHJlcVsndCddID0gdGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxKTtcclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdFB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ28nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvJyxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdE1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvbScsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RDYW5jZWwocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvYycsIHBhdGhTdHJpbmcsIG51bGwsIG9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ29jJyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRPbkRpc2Nvbm5lY3RfKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsIC8qZGF0YSovIGQ6IGRhdGEgfTtcclxuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHJlc3BvbnNlWyAvKnN0YXR1cyovJ3MnXSwgcmVzcG9uc2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ3AnLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcclxuICAgIH1cclxuICAgIG1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdtJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBwdXRJbnRlcm5hbChhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgIC8qZGF0YSovIGQ6IGRhdGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFsgLypoYXNoKi8naCddID0gaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogT25seSBrZWVwIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBwdXQgZm9yIGEgZ2l2ZW4gcGF0aD9cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18ucHVzaCh7XHJcbiAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8rKztcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0J1ZmZlcmluZyBwdXQ6ICcgKyBwYXRoU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUHV0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0uYWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XHJcbiAgICAgICAgY29uc3Qgb25Db21wbGV0ZSA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ub25Db21wbGV0ZTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKGFjdGlvbiArICcgcmVzcG9uc2UnLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8tLTtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUobWVzc2FnZVsgLypzdGF0dXMqLydzJ10sIG1lc3NhZ2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBqdXN0IGRyb3AgdGhlIHN0YXRzLlxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgLypjb3VudGVycyovIGM6IHN0YXRzIH07XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgvKnN0YXRzKi8gJ3MnLCByZXF1ZXN0LCByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzdWx0WyAvKnN0YXR1cyovJ3MnXTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IHJlc3VsdFsgLyogZGF0YSAqLydkJ107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZXBvcnRTdGF0cycsICdFcnJvciBzZW5kaW5nIHN0YXRzOiAnICsgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCdyJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSByZXNwb25zZVxyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2Zyb20gc2VydmVyOiAnICsgc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVxTnVtID0gbWVzc2FnZVsnciddO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xyXG4gICAgICAgICAgICBpZiAob25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgICAgIG9uUmVzcG9uc2UobWVzc2FnZVsgLypib2R5Ki8nYiddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0Egc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiAnICsgbWVzc2FnZVsnZXJyb3InXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2EnIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFQdXNoXyhtZXNzYWdlWydhJ10sIG1lc3NhZ2VbJ2InXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhUHVzaF8oYWN0aW9uLCBib2R5KSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdoYW5kbGVTZXJ2ZXJNZXNzYWdlJywgYWN0aW9uLCBib2R5KTtcclxuICAgICAgICBpZiAoYWN0aW9uID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypkYXRhKi8nZCddLCBcclxuICAgICAgICAgICAgLyppc01lcmdlKi8gZmFsc2UsIGJvZHlbJ3QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ20nKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZT0qLyB0cnVlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uTGlzdGVuUmV2b2tlZF8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKnF1ZXJ5Ki8ncSddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYWMnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYXBjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhib2R5WyAvKnN0YXR1cyBjb2RlKi8ncyddLCBib2R5WyAvKiBleHBsYW5hdGlvbiAqLydkJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vblNlY3VyaXR5RGVidWdQYWNrZXRfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGFjdGlvbikgK1xyXG4gICAgICAgICAgICAgICAgJ1xcbkFyZSB5b3UgdXNpbmcgdGhlIGxhdGVzdCBjbGllbnQ/Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFkeV8odGltZXN0YW1wLCBzZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kQ29ubmVjdFN0YXRzXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3RvcmVTdGF0ZV8oKTtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18odHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZUNvbm5lY3RfKHRpbWVvdXQpIHtcclxuICAgICAgICBhc3NlcnQoIXRoaXMucmVhbHRpbWVfLCBcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTtcclxuICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBFdmVuIHdoZW4gdGltZW91dCBpcyAwLCBpdCdzIGltcG9ydGFudCB0byBkbyBhIHNldFRpbWVvdXQgdG8gd29yayBhcm91bmQgYW4gaW5mdXJpYXRpbmcgXCJTZWN1cml0eSBFcnJvclwiIGluXHJcbiAgICAgICAgLy8gRmlyZWZveCB3aGVuIHRyeWluZyB0byB3cml0ZSB0byBvdXIgbG9uZy1wb2xsaW5nIGlmcmFtZSBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBGb3JnZSBvciBvdXIgdW5pdCB0ZXN0cykuXHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvbl8oKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcclxuICAgIH1cclxuICAgIGluaXRDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfICYmIHRoaXMuZmlyc3RDb25uZWN0aW9uXykge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25WaXNpYmxlXyh2aXNpYmxlKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGFiYmluZyBhd2F5IGFuZCBiYWNrIHRvIGEgd2luZG93IHdpbGwgZGVmZWF0IG91ciByZWNvbm5lY3QgYmFja29mZiwgYnV0IEkgdGhpbmsgdGhhdCdzIGZpbmUuXHJcbiAgICAgICAgaWYgKHZpc2libGUgJiZcclxuICAgICAgICAgICAgIXRoaXMudmlzaWJsZV8gJiZcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPT09IHRoaXMubWF4UmVjb25uZWN0RGVsYXlfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xyXG4gICAgfVxyXG4gICAgb25PbmxpbmVfKG9ubGluZSkge1xyXG4gICAgICAgIGlmIChvbmxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb25saW5lLicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi4nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFsdGltZURpc2Nvbm5lY3RfKCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkJyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXHJcbiAgICAgICAgdGhpcy5jYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpO1xyXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgcGVuZGluZyByZXF1ZXN0cy5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52aXNpYmxlXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSB0aGlzLm1heFJlY29ubmVjdERlbGF5XztcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25uZWN0ZWQgbG9uZyBlbm91Z2gsIHJlc2V0IHJlY29ubmVjdCBkZWxheSB0byBtaW5pbXVtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID4gUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfO1xyXG4gICAgICAgICAgICBsZXQgcmVjb25uZWN0RGVsYXkgPSBNYXRoLm1heCgwLCB0aGlzLnJlY29ubmVjdERlbGF5XyAtIHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCk7XHJcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gTWF0aC5yYW5kb20oKSAqIHJlY29ubmVjdERlbGF5O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1RyeWluZyB0byByZWNvbm5lY3QgaW4gJyArIHJlY29ubmVjdERlbGF5ICsgJ21zJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XHJcbiAgICAgICAgICAgIC8vIEFkanVzdCByZWNvbm5lY3QgZGVsYXkgZm9yIG5leHQgdGltZS5cclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBNYXRoLm1pbih0aGlzLm1heFJlY29ubmVjdERlbGF5XywgdGhpcy5yZWNvbm5lY3REZWxheV8gKiBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlc3RhYmxpc2hDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHQnKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGF0YU1lc3NhZ2UgPSB0aGlzLm9uRGF0YU1lc3NhZ2VfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUmVhZHkgPSB0aGlzLm9uUmVhZHlfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuaWQgKyAnOicgKyBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXysrO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2Vzc2lvbklkID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjbG9zZUZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbmRSZXF1ZXN0Rm4gPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoY29ubmVjdGlvbiwgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfID0ge1xyXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlRm4sXHJcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3RGblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXztcclxuICAgICAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGZldGNoIGF1dGggYW5kIGFwcCBjaGVjayB0b2tlbiwgYW5kIGVzdGFibGlzaCBjb25uZWN0aW9uIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBmZXRjaGluZyB0aGUgdG9rZW4gd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgICAgIGNvbnN0IFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQuIENyZWF0aW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gYXV0aFRva2VuICYmIGF1dGhUb2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gYXBwQ2hlY2tUb2tlbiAmJiBhcHBDaGVja1Rva2VuLnRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihjb25uSWQsIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG9uRGF0YU1lc3NhZ2UsIG9uUmVhZHksIG9uRGlzY29ubmVjdCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLyogb25LaWxsPSAqLyByZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKHJlYXNvbiArICcgKCcgKyB0aGlzLnJlcG9JbmZvXy50b1N0cmluZygpICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnJ1cHQoU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnRmFpbGVkIHRvIGdldCB0b2tlbjogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGEgY3JpdGljYWwgZXJyb3IgZm9yIHRoZSBBZG1pbiBOb2RlLmpzIFNESywgc28gbG9nIGEgd2FybmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGdldFRva2VuKCkgbWF5IGFsc28ganVzdCBoYXZlIHRlbXBvcmFyaWx5IGZhaWxlZCwgc28gd2Ugc3RpbGwgd2FudCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSByZXRyeWluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGludGVycnVwdChyZWFzb24pIHtcclxuICAgICAgICBsb2coJ0ludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlYWx0aW1lRGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VtZShyZWFzb24pIHtcclxuICAgICAgICBsb2coJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gZm9yIHJlYXNvbjogJyArIHJlYXNvbik7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXTtcclxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVRpbWVzdGFtcF8odGltZXN0YW1wKSB7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8oeyBzZXJ2ZXJUaW1lT2Zmc2V0OiBkZWx0YSB9KTtcclxuICAgIH1cclxuICAgIGNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB1dCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcclxuICAgICAgICAgICAgaWYgKHB1dCAmJiAvKmhhc2gqLyAnaCcgaW4gcHV0LnJlcXVlc3QgJiYgcHV0LnF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHB1dC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHV0Lm9uQ29tcGxldGUoJ2Rpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uTGlzdGVuUmV2b2tlZF8ocGF0aFN0cmluZywgcXVlcnkpIHtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbiBhbmQgbWFudWZhY3R1cmUgYSBcInBlcm1pc3Npb25fZGVuaWVkXCIgZXJyb3IgZm9yIHRoZSBmYWlsZWQgbGlzdGVuLlxyXG4gICAgICAgIGxldCBxdWVyeUlkO1xyXG4gICAgICAgIGlmICghcXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnlJZCA9ICdkZWZhdWx0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSBxdWVyeS5tYXAocSA9PiBPYmplY3RUb1VuaXF1ZUtleShxKSkuam9pbignJCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiBsaXN0ZW4ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICBsaXN0ZW4ub25Db21wbGV0ZSgncGVybWlzc2lvbl9kZW5pZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aFN0cmluZyA9IG5ldyBQYXRoKHBhdGhTdHJpbmcpLnRvU3RyaW5nKCk7IC8vIG5vcm1hbGl6ZSBwYXRoLlxyXG4gICAgICAgIGxldCBsaXN0ZW47XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVucy5oYXMobm9ybWFsaXplZFBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubGlzdGVucy5nZXQobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICBsaXN0ZW4gPSBtYXAuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBtYXAuZGVsZXRlKHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBpZiAobWFwLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5kZWxldGUobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhbGwgbGlzdGVucyBmb3IgdGhpcyBwYXRoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICBsaXN0ZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0ZW47XHJcbiAgICB9XHJcbiAgICBvbkF1dGhSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXV0aCB0b2tlbiByZXZva2VkOiAnICsgc3RhdHVzQ29kZSArICcvJyArIGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfKys7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGxvbmcgcmVjb25uZWN0IGRlbGF5IGJlY2F1c2UgcmVjb3ZlcnkgaXMgdW5saWtlbHlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBhdXRoIHRva2VuIHByb3ZpZGVyIHRoYXQgdGhlIHRva2VuIGlzIGludmFsaWQsIHdoaWNoIHdpbGwgbG9nXHJcbiAgICAgICAgICAgICAgICAvLyBhIHdhcm5pbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25BcHBDaGVja1Jldm9rZWRfKHN0YXR1c0NvZGUsIGV4cGxhbmF0aW9uKSB7XHJcbiAgICAgICAgbG9nKCdBcHAgY2hlY2sgdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSB0cnVlO1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGRvbid0IGNsb3NlIHRoZSBjb25uZWN0aW9uIGFzIHRoZSBkZXZlbG9wZXIgbWF5IG5vdCBoYXZlXHJcbiAgICAgICAgLy8gZW5mb3JjZW1lbnQgZW5hYmxlZC4gVGhlIGJhY2tlbmQgY2xvc2VzIGNvbm5lY3Rpb25zIHdpdGggZW5mb3JjZW1lbnRzLlxyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA+PSBJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18oYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoJ21zZycgaW4gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJUkVCQVNFOiAnICsgYm9keVsnbXNnJ10ucmVwbGFjZSgnXFxuJywgJ1xcbkZJUkVCQVNFOiAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN0b3JlU3RhdGVfKCkge1xyXG4gICAgICAgIC8vUmUtYXV0aGVudGljYXRlIG91cnNlbHZlcyBpZiB3ZSBoYXZlIGEgY3JlZGVudGlhbCBzdG9yZWQuXHJcbiAgICAgICAgdGhpcy50cnlBdXRoKCk7XHJcbiAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIC8vIFB1dHMgZGVwZW5kIG9uIGhhdmluZyByZWNlaXZlZCB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHVwZGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRoZXkgY29tcGxldGUsIHNvIHdlIG11c3RcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcmllcyBvZiB0aGlzLmxpc3RlbnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5TcGVjIG9mIHF1ZXJpZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExpc3Rlbl8obGlzdGVuU3BlYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8ocmVxdWVzdC5hY3Rpb24sIHJlcXVlc3QucGF0aFN0cmluZywgcmVxdWVzdC5kYXRhLCByZXF1ZXN0Lm9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdHZXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldHNfW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRHZXRfKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBjbGllbnQgc3RhdHMgZm9yIGZpcnN0IGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc2VuZENvbm5lY3RTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgY2xpZW50TmFtZSA9ICdqcyc7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudE5hbWUgPSAnYWRtaW5fbm9kZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRzWydzZGsuJyArIGNsaWVudE5hbWUgKyAnLicgKyBTREtfVkVSU0lPTi5yZXBsYWNlKC9cXC4vZywgJy0nKV0gPSAxO1xyXG4gICAgICAgIGlmIChpc01vYmlsZUNvcmRvdmEoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLmNvcmRvdmEnXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLnJlYWN0bmF0aXZlJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcG9ydFN0YXRzKHN0YXRzKTtcclxuICAgIH1cclxuICAgIHNob3VsZFJlY29ubmVjdF8oKSB7XHJcbiAgICAgICAgY29uc3Qgb25saW5lID0gT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLmN1cnJlbnRseU9ubGluZSgpO1xyXG4gICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaW50ZXJydXB0UmVhc29uc18pICYmIG9ubGluZTtcclxuICAgIH1cclxufVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8gPSAwO1xyXG4vKipcclxuICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXyA9IDA7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE5hbWVkTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBub2RlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFdyYXAobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4IHtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQSBzdGFuZGFsb25lIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXHJcbiAgICAgKiB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldENvbXBhcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcclxuICAgICAqIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2hhbmdlcyBhcmUgaXNvbGF0ZWQgdG8gcGFydHMgb2YgdGhlIHNuYXBzaG90IHRoYXQgYXJlIG5vdCBpbmRleGVkLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwb3J0aW9uIG9mIHRoZSBzbmFwc2hvdCBiZWluZyBpbmRleGVkIGNoYW5nZWQgYmV0d2VlbiBvbGROb2RlIGFuZCBuZXdOb2RlXHJcbiAgICAgKi9cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZFdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKE1JTl9OQU1FLCBvbGROb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgbmV3Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvbGRXcmFwcGVkLCBuZXdXcmFwcGVkKSAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYSBub2RlIHdyYXBwZXIgdGhhdCB3aWxsIHNvcnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBhbnkgb3RoZXIgbm9kZSB3cmFwcGVyLCB1c2luZyB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19FTVBUWV9OT0RFO1xyXG5jbGFzcyBLZXlJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIHN0YXRpYyBnZXQgX19FTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiBfX0VNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fRU1QVFlfTk9ERSh2YWwpIHtcclxuICAgICAgICBfX0VNUFRZX05PREUgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIC8vIFdlIGNvdWxkIHByb2JhYmx5IHJldHVybiB0cnVlIGhlcmUgKHNpbmNlIGV2ZXJ5IG5vZGUgaGFzIGEga2V5KSwgYnV0IGl0J3MgbmV2ZXIgY2FsbGVkXHJcbiAgICAgICAgLy8gc28ganVzdCBsZWF2aW5nIHVuaW1wbGVtZW50ZWQgZm9yIG5vdy5cclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignS2V5SW5kZXguaXNEZWZpbmVkT24gbm90IGV4cGVjdGVkIHRvIGJlIGNhbGxlZC4nKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlYWxseSBiZSBjcmVhdGVkIG9uY2UgYW5kIGNhY2hlZCBpbiBhIHN0YXRpYyBwcm9wZXJ0eSwgYnV0XHJcbiAgICAgICAgLy8gTmFtZWROb2RlIGlzbid0IGRlZmluZWQgeWV0LCBzbyBJIGNhbid0IHVzZSBpdCBpbiBhIHN0YXRpYy4gIEJsZWguXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJywgJ0tleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuJyk7XHJcbiAgICAgICAgLy8gV2UganVzdCB1c2UgZW1wdHkgbm9kZSwgYnV0IGl0J2xsIG5ldmVyIGJlIGNvbXBhcmVkLCBzaW5jZSBvdXIgY29tcGFyYXRvciBvbmx5IGxvb2tzIGF0IG5hbWUuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoaW5kZXhWYWx1ZSwgX19FTVBUWV9OT0RFKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLmtleSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgS0VZX0lOREVYID0gbmV3IEtleUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwSXRlcmF0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gaXRlcmF0ZS5cclxuICAgICAqIEBwYXJhbSBpc1JldmVyc2VfIC0gV2hldGhlciBvciBub3QgdG8gaXRlcmF0ZSBpbiByZXZlcnNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2VfLCByZXN1bHRHZW5lcmF0b3JfID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuaXNSZXZlcnNlXyA9IGlzUmV2ZXJzZV87XHJcbiAgICAgICAgdGhpcy5yZXN1bHRHZW5lcmF0b3JfID0gcmVzdWx0R2VuZXJhdG9yXztcclxuICAgICAgICB0aGlzLm5vZGVTdGFja18gPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XHJcbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIGNvbXBhcmlzb24gaWYgd2UncmUgZ29pbmcgaW4gcmV2ZXJzZVxyXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgY21wICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLCBidXQgc3RvcCBpdGVyYXRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TmV4dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFja18ucG9wKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0R2VuZXJhdG9yXyhub2RlLmtleSwgbm9kZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tfW3RoaXMubm9kZVN0YWNrXy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG4gKi9cclxuY2xhc3MgTExSQk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxyXG4gICAgICogQHBhcmFtIGxlZnQgLSBMZWZ0IGNoaWxkLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gUmlnaHQgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xyXG4gICAgICAgIHRoaXMubGVmdCA9XHJcbiAgICAgICAgICAgIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID1cclxuICAgICAgICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gTmV3IGtleSBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBOZXcgdmFsdWUgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gTmV3IGNvbG9yIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTmV3IGxlZnQgY2hpbGQgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gTmV3IHJpZ2h0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3VudCgpICsgMSArIHRoaXMucmlnaHQuY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqICAgbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICAhIWFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5fKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW5fKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5fKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgbWluaW11bSBrZXkgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbl8oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4sIHNtYWxsZXN0O1xyXG4gICAgICAgIG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbi5yaWdodC5pc0VtcHR5KCkgJiYgIW4ucmlnaHQuaXNSZWRfKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobi5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW5fKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgaXMgYSBSRUQgbm9kZS5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBmaXhVcF8oKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkXygpICYmICFuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLnJpZ2h0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkTGVmdC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZExlZnRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHRfKCkpO1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZFJpZ2h0LlxyXG4gICAgICovXHJcbiAgICBtb3ZlUmVkUmlnaHRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlTGVmdC5cclxuICAgICAqL1xyXG4gICAgcm90YXRlTGVmdF8oKSB7XHJcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlUmlnaHQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZVJpZ2h0XygpIHtcclxuICAgICAgICBjb25zdCBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3dCByZWUsIGFmdGVyIGNvbG9yRmxpcC5cclxuICAgICAqL1xyXG4gICAgY29sb3JGbGlwXygpIHtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMucmlnaHQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIHRlc3RpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgaXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tNYXhEZXB0aF8oKSB7XHJcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2tfKCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5jb3VudCgpICsgMTtcclxuICAgIH1cclxuICAgIGNoZWNrXygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZF8oKSAmJiB0aGlzLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWQgbm9kZSBoYXMgcmVkIGNoaWxkKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JpZ2h0IGNoaWxkIG9mICgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJykgaXMgcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2tfKCk7XHJcbiAgICAgICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2tfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFjayBkZXB0aHMgZGlmZmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkXygpID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xyXG5MTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG4gKi9cclxuY2xhc3MgTExSQkVtcHR5Tm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5vZGUgY29weS5cclxuICAgICAqL1xyXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgLSBDb21wYXJhdG9yLlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSwgdmFsdWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xyXG4gKiB0cmVlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JfIC0gS2V5IGNvbXBhcmF0b3IuXHJcbiAgICAgKiBAcGFyYW0gcm9vdF8gLSBPcHRpb25hbCByb290IG5vZGUgZm9yIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3JfLCByb290XyA9IFNvcnRlZE1hcC5FTVBUWV9OT0RFKSB7XHJcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yXyA9IGNvbXBhcmF0b3JfO1xyXG4gICAgICAgIHRoaXMucm9vdF8gPSByb290XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cclxuICAgICAqIChUT0RPOiBXZSBzaG91bGQgcGVyaGFwcyByZW5hbWUgdGhpcyBtZXRob2QgdG8gJ3B1dCcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcl8sIHRoaXMucm9vdF9cclxuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gbG9vayB1cC5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwgaWYgdGhlXHJcbiAgICAgKiBrZXkgZG9lc24ndCBleGlzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBjbXA7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3RfO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtICpiZWZvcmUqIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIGtleSBpcyB0aGUgZmlyc3QgaXRlbS5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGZpbmQgdGhlIHByZWRlY2Vzc29yIG9mXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJlZGVjZXNzb3Iga2V5LlxyXG4gICAgICovXHJcbiAgICBnZXRQcmVkZWNlc3NvcktleShrZXkpIHtcclxuICAgICAgICBsZXQgY21wLCBub2RlID0gdGhpcy5yb290XywgcmlnaHRQYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodFBhcmVudC5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmlyc3QgaXRlbS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0UGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgZ2V0SXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXksIHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290Xywga2V5LCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgdHJ1ZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihyZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIG51bGwsIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsd2F5cyB1c2UgdGhlIHNhbWUgZW1wdHkgbm9kZSwgdG8gcmVkdWNlIG1lbW9yeS5cclxuICovXHJcblNvcnRlZE1hcC5FTVBUWV9OT0RFID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gTkFNRV9PTkxZX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0Lm5hbWUsIHJpZ2h0Lm5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIE5BTUVfQ09NUEFSQVRPUihsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQsIHJpZ2h0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgTUFYX05PREUkMjtcclxuZnVuY3Rpb24gc2V0TWF4Tm9kZSQxKHZhbCkge1xyXG4gICAgTUFYX05PREUkMiA9IHZhbDtcclxufVxyXG5jb25zdCBwcmlvcml0eUhhc2hUZXh0ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XHJcbiAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiAnbnVtYmVyOicgKyBkb3VibGVUb0lFRUU3NTRTdHJpbmcocHJpb3JpdHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmc6JyArIHByaW9yaXR5O1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYSBwcmlvcml0eSBzbmFwc2hvdCBOb2RlIGlzIHZhbGlkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eU5vZGUgPSBmdW5jdGlvbiAocHJpb3JpdHlOb2RlKSB7XHJcbiAgICBpZiAocHJpb3JpdHlOb2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcclxuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHZhbCwgJy5zdicpKSwgJ1ByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuaXNFbXB0eSgpLCAncHJpb3JpdHkgb2YgdW5leHBlY3RlZCB0eXBlLicpO1xyXG4gICAgfVxyXG4gICAgLy8gRG9uJ3QgY2FsbCBnZXRQcmlvcml0eSgpIG9uIE1BWF9OT0RFIHRvIGF2b2lkIGhpdHRpbmcgYXNzZXJ0aW9uLlxyXG4gICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCksIFwiUHJpb3JpdHkgbm9kZXMgY2FuJ3QgaGF2ZSBhIHByaW9yaXR5IG9mIHRoZWlyIG93bi5cIik7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xyXG4vKipcclxuICogTGVhZk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBsZWFmIG5vZGVzIGluIGEgRGF0YVNuYXBzaG90LiAgSXRcclxuICogaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIChhIHN0cmluZyxcclxuICogbnVtYmVyLCBvciBib29sZWFuKSBhY2Nlc3NpYmxlIHZpYSBnZXRWYWx1ZSgpLlxyXG4gKi9cclxuY2xhc3MgTGVhZk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVfIC0gVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoaXMgbGVhZiBub2RlLiBUaGUgb2JqZWN0IHR5cGUgaXNcclxuICAgICAqIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlOb2RlXyAtIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlXywgcHJpb3JpdHlOb2RlXyA9IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnZhbHVlXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVfICE9PSBudWxsLCBcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO1xyXG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICAgICAgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IHZhbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICByZXR1cm4gX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNMZWFmTm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHlOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZSh0aGlzLnZhbHVlXywgbmV3UHJpb3JpdHlOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQ2hpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgY2hpbGROYW1lICE9PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpLnVwZGF0ZVByaW9yaXR5KHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVDaGlsZChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBmcm9udCAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQoZnJvbnQgIT09ICcucHJpb3JpdHknIHx8IHBhdGhHZXRMZW5ndGgocGF0aCkgPT09IDEsICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChwYXRoUG9wRnJvbnQocGF0aCksIG5ld0NoaWxkTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIG51bUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAoZXhwb3J0Rm9ybWF0ICYmICF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnLnZhbHVlJzogdGhpcy5nZXRWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgJy5wcmlvcml0eSc6IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5wcmlvcml0eU5vZGVfLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgICAgICB0b0hhc2ggKz0gdHlwZSArICc6JztcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gZG91YmxlVG9JRUVFNzU0U3RyaW5nKHRoaXMudmFsdWVfKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPSB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVhZiBub2RlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgaW5zdGFuY2VvZiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdGhlci5pc0xlYWZOb2RlKCksICdVbmtub3duIG5vZGUgdHlwZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9MZWFmTm9kZV8ob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyaXNvbiBzcGVjaWZpY2FsbHkgZm9yIHR3byBsZWFmIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmVUb0xlYWZOb2RlXyhvdGhlckxlYWYpIHtcclxuICAgICAgICBjb25zdCBvdGhlckxlYWZUeXBlID0gdHlwZW9mIG90aGVyTGVhZi52YWx1ZV87XHJcbiAgICAgICAgY29uc3QgdGhpc0xlYWZUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IG90aGVySW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2Yob3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0luZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKHRoaXNMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KG90aGVySW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgb3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXNJbmRleCA+PSAwLCAnVW5rbm93biBsZWFmIHR5cGU6ICcgKyB0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGlmIChvdGhlckluZGV4ID09PSB0aGlzSW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gU2FtZSB0eXBlLCBjb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAodGhpc0xlYWZUeXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvcmtzIGJlY2F1c2UgdHJ1ZSA+IGZhbHNlLCBhbGwgb3RoZXJzIGFyZSBudW1iZXIgb3Igc3RyaW5nIGNvbXBhcmlzb25zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8gPCBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc0luZGV4IC0gb3RoZXJJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckxlYWYgPSBvdGhlcjtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfLmVxdWFscyhvdGhlckxlYWYucHJpb3JpdHlOb2RlXykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIHNvcnQgb3JkZXIgZm9yIGNvbXBhcmluZyBsZWFmIG5vZGVzIG9mIGRpZmZlcmVudCB0eXBlcy4gSWYgdHdvIGxlYWYgbm9kZXMgaGF2ZVxyXG4gKiB0aGUgc2FtZSB0eXBlLCB0aGUgY29tcGFyaXNvbiBmYWxscyBiYWNrIHRvIHRoZWlyIHZhbHVlXHJcbiAqL1xyXG5MZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSID0gWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ107XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBub2RlRnJvbUpTT04kMTtcclxubGV0IE1BWF9OT0RFJDE7XHJcbmZ1bmN0aW9uIHNldE5vZGVGcm9tSlNPTih2YWwpIHtcclxuICAgIG5vZGVGcm9tSlNPTiQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUodmFsKSB7XHJcbiAgICBNQVhfTk9ERSQxID0gdmFsO1xyXG59XHJcbmNsYXNzIFByaW9yaXR5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhUHJpb3JpdHkgPSBhLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBpbmRleENtcCA9IGFQcmlvcml0eS5jb21wYXJlVG8oYlByaW9yaXR5KTtcclxuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleENtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmdldFByaW9yaXR5KCkuZXF1YWxzKG5ld05vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIE1BWF9OT0RFJDEpKTtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCBwcmlvcml0eU5vZGUgPSBub2RlRnJvbUpTT04kMShpbmRleFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICcucHJpb3JpdHknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFBSSU9SSVRZX0lOREVYID0gbmV3IFByaW9yaXR5SW5kZXgoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HXzIgPSBNYXRoLmxvZygyKTtcclxuY2xhc3MgQmFzZTEyTnVtIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGxvZ0Jhc2UyID0gKG51bSkgPT4gXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBwYXJzZUludCgoTWF0aC5sb2cobnVtKSAvIExPR18yKSwgMTApO1xyXG4gICAgICAgIGNvbnN0IGJpdE1hc2sgPSAoYml0cykgPT4gcGFyc2VJbnQoQXJyYXkoYml0cyArIDEpLmpvaW4oJzEnKSwgMik7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGxvZ0Jhc2UyKGxlbmd0aCArIDEpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8gPSB0aGlzLmNvdW50IC0gMTtcclxuICAgICAgICBjb25zdCBtYXNrID0gYml0TWFzayh0aGlzLmNvdW50KTtcclxuICAgICAgICB0aGlzLmJpdHNfID0gKGxlbmd0aCArIDEpICYgbWFzaztcclxuICAgIH1cclxuICAgIG5leHRCaXRJc09uZSgpIHtcclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU0JpdHdpc2VPcGVyYXRvclVzYWdlXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Xy0tO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGEgbGlzdCBvZiBjaGlsZCBub2RlcyBhbmQgY29uc3RydWN0cyBhIFNvcnRlZFNldCB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyaXNvblxyXG4gKiBmdW5jdGlvblxyXG4gKlxyXG4gKiBVc2VzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluIHRoZSBwYXBlciBsaW5rZWQgaGVyZTpcclxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40Ni4xNDU4XHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZExpc3QgLSBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXHJcbiAqIEBwYXJhbSBjbXAgLSBUaGUgY29tcGFyaXNvbiBtZXRob2QgdG8gYmUgdXNlZFxyXG4gKiBAcGFyYW0ga2V5Rm4gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBleHRyYWN0IEsgZnJvbSBhIG5vZGUgd3JhcHBlciwgaWYgSydzXHJcbiAqIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxyXG4gKiBAcGFyYW0gbWFwU29ydEZuIC0gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgZm9yIGNvbXBhcmF0b3IgdXNlZCBieSB0aGUgZ2VuZXJhdGVkIHNvcnRlZCBtYXBcclxuICovXHJcbmNvbnN0IGJ1aWxkQ2hpbGRTZXQgPSBmdW5jdGlvbiAoY2hpbGRMaXN0LCBjbXAsIGtleUZuLCBtYXBTb3J0Rm4pIHtcclxuICAgIGNoaWxkTGlzdC5zb3J0KGNtcCk7XHJcbiAgICBjb25zdCBidWlsZEJhbGFuY2VkVHJlZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBoaWdoIC0gbG93O1xyXG4gICAgICAgIGxldCBuYW1lZE5vZGU7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb25zdCBtaWRkbGUgPSBwYXJzZUludCgobGVuZ3RoIC8gMiksIDEwKSArIGxvdztcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdywgbWlkZGxlKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZEJhbGFuY2VkVHJlZShtaWRkbGUgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W21pZGRsZV07XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBidWlsZEZyb20xMkFycmF5ID0gZnVuY3Rpb24gKGJhc2UxMikge1xyXG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcclxuICAgICAgICBsZXQgcm9vdCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gY2hpbGRMaXN0Lmxlbmd0aDtcclxuICAgICAgICBjb25zdCBidWlsZFBlbm5hbnQgPSBmdW5jdGlvbiAoY2h1bmtTaXplLCBjb2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBpbmRleCAtIGNodW5rU2l6ZTtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGluZGV4O1xyXG4gICAgICAgICAgICBpbmRleCAtPSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdyArIDEsIGhpZ2gpO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xyXG4gICAgICAgICAgICBhdHRhY2hQZW5uYW50KG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBjb2xvciwgbnVsbCwgY2hpbGRUcmVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhdHRhY2hQZW5uYW50ID0gZnVuY3Rpb24gKHBlbm5hbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTEyLmNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNPbmUgPSBiYXNlMTIubmV4dEJpdElzT25lKCk7XHJcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygbm9kZXMgdGFrZW4gaW4gZWFjaCBzbGljZSBpcyAyXihhcnIubGVuZ3RoIC0gKGkgKyAxKSlcclxuICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIGlmIChpc09uZSkge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCA9PSAyXHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5CTEFDSyk7XHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5SRUQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJhc2UxMiA9IG5ldyBCYXNlMTJOdW0oY2hpbGRMaXN0Lmxlbmd0aCk7XHJcbiAgICBjb25zdCByb290ID0gYnVpbGRGcm9tMTJBcnJheShiYXNlMTIpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKG1hcFNvcnRGbiB8fCBjbXAsIHJvb3QpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX2RlZmF1bHRJbmRleE1hcDtcclxuY29uc3QgZmFsbGJhY2tPYmplY3QgPSB7fTtcclxuY2xhc3MgSW5kZXhNYXAge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhlc18sIGluZGV4U2V0Xykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhlc18gPSBpbmRleGVzXztcclxuICAgICAgICB0aGlzLmluZGV4U2V0XyA9IGluZGV4U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgSW5kZXhNYXAgZm9yIG5vZGVzIHdpdGhvdXQgYSBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbGxiYWNrT2JqZWN0ICYmIFBSSU9SSVRZX0lOREVYLCAnQ2hpbGRyZW5Ob2RlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgICAgICBfZGVmYXVsdEluZGV4TWFwID1cclxuICAgICAgICAgICAgX2RlZmF1bHRJbmRleE1hcCB8fFxyXG4gICAgICAgICAgICAgICAgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IGZhbGxiYWNrT2JqZWN0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pO1xyXG4gICAgICAgIHJldHVybiBfZGVmYXVsdEluZGV4TWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0KGluZGV4S2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc29ydGVkTWFwID0gc2FmZUdldCh0aGlzLmluZGV4ZXNfLCBpbmRleEtleSk7XHJcbiAgICAgICAgaWYgKCFzb3J0ZWRNYXApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbmRleCBkZWZpbmVkIGZvciAnICsgaW5kZXhLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc29ydGVkTWFwIGluc3RhbmNlb2YgU29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggZXhpc3RzLCBidXQgaXQgZmFsbHMgYmFjayB0byBqdXN0IG5hbWUgY29tcGFyaXNvbi4gUmV0dXJuIG51bGwgc28gdGhhdCB0aGUgY2FsbGluZyBjb2RlIHVzZXMgdGhlXHJcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2hpbGQgbWFwXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjb250YWlucyh0aGlzLmluZGV4U2V0XywgaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgYXNzZXJ0KGluZGV4RGVmaW5pdGlvbiAhPT0gS0VZX0lOREVYLCBcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7XHJcbiAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgbGV0IHNhd0luZGV4ZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgfHwgaW5kZXhEZWZpbml0aW9uLmlzRGVmaW5lZE9uKG5leHQubm9kZSk7XHJcbiAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4RGVmaW5pdGlvbi5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3SW5kZXggPSBmYWxsYmFja09iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhTZXQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICAgICAgbmV3SW5kZXhTZXRbaW5kZXhOYW1lXSA9IGluZGV4RGVmaW5pdGlvbjtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleGVzXyk7XHJcbiAgICAgICAgbmV3SW5kZXhlc1tpbmRleE5hbWVdID0gbmV3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCBuZXdJbmRleFNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZSB0aGF0IHRoaXMgbm9kZSBpcyBwcm9wZXJseSB0cmFja2VkIGluIGFueSBpbmRleGVzIHRoYXQgd2UncmUgbWFpbnRhaW5pbmdcclxuICAgICAqL1xyXG4gICAgYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBtYXAodGhpcy5pbmRleGVzXywgKGluZGV4ZWRDaGlsZHJlbiwgaW5kZXhOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2FmZUdldCh0aGlzLmluZGV4U2V0XywgaW5kZXhOYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGluZGV4LCAnTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgJyArIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBpbmRleCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXguaXNEZWZpbmVkT24obmFtZWROb2RlLm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBidWlsZCB0aGlzIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0SXRlcmF0b3IoTmFtZWROb2RlLldyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQubmFtZSAhPT0gbmFtZWROb2RlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmFtZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4LmdldENvbXBhcmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGFuZ2UsIHRoaXMgcmVtYWlucyBhIGZhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmluc2VydChuYW1lZE5vZGUsIG5hbWVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhNYXAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrLiBKdXN0IHJldHVybiBpdCwgbm90aGluZyB0byBkbyBpbiB0aGlzIGNhc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTbmFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbi5yZW1vdmUobmV3IE5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyByZWNvcmQgb2YgdGhpcyBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUT0RPOiBGb3IgbWVtb3J5IHNhdmluZ3MsIGRvbid0IHN0b3JlIHByaW9yaXR5Tm9kZV8gaWYgaXQncyBlbXB0eS5cclxubGV0IEVNUFRZX05PREU7XHJcbi8qKlxyXG4gKiBDaGlsZHJlbk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBpbnRlcm5hbCBub2RlcyBpbiBhIERhdGFTbmFwc2hvdFxyXG4gKiAoaS5lLiBub2RlcyB3aXRoIGNoaWxkcmVuKS4gIEl0IGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZVxyXG4gKiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSwgc29ydGVkIGJ5IGNoaWxkIG5hbWUuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW5fIC0gTGlzdCBvZiBjaGlsZHJlbiBvZiB0aGlzIG5vZGUuLlxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlIChhcyBhIHNuYXBzaG90IG5vZGUpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbl8sIHByaW9yaXR5Tm9kZV8sIGluZGV4TWFwXykge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5fID0gY2hpbGRyZW5fO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5pbmRleE1hcF8gPSBpbmRleE1hcF87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdGU6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBudWxsIHByaW9yaXR5IGlzIGZvciBFTVBUWV9OT0RFLCBzaW5jZSB3ZSBjYW4ndCB1c2VcclxuICAgICAgICAgKiBFTVBUWV9OT0RFIGFzIHRoZSBwcmlvcml0eSBvZiBFTVBUWV9OT0RFLiAgV2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBtYWtpbmcgRU1QVFlfTk9ERSBpdHMgb3duXHJcbiAgICAgICAgICogY2xhc3MgaW5zdGVhZCBvZiBhbiBlbXB0eSBDaGlsZHJlbk5vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMucHJpb3JpdHlOb2RlXykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5wcmlvcml0eU5vZGVfIHx8IHRoaXMucHJpb3JpdHlOb2RlXy5pc0VtcHR5KCksICdBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEVNUFRZX05PREUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChFTVBUWV9OT0RFIHx8XHJcbiAgICAgICAgICAgIChFTVBUWV9OT0RFID0gbmV3IENoaWxkcmVuTm9kZShuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIG51bGwsIEluZGV4TWFwLkRlZmF1bHQpKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmlvcml0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfIHx8IEVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcHJpb3JpdGllcyBvbiBlbXB0eSBub2Rlc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCBuZXdQcmlvcml0eU5vZGUsIHRoaXMuaW5kZXhNYXBfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEltbWVkaWF0ZUNoaWxkKGZyb250KS5nZXRDaGlsZChwYXRoUG9wRnJvbnQocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgYXNzZXJ0KG5ld0NoaWxkTm9kZSwgJ1dlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2RlcycpO1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuLCBuZXdJbmRleE1hcDtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8ucmVtb3ZlKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLnJlbW92ZUZyb21JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5pbnNlcnQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRUb0luZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV3UHJpb3JpdHkgPSBuZXdDaGlsZHJlbi5pc0VtcHR5KClcclxuICAgICAgICAgICAgICAgID8gRU1QVFlfTk9ERVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKG5ld0NoaWxkcmVuLCBuZXdQcmlvcml0eSwgbmV3SW5kZXhNYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocGF0aEdldEZyb250KHBhdGgpICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ltbWVkaWF0ZUNoaWxkID0gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChmcm9udCwgbmV3SW1tZWRpYXRlQ2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdmFsKGV4cG9ydEZvcm1hdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgbGV0IG51bUtleXMgPSAwLCBtYXhLZXkgPSAwLCBhbGxJbnRlZ2VyS2V5cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoaWxkTm9kZS52YWwoZXhwb3J0Rm9ybWF0KTtcclxuICAgICAgICAgICAgbnVtS2V5cysrO1xyXG4gICAgICAgICAgICBpZiAoYWxsSW50ZWdlcktleXMgJiYgQ2hpbGRyZW5Ob2RlLklOVEVHRVJfUkVHRVhQXy50ZXN0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IE1hdGgubWF4KG1heEtleSwgTnVtYmVyKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxsSW50ZWdlcktleXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghZXhwb3J0Rm9ybWF0ICYmIGFsbEludGVnZXJLZXlzICYmIG1heEtleSA8IDIgKiBudW1LZXlzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gYXJyYXkuXHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqWycucHJpb3JpdHknXSA9IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHRvSGFzaCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPVxyXG4gICAgICAgICAgICAgICAgICAgICdwcmlvcml0eTonICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlIYXNoVGV4dCh0aGlzLmdldFByaW9yaXR5KCkudmFsKCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzonO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSGFzaCA9IGNoaWxkTm9kZS5oYXNoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRIYXNoICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSGFzaCArPSAnOicgKyBrZXkgKyAnOicgKyBjaGlsZEhhc2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHRvSGFzaCA9PT0gJycgPyAnJyA6IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZGVjZXNzb3IgPSBpZHguZ2V0UHJlZGVjZXNzb3JLZXkobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3IgPyBwcmVkZWNlc3Nvci5uYW1lIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5nZXRQcmVkZWNlc3NvcktleShjaGlsZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluS2V5ID0gaWR4Lm1pbktleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWluS2V5ICYmIG1pbktleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1pbktleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGQoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgbWluS2V5ID0gdGhpcy5nZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtaW5LZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWluS2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWluS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGluZGV4LCByZXR1cm4gdGhlIGtleSBuYW1lIG9mIHRoZSBsYXJnZXN0IHZhbHVlIHdlIGhhdmUsIGFjY29yZGluZyB0byB0aGF0IGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXhLZXkgPSBpZHgubWF4S2V5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhLZXkgJiYgbWF4S2V5Lm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8ubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGFzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1heEtleSA9IHRoaXMuZ2V0TGFzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtYXhLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWF4S2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWF4S2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleCk7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4Lmlub3JkZXJUcmF2ZXJzYWwod3JhcHBlZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbih3cmFwcGVkTm9kZS5uYW1lLCB3cmFwcGVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWluUG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGtleSA9PiBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgc3RhcnRQb3N0KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGluZGV4RGVmaW5pdGlvbi5tYXhQb3N0KCksIGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgZW5kUG9zdCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT09IE1BWF9OT0RFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE11c3QgYmUgYW5vdGhlciBub2RlIHdpdGggY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdpdGhJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLRVlfSU5ERVggfHxcclxuICAgICAgICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCB0aGlzLnByaW9yaXR5Tm9kZV8sIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPT09IEtFWV9JTkRFWCB8fCB0aGlzLmluZGV4TWFwXy5oYXNJbmRleChpbmRleCk7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckNoaWxkcmVuTm9kZSA9IG90aGVyO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob3RoZXJDaGlsZHJlbk5vZGUuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuXy5jb3VudCgpID09PSBvdGhlckNoaWxkcmVuTm9kZS5jaGlsZHJlbl8uY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSB0aGlzLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVySXRlciA9IG90aGVyQ2hpbGRyZW5Ob2RlLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGxldCB0aGlzQ3VycmVudCA9IHRoaXNJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIGxldCBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXNDdXJyZW50ICYmIG90aGVyQ3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ3VycmVudC5uYW1lICE9PSBvdGhlckN1cnJlbnQubmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpc0N1cnJlbnQubm9kZS5lcXVhbHMob3RoZXJDdXJyZW50Lm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ3VycmVudCA9PT0gbnVsbCAmJiBvdGhlckN1cnJlbnQgPT09IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBTb3J0ZWRNYXAgb3JkZXJlZCBieSBpbmRleCwgb3IgbnVsbCBpZiB0aGUgZGVmYXVsdCAoYnkta2V5KSBvcmRlcmluZyBjYW4gYmUgdXNlZFxyXG4gICAgICogaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYXBfLmdldChpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkNoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8gPSAvXigwfFsxLTldXFxkKikkLztcclxuY2xhc3MgTWF4Tm9kZSBleHRlbmRzIENoaWxkcmVuTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIC8vIE5vdCB0aGF0IHdlIGV2ZXJ5IGNvbXBhcmUgaXQsIGJ1dCBNQVhfTk9ERSBpcyBvbmx5IGV2ZXIgZXF1YWwgdG8gaXRzZWxmXHJcbiAgICAgICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFya2VyIHRoYXQgd2lsbCBzb3J0IGhpZ2hlciB0aGFuIGFueSBvdGhlciBzbmFwc2hvdC5cclxuICovXHJcbmNvbnN0IE1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTmFtZWROb2RlLCB7XHJcbiAgICBNSU46IHtcclxuICAgICAgICB2YWx1ZTogbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXHJcbiAgICB9LFxyXG4gICAgTUFYOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIE1BWF9OT0RFKVxyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbiAqIFJlZmVyZW5jZSBFeHRlbnNpb25zXHJcbiAqL1xyXG5LZXlJbmRleC5fX0VNUFRZX05PREUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IENoaWxkcmVuTm9kZTtcclxuc2V0TWF4Tm9kZSQxKE1BWF9OT0RFKTtcclxuc2V0TWF4Tm9kZShNQVhfTk9ERSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFVTRV9ISU5aRSA9IHRydWU7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxyXG4gKiBAcGFyYW0ganNvbiAtIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxyXG4gKiBwYXNzZWQgSlNPTiBjb250YWlucyBhIC5wcmlvcml0eSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVGcm9tSlNPTihqc29uLCBwcmlvcml0eSA9IG51bGwpIHtcclxuICAgIGlmIChqc29uID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0JyAmJiAnLnByaW9yaXR5JyBpbiBqc29uKSB7XHJcbiAgICAgICAgcHJpb3JpdHkgPSBqc29uWycucHJpb3JpdHknXTtcclxuICAgIH1cclxuICAgIGFzc2VydChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgJy5zdicgaW4gcHJpb3JpdHkpLCAnSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiAnICsgdHlwZW9mIHByaW9yaXR5KTtcclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy52YWx1ZScgaW4ganNvbiAmJiBqc29uWycudmFsdWUnXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGpzb24gPSBqc29uWycudmFsdWUnXTtcclxuICAgIH1cclxuICAgIC8vIFZhbGlkIGxlYWYgbm9kZXMgaW5jbHVkZSBub24tb2JqZWN0cyBvciBzZXJ2ZXItdmFsdWUgd3JhcHBlciBvYmplY3RzXHJcbiAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnIHx8ICcuc3YnIGluIGpzb24pIHtcclxuICAgICAgICBjb25zdCBqc29uTGVhZiA9IGpzb247XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZShqc29uTGVhZiwgbm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShqc29uIGluc3RhbmNlb2YgQXJyYXkpICYmIFVTRV9ISU5aRSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuSGF2ZVByaW9yaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgaGluemVKc29uT2JqID0ganNvbjtcclxuICAgICAgICBlYWNoKGhpbnplSnNvbk9iaiwgKGtleSwgY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG1ldGFkYXRhIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eSB8fCAhY2hpbGROb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgTkFNRV9PTkxZX0NPTVBBUkFUT1IsIG5hbWVkTm9kZSA9PiBuYW1lZE5vZGUubmFtZSwgTkFNRV9DT01QQVJBVE9SKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW5IYXZlUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkQ2hpbGRTZXQgPSBidWlsZENoaWxkU2V0KGNoaWxkcmVuLCBQUklPUklUWV9JTkRFWC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IHNvcnRlZENoaWxkU2V0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIGVhY2goanNvbiwgKGtleSwgY2hpbGREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhqc29uLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCAxKSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1ldGFkYXRhIG5vZGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaXNMZWFmTm9kZSgpIHx8ICFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVQcmlvcml0eShub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgIH1cclxufVxyXG5zZXROb2RlRnJvbUpTT04obm9kZUZyb21KU09OKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUGF0aEluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhQYXRoXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleFBhdGhfID0gaW5kZXhQYXRoXztcclxuICAgICAgICBhc3NlcnQoIXBhdGhJc0VtcHR5KGluZGV4UGF0aF8pICYmIHBhdGhHZXRGcm9udChpbmRleFBhdGhfKSAhPT0gJy5wcmlvcml0eScsIFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiKTtcclxuICAgIH1cclxuICAgIGV4dHJhY3RDaGlsZChzbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXAuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChhLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhQ2hpbGQuY29tcGFyZVRvKGJDaGlsZCk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCB2YWx1ZU5vZGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCBNQVhfTk9ERSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhTbGljZSh0aGlzLmluZGV4UGF0aF8sIDApLmpvaW4oJy8nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWYWx1ZUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmVxdWFscyhuZXdOb2RlKTtcclxuICAgIH1cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1BWDtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgdmFsdWVOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnZhbHVlJztcclxuICAgIH1cclxufVxyXG5jb25zdCBWQUxVRV9JTkRFWCA9IG5ldyBWYWx1ZUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNoYW5nZVZhbHVlKHNuYXBzaG90Tm9kZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJ2YWx1ZVwiIC8qIENoYW5nZVR5cGUuVkFMVUUgKi8sIHNuYXBzaG90Tm9kZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkQWRkZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkUmVtb3ZlZChjaGlsZE5hbWUsIHNuYXBzaG90Tm9kZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZE5hbWUsIHNuYXBzaG90Tm9kZSwgb2xkU25hcCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sXHJcbiAgICAgICAgc25hcHNob3ROb2RlLFxyXG4gICAgICAgIGNoaWxkTmFtZSxcclxuICAgICAgICBvbGRTbmFwXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkTW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX01PVkVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEb2Vzbid0IHJlYWxseSBmaWx0ZXIgbm9kZXMgYnV0IGFwcGxpZXMgYW4gaW5kZXggdG8gdGhlIG5vZGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFueSBjaGFuZ2VzXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4Xykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KHNuYXAuaXNJbmRleGVkKHRoaXMuaW5kZXhfKSwgJ0Egbm9kZSBtdXN0IGJlIGluZGV4ZWQgaWYgb25seSBhIGNoaWxkIGlzIHVwZGF0ZWQnKTtcclxuICAgICAgICBjb25zdCBvbGRDaGlsZCA9IHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcclxuICAgICAgICAvLyBDaGVjayBpZiBhbnl0aGluZyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gICAgICAgIGlmIChvbGRDaGlsZC5nZXRDaGlsZChhZmZlY3RlZFBhdGgpLmVxdWFscyhuZXdDaGlsZC5nZXRDaGlsZChhZmZlY3RlZFBhdGgpKSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNoaWxkIGNhbiBlbnRlciBvciBsZWF2ZSB0aGUgdmlldyBiZWNhdXNlIGFmZmVjdGVkUGF0aCB3YXMgc2V0IHRvIG51bGwuXHJcbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgYWZmZWN0ZWRQYXRoIHdpbGwgYXBwZWFyIG51bGwgaW4gYm90aCB0aGUgb2xkIGFuZCBuZXcgc25hcHNob3RzLiAgU28gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyB0aGVzZSBjYXNlcyBhcyBcIm5vdGhpbmcgY2hhbmdlZC5cIlxyXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpID09PSBuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzZXJ0IHNob3VsZCBiZSB2YWxpZCwgYnV0IGl0J3MgZXhwZW5zaXZlIChjYW4gZG9taW5hdGUgcGVyZiB0ZXN0aW5nKSBzbyBkb24ndCBhY3R1YWxseSBkbyBpdC5cclxuICAgICAgICAgICAgICAgIC8vYXNzZXJ0KG9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCksICdPbGQgYW5kIG5ldyBzbmFwc2hvdHMgc2hvdWxkIGJlIGVxdWFsLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKGtleSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzbmFwLmlzTGVhZk5vZGUoKSwgJ0EgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbGRDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChrZXksIG5ld0NoaWxkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIG5ld0NoaWxkLCBvbGRDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbmFwLmlzTGVhZk5vZGUoKSAmJiBuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5vZGUgaXMgaW5kZXhlZFxyXG4gICAgICAgICAgICByZXR1cm4gc25hcC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIG5ld0NoaWxkKS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCFvbGRTbmFwLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkU25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3U25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRTbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRDaGFuZ2VkKGtleSwgY2hpbGROb2RlLCBvbGRDaGlsZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICBpZiAob2xkU25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFNuYXAudXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbHRlcnNOb2RlcygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBGaWx0ZXJzIG5vZGVzIGJ5IHJhbmdlIGFuZCB1c2VzIGFuIEluZGV4RmlsdGVyIHRvIHRyYWNrIGFueSBjaGFuZ2VzIGFmdGVyIGZpbHRlcmluZyB0aGUgbm9kZVxyXG4gKi9cclxuY2xhc3MgUmFuZ2VkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhlZEZpbHRlcl8gPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0UG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0U3RhcnRQb3N0XyhwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuZW5kUG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0RW5kUG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfID0gIXBhcmFtcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICB0aGlzLmVuZElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuZW5kQmVmb3JlU2V0XztcclxuICAgIH1cclxuICAgIGdldFN0YXJ0UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvc3RfO1xyXG4gICAgfVxyXG4gICAgZ2V0RW5kUG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRQb3N0XztcclxuICAgIH1cclxuICAgIG1hdGNoZXMobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluU3RhcnQgPSB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfXHJcbiAgICAgICAgICAgID8gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLmdldFN0YXJ0UG9zdCgpLCBub2RlKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLmdldFN0YXJ0UG9zdCgpLCBub2RlKSA8IDA7XHJcbiAgICAgICAgY29uc3QgaXNXaXRoaW5FbmQgPSB0aGlzLmVuZElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5nZXRFbmRQb3N0KCkpIDw9IDBcclxuICAgICAgICAgICAgOiB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8IDA7XHJcbiAgICAgICAgcmV0dXJuIGlzV2l0aGluU3RhcnQgJiYgaXNXaXRoaW5FbmQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnVsbE5vZGUob2xkU25hcCwgbmV3U25hcCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgbmV3U25hcCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZVByaW9yaXR5KENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBuZXdTbmFwLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIGZpbHRlcmVkLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQcmlvcml0eShvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFN0YXJ0UG9zdF8ocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0TmFtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4U3RhcnRWYWx1ZSgpLCBzdGFydE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1pblBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0RW5kUG9zdF8ocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKSwgZW5kTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWF4UG9zdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXBwbGllcyBhIGxpbWl0IGFuZCBhIHJhbmdlIHRvIGEgbm9kZSBhbmQgdXNlcyBSYW5nZWRGaWx0ZXIgdG8gZG8gdGhlIGhlYXZ5IGxpZnRpbmcgd2hlcmUgcG9zc2libGVcclxuICovXHJcbmNsYXNzIExpbWl0ZWRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbFN0YXJ0ID0gKG5vZGUpID0+IHRoaXMucmV2ZXJzZV8gPyB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpblN0YXJ0UG9zdChub2RlKTtcclxuICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kID0gKG5vZGUpID0+IHRoaXMucmV2ZXJzZV8gPyB0aGlzLndpdGhpblN0YXJ0UG9zdChub2RlKSA6IHRoaXMud2l0aGluRW5kUG9zdChub2RlKTtcclxuICAgICAgICB0aGlzLndpdGhpblN0YXJ0UG9zdCA9IChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXMgPSB0aGlzLmluZGV4Xy5jb21wYXJlKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKSwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfID8gY29tcGFyZVJlcyA8PSAwIDogY29tcGFyZVJlcyA8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndpdGhpbkVuZFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kSXNJbmNsdXNpdmVfID8gY29tcGFyZVJlcyA8PSAwIDogY29tcGFyZVJlcyA8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8gPSBuZXcgUmFuZ2VkRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IHBhcmFtcy5nZXRMaW1pdCgpO1xyXG4gICAgICAgIHRoaXMucmV2ZXJzZV8gPSAhcGFyYW1zLmlzVmlld0Zyb21MZWZ0KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XHJcbiAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSkuZXF1YWxzKG5ld0NoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBObyBjaGFuZ2VcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuYXAubnVtQ2hpbGRyZW4oKSA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cclxuICAgICAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcclxuICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGtleSwgbmV3Q2hpbGQsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkO1xyXG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSB8fCBuZXdTbmFwLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xyXG4gICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdF8gKiAyIDwgbmV3U25hcC5udW1DaGlsZHJlbigpICYmXHJcbiAgICAgICAgICAgICAgICBuZXdTbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVhc2llciB0byBidWlsZCB1cCBhIHNuYXBzaG90LCBzaW5jZSB3aGF0IHdlJ3JlIGdpdmVuIGhhcyBtb3JlIHRoYW4gdHdpY2UgdGhlIGVsZW1lbnRzIHdlIHdhbnRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgc3RhcnRQb3N0LCBlbmRQb3N0LCBvciBsYXN0IGVsZW1lbnQgYXMgYXBwcm9wcmlhdGVcclxuICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldFJldmVyc2VJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSwgdGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldEl0ZXJhdG9yRnJvbSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpICYmIGNvdW50IDwgdGhpcy5saW1pdF8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbFN0YXJ0KG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgdGhlIHN0YXJ0LCBza2lwIHRvIHRoZSBuZXh0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kKG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kLCBzdG9wIGFkZGluZyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dC5uYW1lLCBuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZmlsdGVyZWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZmlsdGVyZWQuZ2V0SXRlcmF0b3IodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluUmFuZ2UgPSBjb3VudCA8IHRoaXMubGltaXRfICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcclxuICAgICAgICAgICAgLnVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIGZpbHRlcmVkLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQcmlvcml0eShvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGNoaWxkS2V5LCBjaGlsZFNuYXAsIHNvdXJjZSwgY2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICAvLyBUT0RPOiByZW5hbWUgYWxsIGNhY2hlIHN0dWZmIGV0YyB0byBnZW5lcmFsIHNuYXAgdGVybWlub2xvZ3lcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgICAgICBjbXAgPSAoYSwgYikgPT4gaW5kZXhDbXAoYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbXAgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEV2ZW50Q2FjaGUgPSBzbmFwO1xyXG4gICAgICAgIGFzc2VydChvbGRFdmVudENhY2hlLm51bUNoaWxkcmVuKCkgPT09IHRoaXMubGltaXRfLCAnJyk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd0JvdW5kYXJ5ID0gdGhpcy5yZXZlcnNlX1xyXG4gICAgICAgICAgICA/IG9sZEV2ZW50Q2FjaGUuZ2V0Rmlyc3RDaGlsZCh0aGlzLmluZGV4XylcclxuICAgICAgICAgICAgOiBvbGRFdmVudENhY2hlLmdldExhc3RDaGlsZCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgY29uc3QgaW5SYW5nZSA9IHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ld0NoaWxkTmFtZWROb2RlKTtcclxuICAgICAgICBpZiAob2xkRXZlbnRDYWNoZS5oYXNDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGRTbmFwID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCB3aW5kb3dCb3VuZGFyeSwgdGhpcy5yZXZlcnNlXyk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0Q2hpbGQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZC5uYW1lID09PSBjaGlsZEtleSB8fCBvbGRFdmVudENhY2hlLmhhc0NoaWxkKG5leHRDaGlsZC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgd2VpcmQgZWRnZSBjYXNlIHdoZXJlIGEgbm9kZSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgYSBtZXJnZSBpbiB0aGUgd3JpdGUgdHJlZSwgYnV0IGhhc24ndFxyXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBhcHBsaWVkIHRvIHRoZSBsaW1pdGVkIGZpbHRlciB5ZXQuIElnbm9yZSB0aGlzIG5leHQgY2hpbGQgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGltaXRlZCBmaWx0ZXIuLi5cclxuICAgICAgICAgICAgICAgIG5leHRDaGlsZCA9IHNvdXJjZS5nZXRDaGlsZEFmdGVyQ2hpbGQodGhpcy5pbmRleF8sIG5leHRDaGlsZCwgdGhpcy5yZXZlcnNlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZU5leHQgPSBuZXh0Q2hpbGQgPT0gbnVsbCA/IDEgOiBjbXAobmV4dENoaWxkLCBuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbnNJbldpbmRvdyA9IGluUmFuZ2UgJiYgIWNoaWxkU25hcC5pc0VtcHR5KCkgJiYgY29tcGFyZU5leHQgPj0gMDtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbnNJbldpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hpbGRTbmFwLCBvbGRDaGlsZFNuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChjaGlsZEtleSwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkSW5SYW5nZSA9IG5leHRDaGlsZCAhPSBudWxsICYmIHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5leHRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkSW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChuZXh0Q2hpbGQubmFtZSwgbmV4dENoaWxkLm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkU25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgZGVsZXRpbmcgYSBub2RlLCBidXQgaXQgd2FzIG5vdCBpbiB0aGUgd2luZG93LCBzbyBpZ25vcmUgaXRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluUmFuZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGNtcCh3aW5kb3dCb3VuZGFyeSwgbmV3Q2hpbGROYW1lZE5vZGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQod2luZG93Qm91bmRhcnkubmFtZSwgd2luZG93Qm91bmRhcnkubm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKVxyXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZCh3aW5kb3dCb3VuZGFyeS5uYW1lLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltbXV0YWJsZS1mcm9tLXRoZS1wdWJsaWMtYXBpIHN0cnVjdCBjb250YWluaW5nIGEgc2V0IG9mIHF1ZXJ5IHBhcmFtZXRlcnMgZGVmaW5pbmcgYVxyXG4gKiByYW5nZSB0byBiZSByZXR1cm5lZCBmb3IgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLiBJdCBpcyBhc3N1bWVkIHRoYXQgdmFsaWRhdGlvbiBvZiBwYXJhbWV0ZXJzIGlzIGRvbmUgYXQgdGhlXHJcbiAqIHVzZXItZmFjaW5nIEFQSSBsZXZlbCwgc28gaXQgaXMgbm90IGRvbmUgaGVyZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeVBhcmFtcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxpbWl0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydE5hbWVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydEFmdGVyU2V0XyA9IGZhbHNlOyAvLyBjYW4gb25seSBiZSB0cnVlIGlmIHN0YXJ0U2V0XyBpcyB0cnVlXHJcbiAgICAgICAgdGhpcy5lbmRTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kQmVmb3JlU2V0XyA9IGZhbHNlOyAvLyBjYW4gb25seSBiZSB0cnVlIGlmIGVuZFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMubGltaXRfID0gMDtcclxuICAgICAgICB0aGlzLnZpZXdGcm9tXyA9ICcnO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4RW5kVmFsdWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4RW5kTmFtZV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4XyA9IFBSSU9SSVRZX0lOREVYO1xyXG4gICAgfVxyXG4gICAgaGFzU3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTZXRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGl0IHdvdWxkIHJldHVybiBmcm9tIGxlZnQuXHJcbiAgICAgKi9cclxuICAgIGlzVmlld0Zyb21MZWZ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXdGcm9tXyA9PT0gJycpIHtcclxuICAgICAgICAgICAgLy8gbGltaXQoKSwgcmF0aGVyIHRoYW4gbGltaXRUb0ZpcnN0IG9yIGxpbWl0VG9MYXN0IHdhcyBjYWxsZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvbmx5IG9uZSBvZiBzdGFydFNldF8gYW5kIGVuZFNldF8gaXMgdHJ1ZS4gVXNlIHRoZW1cclxuICAgICAgICAgICAgLy8gdG8gY2FsY3VsYXRlIHdoaWNoIHNpZGUgb2YgdGhlIHZpZXcgdG8gYW5jaG9yIHRvLiBJZiBuZWl0aGVyIGlzIHNldCxcclxuICAgICAgICAgICAgLy8gYW5jaG9yIHRvIHRoZSBlbmQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGcm9tXyA9PT0gXCJsXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX0xFRlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzU3RhcnQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhTdGFydFZhbHVlKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnRpbmcga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhTdGFydE5hbWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNFbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0VuZCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhFbmRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmQga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhFbmROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmVuZFNldF8sICdPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZE5hbWVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0xpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhIGxpbWl0IGhhcyBiZWVuIHNldCBhbmQgaXQgaGFzIGJlZW4gZXhwbGljaXRseSBhbmNob3JlZFxyXG4gICAgICovXHJcbiAgICBoYXNBbmNob3JlZExpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XyAmJiB0aGlzLnZpZXdGcm9tXyAhPT0gJyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNMaW1pdCgpIHJldHVybnMgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBnZXRMaW1pdCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5saW1pdFNldF8sICdPbmx5IHZhbGlkIGlmIGxpbWl0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0XztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGxvYWRzQWxsRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gISh0aGlzLnN0YXJ0U2V0XyB8fCB0aGlzLmVuZFNldF8gfHwgdGhpcy5saW1pdFNldF8pO1xyXG4gICAgfVxyXG4gICAgaXNEZWZhdWx0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRzQWxsRGF0YSgpICYmIHRoaXMuaW5kZXhfID09PSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGNvcHkoKSB7XHJcbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBRdWVyeVBhcmFtcygpO1xyXG4gICAgICAgIGNvcHkubGltaXRTZXRfID0gdGhpcy5saW1pdFNldF87XHJcbiAgICAgICAgY29weS5saW1pdF8gPSB0aGlzLmxpbWl0XztcclxuICAgICAgICBjb3B5LnN0YXJ0U2V0XyA9IHRoaXMuc3RhcnRTZXRfO1xyXG4gICAgICAgIGNvcHkuc3RhcnRBZnRlclNldF8gPSB0aGlzLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydFZhbHVlXyA9IHRoaXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgICAgICBjb3B5LnN0YXJ0TmFtZVNldF8gPSB0aGlzLnN0YXJ0TmFtZVNldF87XHJcbiAgICAgICAgY29weS5pbmRleFN0YXJ0TmFtZV8gPSB0aGlzLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICBjb3B5LmVuZFNldF8gPSB0aGlzLmVuZFNldF87XHJcbiAgICAgICAgY29weS5lbmRCZWZvcmVTZXRfID0gdGhpcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhFbmRWYWx1ZV8gPSB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGNvcHkuZW5kTmFtZVNldF8gPSB0aGlzLmVuZE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhFbmROYW1lXyA9IHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICBjb3B5LmluZGV4XyA9IHRoaXMuaW5kZXhfO1xyXG4gICAgICAgIGNvcHkudmlld0Zyb21fID0gdGhpcy52aWV3RnJvbV87XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWRGaWx0ZXIocXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW1pdGVkRmlsdGVyKHF1ZXJ5UGFyYW1zKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VkRmlsdGVyKHF1ZXJ5UGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0xpbWl0VG9GaXJzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0xpbWl0VG9MYXN0KHF1ZXJ5UGFyYW1zLCBuZXdMaW1pdCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XHJcbiAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XHJcbiAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLnN0YXJ0U2V0XyA9IHRydWU7XHJcbiAgICBpZiAoaW5kZXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyA9IGluZGV4VmFsdWU7XHJcbiAgICBpZiAoa2V5ICE9IG51bGwpIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9IGtleTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1BhcmFtcy5zdGFydE5hbWVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgbGV0IHBhcmFtcztcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCB8fCAhIWtleSkge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwgTUFYX05BTUUpO1xyXG4gICAgfVxyXG4gICAgcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMuZW5kU2V0XyA9IHRydWU7XHJcbiAgICBpZiAoaW5kZXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhFbmRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLmVuZE5hbWVTZXRfID0gdHJ1ZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9IGtleTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQmVmb3JlKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwgTUlOX05BTUUpO1xyXG4gICAgfVxyXG4gICAgcGFyYW1zLmVuZEJlZm9yZVNldF8gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnlQYXJhbXMsIGluZGV4KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhfID0gaW5kZXg7XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2V0IG9mIFJFU1QgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgcmVwcmVzZW50aW5nIHRoaXMgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeVBhcmFtcykge1xyXG4gICAgY29uc3QgcXMgPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIHJldHVybiBxcztcclxuICAgIH1cclxuICAgIGxldCBvcmRlckJ5O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBvcmRlckJ5ID0gXCIkcHJpb3JpdHlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5QUklPUklUWV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gVkFMVUVfSU5ERVgpIHtcclxuICAgICAgICBvcmRlckJ5ID0gXCIkdmFsdWVcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5WQUxVRV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJGtleVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLktFWV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChxdWVyeVBhcmFtcy5pbmRleF8gaW5zdGFuY2VvZiBQYXRoSW5kZXgsICdVbnJlY29nbml6ZWQgaW5kZXggdHlwZSEnKTtcclxuICAgICAgICBvcmRlckJ5ID0gcXVlcnlQYXJhbXMuaW5kZXhfLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBxc1tcIm9yZGVyQnlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5PUkRFUl9CWSAqL10gPSBzdHJpbmdpZnkob3JkZXJCeSk7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnRTZXRfKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQYXJhbSA9IHF1ZXJ5UGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfXHJcbiAgICAgICAgICAgID8gXCJzdGFydEFmdGVyXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQUZURVIgKi9cclxuICAgICAgICAgICAgOiBcInN0YXJ0QXRcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5TVEFSVF9BVCAqLztcclxuICAgICAgICBxc1tzdGFydFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleFN0YXJ0VmFsdWVfKTtcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBxc1tzdGFydFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIGNvbnN0IGVuZFBhcmFtID0gcXVlcnlQYXJhbXMuZW5kQmVmb3JlU2V0X1xyXG4gICAgICAgICAgICA/IFwiZW5kQmVmb3JlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0JFRk9SRSAqL1xyXG4gICAgICAgICAgICA6IFwiZW5kQXRcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5FTkRfQVQgKi87XHJcbiAgICAgICAgcXNbZW5kUGFyYW1dID0gc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfKTtcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbZW5kUGFyYW1dICs9ICcsJyArIHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmlzVmlld0Zyb21MZWZ0KCkpIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvRmlyc3RcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5MSU1JVF9UT19GSVJTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxc1tcImxpbWl0VG9MYXN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fTEFTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHFzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIG9ialtcInNwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfVkFMVUUgKi9dID1cclxuICAgICAgICAgICAgcXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJzblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX05BTUUgKi9dID1cclxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1wic2luXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfSVNfSU5DTFVTSVZFICovXSA9XHJcbiAgICAgICAgICAgICFxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0XztcclxuICAgIH1cclxuICAgIGlmIChxdWVyeVBhcmFtcy5lbmRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wiZXBcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9FTkRfVkFMVUUgKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhFbmRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIG9ialtcImVuXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX05BTUUgKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1wiZWluXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuZW5kQmVmb3JlU2V0XztcclxuICAgIH1cclxuICAgIGlmIChxdWVyeVBhcmFtcy5saW1pdFNldF8pIHtcclxuICAgICAgICBvYmpbXCJsXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuTElNSVQgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIGxldCB2aWV3RnJvbSA9IHF1ZXJ5UGFyYW1zLnZpZXdGcm9tXztcclxuICAgICAgICBpZiAodmlld0Zyb20gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcInJcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fUklHSFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1widmZcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST00gKi9dID0gdmlld0Zyb207XHJcbiAgICB9XHJcbiAgICAvLyBGb3Igbm93LCBwcmlvcml0eSBpbmRleCBpcyB0aGUgZGVmYXVsdCwgc28gd2Ugb25seSBzcGVjaWZ5IGlmIGl0J3Mgc29tZSBvdGhlciBpbmRleFxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyAhPT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBvYmpbXCJpXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVggKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhfLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBTZXJ2ZXJBY3Rpb25zIHRoYXQgY29tbXVuaWNhdGVzIHdpdGggdGhlIHNlcnZlciB2aWEgUkVTVCByZXF1ZXN0cy5cclxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggY3Jhd2xlcnMsIHdoZXJlIHdlIGRvbid0IHdhbnQgdG8gc3BpbiB1cCBhIGZ1bGxcclxuICogcGVyc2lzdGVudCBjb25uZWN0aW9uICh1c2luZyBXZWJTb2NrZXRzIG9yIGxvbmctcG9sbGluZylcclxuICovXHJcbmNsYXNzIFJlYWRvbmx5UmVzdENsaWVudCBleHRlbmRzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIG9uRGF0YVVwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXBwQ2hlY2tUb2tlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfID0gb25EYXRhVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oLi4uWypdKX0gKi9cclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOnJlc3Q6Jyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0byB0cmFjayBsaXN0ZW5zLCBleGNlcHQgdG8gcHJldmVudCB1cyBjYWxsaW5nIGFuIG9uQ29tcGxldGUgZm9yIGEgbGlzdGVuXHJcbiAgICAgICAgICogdGhhdCdzIGJlZW4gcmVtb3ZlZC4gOi0vXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saXN0ZW5zXyA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0YWckJyArIHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChxdWVyeS5fcXVlcnlQYXJhbXMuaXNEZWZhdWx0KCksIFwic2hvdWxkIGhhdmUgYSB0YWcgaWYgaXQncyBub3QgYSBkZWZhdWx0IHF1ZXJ5LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBsaXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyKTtcclxuICAgICAgICAvLyBNYXJrIHRoaXMgbGlzdGVuZXIgc28gd2UgY2FuIHRlbGwgaWYgaXQncyByZW1vdmVkLlxyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBjb25zdCB0aGlzTGlzdGVuID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF0gPSB0aGlzTGlzdGVuO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKHF1ZXJ5Ll9xdWVyeVBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCAvKmlzTWVyZ2U9Ki8gZmFsc2UsIHRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNhZmVHZXQodGhpcy5saXN0ZW5zXywgbGlzdGVuSWQpID09PSB0aGlzTGlzdGVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdvayc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gNDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ3Blcm1pc3Npb25fZGVuaWVkJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdyZXN0X2Vycm9yOicgKyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoc3RhdHVzLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1bmxpc3RlbihxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuSWQgPSBSZWFkb25seVJlc3RDbGllbnQuZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW2xpc3RlbklkXTtcclxuICAgIH1cclxuICAgIGdldChxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKHF1ZXJ5Ll9xdWVyeVBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLnJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nICsgJy5qc29uJywgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKHBhdGhTdHJpbmcsIGRhdGEsIFxyXG4gICAgICAgICAgICAgICAgLyppc01lcmdlPSovIGZhbHNlLCBcclxuICAgICAgICAgICAgICAgIC8qdGFnPSovIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoZGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICAvLyBuby1vcCBzaW5jZSB3ZSBqdXN0IGFsd2F5cyBjYWxsIGdldFRva2VuLlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIFJFU1QgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gcGF0aCwgd2l0aCB0aGUgcHJvdmlkZWQgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMsXHJcbiAgICAgKiBhbmQgYW55IGF1dGggY3JlZGVudGlhbHMgd2UgaGF2ZS5cclxuICAgICAqL1xyXG4gICAgcmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHt9LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snZm9ybWF0J10gPSAnZXhwb3J0JztcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSksXHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSlcclxuICAgICAgICBdKS50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXV0aFRva2VuICYmIGF1dGhUb2tlbi5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydhdXRoJ10gPSBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydhYyddID0gYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSAodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCArXHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICc/JyArXHJcbiAgICAgICAgICAgICAgICAnbnM9JyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5uYW1lc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcocXVlcnlTdHJpbmdQYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdTZW5kaW5nIFJFU1QgcmVxdWVzdCBmb3IgJyArIHVybCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdSRVNUIFJlc3BvbnNlIGZvciAnICsgdXJsICsgJyByZWNlaXZlZC4gc3RhdHVzOicsIHhoci5zdGF0dXMsICdyZXNwb25zZTonLCB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0ganNvbkV2YWwoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MDEgYW5kIDQwNCBhcmUgZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSA0MDEgJiYgeGhyLnN0YXR1cyAhPT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdHb3QgdW5zdWNjZXNzZnVsIFJFU1QgcmVzcG9uc2UgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBTdGF0dXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIC8qYXN5bmNocm9ub3VzPSovIHRydWUpO1xyXG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNdXRhYmxlIG9iamVjdCB3aGljaCBiYXNpY2FsbHkganVzdCBzdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIFwibGF0ZXN0XCIgaW1tdXRhYmxlIHNuYXBzaG90LlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RIb2xkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZV8gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGdldE5vZGUocGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXy5nZXRDaGlsZChwYXRoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNuYXBzaG90KHBhdGgsIG5ld1NuYXBzaG90Tm9kZSkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gdGhpcy5yb290Tm9kZV8udXBkYXRlQ2hpbGQocGF0aCwgbmV3U25hcHNob3ROb2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgTWFwKClcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgZ2l2ZW4gbm9kZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlXHJcbiAqIGF0IGEgc2hhbGxvd2VyIHBhdGgsIGl0IG1lcmdlcyB0aGUgbmV3IGRhdGEgaW50byB0aGF0IHNuYXBzaG90IG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgbmV3IGRhdGEsIG9yIG51bGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgsIGRhdGEpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IGRhdGE7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUudXBkYXRlQ2hpbGQocGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoIXNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zZXQoY2hpbGRLZXksIG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkS2V5KTtcclxuICAgICAgICBwYXRoID0gcGF0aFBvcEZyb250KHBhdGgpO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKGNoaWxkLCBwYXRoLCBkYXRhKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHVyZ2UgdGhlIGRhdGEgYXQgcGF0aCBmcm9tIHRoZSBjYWNoZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbm9kZSBzaG91bGQgbm93IGJlIHJlbW92ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgdHJ5aW5nIHRvIGZvcmdldCBhIG5vZGUgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihzcGFyc2VTbmFwc2hvdFRyZWUsIG5ldyBQYXRoKGtleSksIHRyZWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aFBvcEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmhhcyhjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNhZmVUb1JlbW92ZSA9IHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkS2V5KSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2FmZVRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBpdGVyYXRlcyB0aHJvdWdoIGFsbCBvZiB0aGUgc3RvcmVkIHRyZWUgYW5kIGNhbGxzIHRoZVxyXG4gKiBjYWxsYmFjayBvbiBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIHByZWZpeFBhdGggLSBQYXRoIHRvIGxvb2sgdXAgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUoc3BhcnNlU25hcHNob3RUcmVlLCBwcmVmaXhQYXRoLCBmdW5jKSB7XHJcbiAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgZnVuYyhwcmVmaXhQYXRoLCBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgKGtleSwgdHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocHJlZml4UGF0aC50b1N0cmluZygpICsgJy8nICsga2V5KTtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUodHJlZSwgcGF0aCwgZnVuYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBpbW1lZGlhdGUgY2hpbGQgYW5kIHRyaWdnZXJzIHRoZSBjYWxsYmFjay5cclxuICogT25seSBzZWVtcyB0byBiZSB1c2VkIGluIHRlc3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoQ2hpbGQoc3BhcnNlU25hcHNob3RUcmVlLCBmdW5jKSB7XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZm9yRWFjaCgodHJlZSwga2V5KSA9PiB7XHJcbiAgICAgICAgZnVuYyhrZXksIHRyZWUpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgdG8gZ2V0IHN0YXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbl8gLSBUaGUgY29sbGVjdGlvbiB0byBcImxpc3RlblwiIHRvLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNMaXN0ZW5lciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uXykge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbl8gPSBjb2xsZWN0aW9uXztcclxuICAgICAgICB0aGlzLmxhc3RfID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICBjb25zdCBuZXdTdGF0cyA9IHRoaXMuY29sbGVjdGlvbl8uZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdTdGF0cyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdF8pIHtcclxuICAgICAgICAgICAgZWFjaCh0aGlzLmxhc3RfLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlbHRhW3N0YXRdID0gZGVsdGFbc3RhdF0gLSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdF8gPSBuZXdTdGF0cztcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQXNzdW1pbmcgc29tZSBhcHBzIG1heSBoYXZlIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgb24gcGFnZSwgYW5kIGEgYnVsayBvZiBmaXJlYmFzZSBvcGVyYXRpb25zIHByb2JhYmx5XHJcbi8vIGhhcHBlbiBvbiBwYWdlIGxvYWQsIHdlIHRyeSB0byByZXBvcnQgb3VyIGZpcnN0IHNldCBvZiBzdGF0cyBwcmV0dHkgcXVpY2tseSwgYnV0IHdlIHdhaXQgYXQgbGVhc3QgMTBcclxuLy8gc2Vjb25kcyB0byB0cnkgdG8gZW5zdXJlIHRoZSBGaXJlYmFzZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIC8gc2V0dGxlZC5cclxuY29uc3QgRklSU1RfU1RBVFNfTUlOX1RJTUUgPSAxMCAqIDEwMDA7XHJcbmNvbnN0IEZJUlNUX1NUQVRTX01BWF9USU1FID0gMzAgKiAxMDAwO1xyXG4vLyBXZSdsbCBjb250aW51ZSB0byByZXBvcnQgc3RhdHMgb24gYXZlcmFnZSBldmVyeSA1IG1pbnV0ZXMuXHJcbmNvbnN0IFJFUE9SVF9TVEFUU19JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XHJcbmNsYXNzIFN0YXRzUmVwb3J0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgc2VydmVyXykge1xyXG4gICAgICAgIHRoaXMuc2VydmVyXyA9IHNlcnZlcl87XHJcbiAgICAgICAgdGhpcy5zdGF0c1RvUmVwb3J0XyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBuZXcgU3RhdHNMaXN0ZW5lcihjb2xsZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gRklSU1RfU1RBVFNfTUlOX1RJTUUgK1xyXG4gICAgICAgICAgICAoRklSU1RfU1RBVFNfTUFYX1RJTUUgLSBGSVJTVF9TVEFUU19NSU5fVElNRSkgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzXygpIHtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHNMaXN0ZW5lcl8uZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgcmVwb3J0ZWRTdGF0cyA9IHt9O1xyXG4gICAgICAgIGxldCBoYXZlU3RhdHNUb1JlcG9ydCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goc3RhdHMsIChzdGF0LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwICYmIGNvbnRhaW5zKHRoaXMuc3RhdHNUb1JlcG9ydF8sIHN0YXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXBvcnRlZFN0YXRzW3N0YXRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBoYXZlU3RhdHNUb1JlcG9ydCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaGF2ZVN0YXRzVG9SZXBvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJfLnJlcG9ydFN0YXRzKHJlcG9ydGVkU3RhdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBxdWV1ZSBvdXIgbmV4dCBydW4uXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKHRoaXMucmVwb3J0U3RhdHNfLmJpbmQodGhpcyksIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIgKiBSRVBPUlRfU1RBVFNfSU5URVJWQUwpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICpcclxuICogQGVudW1cclxuICovXHJcbnZhciBPcGVyYXRpb25UeXBlO1xyXG4oZnVuY3Rpb24gKE9wZXJhdGlvblR5cGUpIHtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk9WRVJXUklURVwiXSA9IDBdID0gXCJPVkVSV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk1FUkdFXCJdID0gMV0gPSBcIk1FUkdFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJBQ0tfVVNFUl9XUklURVwiXSA9IDJdID0gXCJBQ0tfVVNFUl9XUklURVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTElTVEVOX0NPTVBMRVRFXCJdID0gM10gPSBcIkxJU1RFTl9DT01QTEVURVwiO1xyXG59KShPcGVyYXRpb25UeXBlIHx8IChPcGVyYXRpb25UeXBlID0ge30pKTtcclxuZnVuY3Rpb24gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IHRydWUsXHJcbiAgICAgICAgZnJvbVNlcnZlcjogZmFsc2UsXHJcbiAgICAgICAgcXVlcnlJZDogbnVsbCxcclxuICAgICAgICB0YWdnZWQ6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IGZhbHNlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IHRydWUsXHJcbiAgICAgICAgcXVlcnlJZDogbnVsbCxcclxuICAgICAgICB0YWdnZWQ6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IGZhbHNlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IHRydWUsXHJcbiAgICAgICAgcXVlcnlJZCxcclxuICAgICAgICB0YWdnZWQ6IHRydWVcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgQWNrVXNlcldyaXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFmZmVjdGVkVHJlZSAtIEEgdHJlZSBjb250YWluaW5nIHRydWUgZm9yIGVhY2ggYWZmZWN0ZWQgcGF0aC4gQWZmZWN0ZWQgcGF0aHMgY2FuJ3Qgb3ZlcmxhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcGF0aCwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gYWZmZWN0ZWRUcmVlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyByZXZlcnQpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlO1xyXG4gICAgICAgIHRoaXMucmV2ZXJ0ID0gcmV2ZXJ0O1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEU7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCk7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAoIXBhdGhJc0VtcHR5KHRoaXMucGF0aCkpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udCh0aGlzLnBhdGgpID09PSBjaGlsZE5hbWUsICdvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUocGF0aFBvcEZyb250KHRoaXMucGF0aCksIHRoaXMuYWZmZWN0ZWRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuYWZmZWN0ZWRUcmVlLmNoaWxkcmVuLmlzRW1wdHkoKSwgJ2FmZmVjdGVkVHJlZSBzaG91bGQgbm90IGhhdmUgb3ZlcmxhcHBpbmcgYWZmZWN0ZWQgcGF0aHMuJyk7XHJcbiAgICAgICAgICAgIC8vIEFsbCBjaGlsZCBsb2NhdGlvbnMgYXJlIGFmZmVjdGVkIGFzIHdlbGw7IGp1c3QgcmV0dXJuIHNhbWUgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuYWZmZWN0ZWRUcmVlLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKG5ld0VtcHR5UGF0aCgpLCBjaGlsZFRyZWUsIHRoaXMucmV2ZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTGlzdGVuQ29tcGxldGUge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgT3ZlcndyaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCwgc25hcCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLk9WRVJXUklURTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgdGhpcy5zbmFwLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLnNuYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZXJnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBzb3VyY2UsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5NRVJHRTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uc3VidHJlZShuZXcgUGF0aChjaGlsZE5hbWUpKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgdW5hZmZlY3RlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRUcmVlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc25hcHNob3QgZm9yIHRoZSBjaGlsZCBpbiBxdWVzdGlvbi4gIFRoaXMgYmVjb21lcyBhbiBvdmVyd3JpdGUgb2YgdGhlIGNoaWxkLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlIGF0IGEgZGVlcGVyIGxldmVsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udCh0aGlzLnBhdGgpID09PSBjaGlsZE5hbWUsIFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWVyZ2UodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCdPcGVyYXRpb24oJyArXHJcbiAgICAgICAgICAgIHRoaXMucGF0aCArXHJcbiAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyBtZXJnZTogJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4udG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY2FjaGUgbm9kZSBvbmx5IHN0b3JlcyBjb21wbGV0ZSBjaGlsZHJlbi4gQWRkaXRpb25hbGx5IGl0IGhvbGRzIGEgZmxhZyB3aGV0aGVyIHRoZSBub2RlIGNhbiBiZSBjb25zaWRlcmVkIGZ1bGx5XHJcbiAqIGluaXRpYWxpemVkIGluIHRoZSBzZW5zZSB0aGF0IHdlIGtub3cgYXQgb25lIHBvaW50IGluIHRpbWUgdGhpcyByZXByZXNlbnRlZCBhIHZhbGlkIHN0YXRlIG9mIHRoZSB3b3JsZCwgZS5nLlxyXG4gKiBpbml0aWFsaXplZCB3aXRoIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50LiBUaGUgZmlsdGVyZWQgZmxhZyBhbHNvIHRyYWNrc1xyXG4gKiB3aGV0aGVyIGEgbm9kZSBwb3RlbnRpYWxseSBoYWQgY2hpbGRyZW4gcmVtb3ZlZCBkdWUgdG8gYSBmaWx0ZXIuXHJcbiAqL1xyXG5jbGFzcyBDYWNoZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZV8sIGZ1bGx5SW5pdGlhbGl6ZWRfLCBmaWx0ZXJlZF8pIHtcclxuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XHJcbiAgICAgICAgdGhpcy5mdWxseUluaXRpYWxpemVkXyA9IGZ1bGx5SW5pdGlhbGl6ZWRfO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWRfID0gZmlsdGVyZWRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIHdhcyBmdWxseSBpbml0aWFsaXplZCB3aXRoIGVpdGhlciBzZXJ2ZXIgZGF0YSBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50XHJcbiAgICAgKi9cclxuICAgIGlzRnVsbHlJbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdWxseUluaXRpYWxpemVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBwb3RlbnRpYWxseSBtaXNzaW5nIGNoaWxkcmVuIGR1ZSB0byBhIGZpbHRlciBhcHBsaWVkIHRvIHRoZSBub2RlXHJcbiAgICAgKi9cclxuICAgIGlzRmlsdGVyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRfO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvclBhdGgocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlRm9yQ2hpbGQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF8pIHx8IHRoaXMubm9kZV8uaGFzQ2hpbGQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBFdmVudEdlbmVyYXRvciBpcyB1c2VkIHRvIGNvbnZlcnQgXCJyYXdcIiBjaGFuZ2VzIChDaGFuZ2UpIGFzIGNvbXB1dGVkIGJ5IHRoZVxyXG4gKiBDYWNoZURpZmZlciBpbnRvIGFjdHVhbCBldmVudHMgKEV2ZW50KSB0aGF0IGNhbiBiZSByYWlzZWQuICBTZWUgZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKClcclxuICogZm9yIGRldGFpbHMuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBFdmVudEdlbmVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8pIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmluZGV4XyA9IHRoaXMucXVlcnlfLl9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHNldCBvZiByYXcgY2hhbmdlcyAobm8gbW92ZWQgZXZlbnRzIGFuZCBwcmV2TmFtZSBub3Qgc3BlY2lmaWVkIHlldCksIGFuZCBhIHNldCBvZlxyXG4gKiBFdmVudFJlZ2lzdHJhdGlvbnMgdGhhdCBzaG91bGQgYmUgbm90aWZpZWQgb2YgdGhlc2UgY2hhbmdlcywgZ2VuZXJhdGUgdGhlIGFjdHVhbCBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogIC0gY2hpbGRfbW92ZWQgZXZlbnRzIHdpbGwgYmUgc3ludGhlc2l6ZWQgYXQgdGhpcyB0aW1lIGZvciBhbnkgY2hpbGRfY2hhbmdlZCBldmVudHMgdGhhdCBhZmZlY3RcclxuICogICAgb3VyIGluZGV4LlxyXG4gKiAgLSBwcmV2TmFtZSB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGluZGV4IG9yZGVyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9ucykge1xyXG4gICAgY29uc3QgZXZlbnRzID0gW107XHJcbiAgICBjb25zdCBtb3ZlcyA9IFtdO1xyXG4gICAgY2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8gJiZcclxuICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IuaW5kZXhfLmluZGV4ZWRWYWx1ZUNoYW5nZWQoY2hhbmdlLm9sZFNuYXAsIGNoYW5nZS5zbmFwc2hvdE5vZGUpKSB7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2goY2hhbmdlQ2hpbGRNb3ZlZChjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwiY2hpbGRfbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX01PVkVEICovLCBtb3ZlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogR2l2ZW4gY2hhbmdlcyBvZiBhIHNpbmdsZSBjaGFuZ2UgdHlwZSwgZ2VuZXJhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgZXZlbnRUeXBlLCBjaGFuZ2VzLCByZWdpc3RyYXRpb25zLCBldmVudENhY2hlKSB7XHJcbiAgICBjb25zdCBmaWx0ZXJlZENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcihjaGFuZ2UgPT4gY2hhbmdlLnR5cGUgPT09IGV2ZW50VHlwZSk7XHJcbiAgICBmaWx0ZXJlZENoYW5nZXMuc29ydCgoYSwgYikgPT4gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbGl6ZWRDaGFuZ2UgPSBldmVudEdlbmVyYXRvck1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2UsIGV2ZW50Q2FjaGUpO1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChyZWdpc3RyYXRpb24gPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLnJlc3BvbmRzVG8oY2hhbmdlLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaChyZWdpc3RyYXRpb24uY3JlYXRlRXZlbnQobWF0ZXJpYWxpemVkQ2hhbmdlLCBldmVudEdlbmVyYXRvci5xdWVyeV8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKSB7XHJcbiAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICd2YWx1ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdjaGlsZF9yZW1vdmVkJykge1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjaGFuZ2UucHJldk5hbWUgPSBldmVudENhY2hlLmdldFByZWRlY2Vzc29yQ2hpbGROYW1lKGNoYW5nZS5jaGlsZE5hbWUsIGNoYW5nZS5zbmFwc2hvdE5vZGUsIGV2ZW50R2VuZXJhdG9yLmluZGV4Xyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBldmVudEdlbmVyYXRvckNvbXBhcmVDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBhLCBiKSB7XHJcbiAgICBpZiAoYS5jaGlsZE5hbWUgPT0gbnVsbCB8fCBiLmNoaWxkTmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1Nob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShhLmNoaWxkTmFtZSwgYS5zbmFwc2hvdE5vZGUpO1xyXG4gICAgY29uc3QgYldyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGIuY2hpbGROYW1lLCBiLnNuYXBzaG90Tm9kZSk7XHJcbiAgICByZXR1cm4gZXZlbnRHZW5lcmF0b3IuaW5kZXhfLmNvbXBhcmUoYVdyYXBwZWQsIGJXcmFwcGVkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3Q2FjaGUoZXZlbnRDYWNoZSwgc2VydmVyQ2FjaGUpIHtcclxuICAgIHJldHVybiB7IGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudFNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcCh2aWV3Q2FjaGUsIHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkge1xyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcCh2aWV3Q2FjaGUpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKVxyXG4gICAgICAgID8gdmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKClcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gZW1wdHkgY2hpbGRyZW4gY29sbGVjdGlvbi5cclxuICpcclxuICovXHJcbmNvbnN0IEVtcHR5Q2hpbGRyZW4gPSAoKSA9PiB7XHJcbiAgICBpZiAoIWVtcHR5Q2hpbGRyZW5TaW5nbGV0b24pIHtcclxuICAgICAgICBlbXB0eUNoaWxkcmVuU2luZ2xldG9uID0gbmV3IFNvcnRlZE1hcChzdHJpbmdDb21wYXJlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG59O1xyXG4vKipcclxuICogQSB0cmVlIHdpdGggaW1tdXRhYmxlIGVsZW1lbnRzLlxyXG4gKi9cclxuY2xhc3MgSW1tdXRhYmxlVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hpbGRyZW4gPSBFbXB0eUNoaWxkcmVuKCkpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21PYmplY3Qob2JqKSB7XHJcbiAgICAgICAgbGV0IHRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICBlYWNoKG9iaiwgKGNoaWxkUGF0aCwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgIHRyZWUgPSB0cmVlLnNldChuZXcgUGF0aChjaGlsZFBhdGgpLCBjaGlsZFNuYXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG51bGwgJiYgdGhpcy5jaGlsZHJlbi5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgcGF0aCBhbmQgcHJlZGljYXRlLCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgYW5kIHRoZSBwYXRoIHRvIHRoYXQgbm9kZVxyXG4gICAgICogd2hlcmUgdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyBEbyBhIHBlcmYgdGVzdCAtLSBJZiB3ZSdyZSBjcmVhdGluZyBhIGJ1bmNoIG9mIGB7cGF0aDogdmFsdWU6fWBcclxuICAgICAqIG9iamVjdHMgb24gdGhlIHdheSBiYWNrIG91dCwgaXQgbWF5IGJlIGJldHRlciB0byBwYXNzIGRvd24gYSBwYXRoU29GYXIgb2JqLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBUaGUgcmVtYWluZGVyIG9mIHRoZSBwYXRoXHJcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIC0gVGhlIHByZWRpY2F0ZSB0byBzYXRpc2Z5IHRvIHJldHVybiBhIG5vZGVcclxuICAgICAqL1xyXG4gICAgZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHByZWRpY2F0ZSh0aGlzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBuZXdFbXB0eVBhdGgoKSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgPSBjaGlsZC5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgcHJlZGljYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aENoaWxkKG5ldyBQYXRoKGZyb250KSwgY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogZnVsbFBhdGgsIHZhbHVlOiBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlLnZhbHVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCwgaWYgaXQgZXhpc3RzLCB0aGUgc2hvcnRlc3Qgc3VicGF0aCBvZiB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHBvaW50cyBhIGRlZmluZWRcclxuICAgICAqIHZhbHVlIGluIHRoZSB0cmVlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsICgpID0+IHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3VidHJlZSBhdCB0aGUgZ2l2ZW4gcGF0aFxyXG4gICAgICovXHJcbiAgICBzdWJ0cmVlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLnN1YnRyZWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHNldCB2YWx1ZSBhdC5cclxuICAgICAqIEBwYXJhbSB0b1NldCAtIFZhbHVlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXQocmVsYXRpdmVQYXRoLCB0b1NldCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0b1NldCwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5zZXQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHRvU2V0KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHZhbHVlIHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQucmVtb3ZlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsICYmIG5ld0NoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFBhdGggdG8gZ2V0IHZhbHVlIGZvci5cclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHBhdGgsIG9yIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGdldChyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5nZXQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2UgdGhlIHN1YnRyZWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggdGhlIGdpdmVuIG5ldyB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHJlcGxhY2Ugc3VidHJlZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gbmV3VHJlZSAtIE5ldyB0cmVlLlxyXG4gICAgICogQHJldHVybnMgUmVzdWx0aW5nIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIHNldFRyZWUocmVsYXRpdmVQYXRoLCBuZXdUcmVlKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyZWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5zZXRUcmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCBuZXdUcmVlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBkZXB0aCBmaXJzdCBmb2xkIG9uIHRoaXMgdHJlZS4gVHJhbnNmb3JtcyBhIHRyZWUgaW50byBhIHNpbmdsZVxyXG4gICAgICogdmFsdWUsIGdpdmVuIGEgZnVuY3Rpb24gdGhhdCBvcGVyYXRlcyBvbiB0aGUgcGF0aCB0byBhIG5vZGUsIGFuIG9wdGlvbmFsXHJcbiAgICAgKiBjdXJyZW50IHZhbHVlLCBhbmQgYSBtYXAgb2YgY2hpbGQgbmFtZXMgdG8gZm9sZGVkIHN1YnRyZWVzXHJcbiAgICAgKi9cclxuICAgIGZvbGQoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkXyhuZXdFbXB0eVBhdGgoKSwgZm4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBwdWJsaWMtZmFjaW5nIGZvbGQoKSBtZXRob2RcclxuICAgICAqL1xyXG4gICAgZm9sZF8ocGF0aFNvRmFyLCBmbikge1xyXG4gICAgICAgIGNvbnN0IGFjY3VtID0ge307XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGFjY3VtW2NoaWxkS2V5XSA9IGNoaWxkVHJlZS5mb2xkXyhwYXRoQ2hpbGQocGF0aFNvRmFyLCBjaGlsZEtleSksIGZuKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm4ocGF0aFNvRmFyLCB0aGlzLnZhbHVlLCBhY2N1bSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGZpcnN0IG1hdGNoaW5nIHZhbHVlIG9uIHRoZSBnaXZlbiBwYXRoLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBhcHBseWluZyBmIHRvIGl0LlxyXG4gICAgICovXHJcbiAgICBmaW5kT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmaW5kT25QYXRoXyhwYXRoVG9Gb2xsb3csIHBhdGhTb0ZhciwgZikge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsdWUgPyBmKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSkgOiBmYWxzZTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoVG9Gb2xsb3cpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZmluZE9uUGF0aF8ocGF0aFBvcEZyb250KHBhdGhUb0ZvbGxvdyksIHBhdGhDaGlsZChwYXRoU29GYXIsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcmVhY2hPblBhdGgocGF0aCwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcmVhY2hPblBhdGhfKHBhdGgsIG5ld0VtcHR5UGF0aCgpLCBmKTtcclxuICAgIH1cclxuICAgIGZvcmVhY2hPblBhdGhfKHBhdGhUb0ZvbGxvdywgY3VycmVudFJlbGF0aXZlUGF0aCwgZikge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoVG9Gb2xsb3cpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZvcmVhY2hPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQoY3VycmVudFJlbGF0aXZlUGF0aCwgZnJvbnQpLCBmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBoYXMgYSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZiAtIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0b1xyXG4gICAgICogYSBub2RlLCBhbmQgdGhlIHZhbHVlIGF0IHRoYXQgbm9kZS4gQ2FsbGVkIGluIGRlcHRoLWZpcnN0IG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBmb3JlYWNoKGYpIHtcclxuICAgICAgICB0aGlzLmZvcmVhY2hfKG5ld0VtcHR5UGF0aCgpLCBmKTtcclxuICAgIH1cclxuICAgIGZvcmVhY2hfKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNoaWxkVHJlZS5mb3JlYWNoXyhwYXRoQ2hpbGQoY3VycmVudFJlbGF0aXZlUGF0aCwgY2hpbGROYW1lKSwgZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoQ2hpbGQoZikge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZihjaGlsZE5hbWUsIGNoaWxkVHJlZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygd3JpdGVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gbm9kZXMgaW4gdW5pc29uLiBJdCBhYnN0cmFjdHMgYXdheSB0aGUgbG9naWMgd2l0aFxyXG4gKiBkZWFsaW5nIHdpdGggcHJpb3JpdHkgd3JpdGVzIGFuZCBtdWx0aXBsZSBuZXN0ZWQgd3JpdGVzLiBBdCBhbnkgZ2l2ZW4gcGF0aCB0aGVyZSBpcyBvbmx5IGFsbG93ZWQgdG8gYmUgb25lIHdyaXRlXHJcbiAqIG1vZGlmeWluZyB0aGF0IHBhdGguIEFueSB3cml0ZSB0byBhbiBleGlzdGluZyBwYXRoIG9yIHNoYWRvd2luZyBhbiBleGlzdGluZyBwYXRoIHdpbGwgbW9kaWZ5IHRoYXQgZXhpc3Rpbmcgd3JpdGVcclxuICogdG8gcmVmbGVjdCB0aGUgd3JpdGUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBDb21wb3VuZFdyaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHdyaXRlVHJlZV8pIHtcclxuICAgICAgICB0aGlzLndyaXRlVHJlZV8gPSB3cml0ZVRyZWVfO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgsIG5vZGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShub2RlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCByb290bW9zdCA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5maW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocGF0aCk7XHJcbiAgICAgICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdE1vc3RQYXRoID0gcm9vdG1vc3QucGF0aDtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gcm9vdG1vc3QudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChyb290TW9zdFBhdGgsIHBhdGgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0KHJvb3RNb3N0UGF0aCwgdmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShub2RlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3V3JpdGVUcmVlID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgc3VidHJlZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIHBhdGgsIHVwZGF0ZXMpIHtcclxuICAgIGxldCBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGU7XHJcbiAgICBlYWNoKHVwZGF0ZXMsIChjaGlsZEtleSwgbm9kZSkgPT4ge1xyXG4gICAgICAgIG5ld1dyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKG5ld1dyaXRlLCBwYXRoQ2hpbGQocGF0aCwgY2hpbGRLZXkpLCBub2RlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld1dyaXRlO1xyXG59XHJcbi8qKlxyXG4gKiBXaWxsIHJlbW92ZSBhIHdyaXRlIGF0IHRoZSBnaXZlbiBwYXRoIGFuZCBkZWVwZXIgcGF0aHMuIFRoaXMgd2lsbCA8ZW0+bm90PC9lbT4gbW9kaWZ5IGEgd3JpdGUgYXQgYSBoaWdoZXJcclxuICogbG9jYXRpb24sIHdoaWNoIG11c3QgYmUgcmVtb3ZlZCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggdGhhdCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIHJlbW92ZS5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBhdCB3aGljaCBhIHdyaXRlIGFuZCBhbGwgZGVlcGVyIHdyaXRlcyBzaG91bGQgYmUgcmVtb3ZlZFxyXG4gKiBAcmV0dXJucyBUaGUgbmV3IENvbXBvdW5kV3JpdGUgd2l0aCB0aGUgcmVtb3ZlZCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIG5ldyBJbW11dGFibGVUcmVlKG51bGwpKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSB3aWxsIGZ1bGx5IG92ZXJ3cml0ZSBhIG5vZGUgYXQgYSBnaXZlbiBsb2NhdGlvbiBhbmQgY2FuIHRoZXJlZm9yZSBiZVxyXG4gKiBjb25zaWRlcmVkIFwiY29tcGxldGVcIi5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byBjaGVjay5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVjayBmb3JcclxuICogQHJldHVybnMgV2hldGhlciB0aGVyZSBpcyBhIGNvbXBsZXRlIHdyaXRlIGF0IHRoYXQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCkgIT0gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgZm9yIGEgcGF0aCBpZiBhbmQgb25seSBpZiB0aGUgbm9kZSBpcyBhIFwiY29tcGxldGVcIiBvdmVyd3JpdGUgYXQgdGhhdCBwYXRoLiBUaGlzIHdpbGwgbm90IGFnZ3JlZ2F0ZVxyXG4gKiB3cml0ZXMgZnJvbSBkZWVwZXIgcGF0aHMsIGJ1dCB3aWxsIHJldHVybiBjaGlsZCBub2RlcyBmcm9tIGEgbW9yZSBzaGFsbG93IHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IHRoZSBub2RlIGZyb20uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gZ2V0IGEgY29tcGxldGUgd3JpdGVcclxuICogQHJldHVybnMgVGhlIG5vZGUgaWYgY29tcGxldGUgYXQgdGhhdCBwYXRoLCBvciBudWxsIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfXHJcbiAgICAgICAgICAgIC5nZXQocm9vdG1vc3QucGF0aClcclxuICAgICAgICAgICAgLmdldENoaWxkKG5ld1JlbGF0aXZlUGF0aChyb290bW9zdC5wYXRoLCBwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbGwgY2hpbGRyZW4gdGhhdCBhcmUgZ3VhcmFudGVlZCB0byBiZSBhIGNvbXBsZXRlIG92ZXJ3cml0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byBnZXQgY2hpbGRyZW4gZnJvbS5cclxuICogQHJldHVybnMgQSBsaXN0IG9mIGFsbCBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKGNvbXBvdW5kV3JpdGUpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnZhbHVlO1xyXG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIElmIGl0J3MgYSBsZWFmIG5vZGUsIGl0IGhhcyBubyBjaGlsZHJlbjsgc28gbm90aGluZyB0byBkby5cclxuICAgICAgICBpZiAoIW5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShjb21wb3VuZFdyaXRlLCBwYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShzaGFkb3dpbmdOb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnN1YnRyZWUocGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eSBhbmQgdGhlcmVmb3JlIGRvZXMgbm90IG1vZGlmeSBhbnkgbm9kZXMuXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlSXNFbXB0eShjb21wb3VuZFdyaXRlKSB7XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmlzRW1wdHkoKTtcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGlzIENvbXBvdW5kV3JpdGUgdG8gYSBub2RlLiBUaGUgbm9kZSBpcyByZXR1cm5lZCB3aXRoIGFsbCB3cml0ZXMgZnJvbSB0aGlzIENvbXBvdW5kV3JpdGUgYXBwbGllZCB0byB0aGVcclxuICogbm9kZVxyXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGFwcGx5IHRoaXMgQ29tcG91bmRXcml0ZSB0b1xyXG4gKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIGFsbCB3cml0ZXMgYXBwbGllZFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGUsIG5vZGUpIHtcclxuICAgIHJldHVybiBhcHBseVN1YnRyZWVXcml0ZShuZXdFbXB0eVBhdGgoKSwgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVN1YnRyZWVXcml0ZShyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZSwgbm9kZSkge1xyXG4gICAgaWYgKHdyaXRlVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlcmUgYSB3cml0ZSBpcyBhbHdheXMgYSBsZWFmLCB3ZSdyZSBkb25lIGhlcmVcclxuICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcHJpb3JpdHlXcml0ZSA9IG51bGw7XHJcbiAgICAgICAgd3JpdGVUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcHJpb3JpdGllcyBhdCB0aGUgZW5kIHNvIHdlIGRvbid0IHVwZGF0ZSBwcmlvcml0aWVzIGZvciBlaXRoZXIgZW1wdHkgbm9kZXMgb3IgZm9yZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyB0byBhcHBseSBwcmlvcml0aWVzIHRvIGVtcHR5IG5vZGVzIHRoYXQgYXJlIGxhdGVyIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNoaWxkVHJlZS52YWx1ZSAhPT0gbnVsbCwgJ1ByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzJyk7XHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eVdyaXRlID0gY2hpbGRUcmVlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGFwcGx5U3VidHJlZVdyaXRlKHBhdGhDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkS2V5KSwgY2hpbGRUcmVlLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByaW9yaXR5IHdyaXRlLCB3ZSBvbmx5IGFwcGx5IGl0IGlmIHRoZSBub2RlIGlzIG5vdCBlbXB0eVxyXG4gICAgICAgIGlmICghbm9kZS5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpLmlzRW1wdHkoKSAmJiBwcmlvcml0eVdyaXRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUNoaWxkKHBhdGhDaGlsZChyZWxhdGl2ZVBhdGgsICcucHJpb3JpdHknKSwgcHJpb3JpdHlXcml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgV3JpdGVUcmVlUmVmIGZvciB0aGUgZ2l2ZW4gcGF0aC4gRm9yIHVzZSB3aXRoIGEgbmV3IHN5bmMgcG9pbnQgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDaGlsZFdyaXRlcyh3cml0ZVRyZWUsIHBhdGgpIHtcclxuICAgIHJldHVybiBuZXdXcml0ZVRyZWVSZWYocGF0aCwgd3JpdGVUcmVlKTtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG92ZXJ3cml0ZSBmcm9tIHVzZXIgY29kZS5cclxuICpcclxuICogQHBhcmFtIHZpc2libGUgLSBUaGlzIGlzIHNldCB0byBmYWxzZSBieSBzb21lIHRyYW5zYWN0aW9ucy4gSXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZXZlbnQgY2FjaGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVBZGRPdmVyd3JpdGUod3JpdGVUcmVlLCBwYXRoLCBzbmFwLCB3cml0ZUlkLCB2aXNpYmxlKSB7XHJcbiAgICBhc3NlcnQod3JpdGVJZCA+IHdyaXRlVHJlZS5sYXN0V3JpdGVJZCwgJ1N0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XHJcbiAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmlzaWJsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB3cml0ZVRyZWUuYWxsV3JpdGVzLnB1c2goe1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgc25hcCxcclxuICAgICAgICB3cml0ZUlkLFxyXG4gICAgICAgIHZpc2libGVcclxuICAgIH0pO1xyXG4gICAgaWYgKHZpc2libGUpIHtcclxuICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCwgc25hcCk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvcmQgYSBuZXcgbWVyZ2UgZnJvbSB1c2VyIGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVBZGRNZXJnZSh3cml0ZVRyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciBtZXJnZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIGNoaWxkcmVuOiBjaGFuZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IHdyaXRlSWQ7XHJcbn1cclxuZnVuY3Rpb24gd3JpdGVUcmVlR2V0V3JpdGUod3JpdGVUcmVlLCB3cml0ZUlkKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCByZWNvcmQgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChyZWNvcmQud3JpdGVJZCA9PT0gd3JpdGVJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgYSB3cml0ZSAoZWl0aGVyIGFuIG92ZXJ3cml0ZSBvciBtZXJnZSkgdGhhdCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYWNrbm93bGVkZ2UgYnkgdGhlIHNlcnZlci4gUmVjYWxjdWxhdGVzXHJcbiAqIHRoZSB0cmVlIGlmIG5lY2Vzc2FyeS4gIFdlIHJldHVybiB0cnVlIGlmIGl0IG1heSBoYXZlIGJlZW4gdmlzaWJsZSwgbWVhbmluZyB2aWV3cyBuZWVkIHRvIHJlZXZhbHVhdGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHdyaXRlIG1heSBoYXZlIGJlZW4gdmlzaWJsZSAobWVhbmluZyB3ZSdsbCBuZWVkIHRvIHJlZXZhbHVhdGUgLyByYWlzZVxyXG4gKiBldmVudHMgYXMgYSByZXN1bHQpLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVtb3ZlV3JpdGUod3JpdGVUcmVlLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBOb3RlOiBkaXNhYmxpbmcgdGhpcyBjaGVjay4gSXQgY291bGQgYmUgYSB0cmFuc2FjdGlvbiB0aGF0IHByZWVtcHRlZCBhbm90aGVyIHRyYW5zYWN0aW9uLCBhbmQgdGh1cyB3YXMgYXBwbGllZFxyXG4gICAgLy8gb3V0IG9mIG9yZGVyLlxyXG4gICAgLy9jb25zdCB2YWxpZENsZWFyID0gcmV2ZXJ0IHx8IHRoaXMuYWxsV3JpdGVzXy5sZW5ndGggPT09IDAgfHwgd3JpdGVJZCA8PSB0aGlzLmFsbFdyaXRlc19bMF0ud3JpdGVJZDtcclxuICAgIC8vYXNzZXJ0KHZhbGlkQ2xlYXIsIFwiRWl0aGVyIHdlIGRvbid0IGhhdmUgdGhpcyB3cml0ZSwgb3IgaXQncyB0aGUgZmlyc3Qgb25lIGluIHRoZSBxdWV1ZVwiKTtcclxuICAgIGNvbnN0IGlkeCA9IHdyaXRlVHJlZS5hbGxXcml0ZXMuZmluZEluZGV4KHMgPT4ge1xyXG4gICAgICAgIHJldHVybiBzLndyaXRlSWQgPT09IHdyaXRlSWQ7XHJcbiAgICB9KTtcclxuICAgIGFzc2VydChpZHggPj0gMCwgJ3JlbW92ZVdyaXRlIGNhbGxlZCB3aXRoIG5vbmV4aXN0ZW50IHdyaXRlSWQuJyk7XHJcbiAgICBjb25zdCB3cml0ZVRvUmVtb3ZlID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpZHhdO1xyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gd3JpdGVUb1JlbW92ZS52aXNpYmxlO1xyXG4gICAgbGV0IHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gZmFsc2U7XHJcbiAgICBsZXQgaSA9IHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChyZW1vdmVkV3JpdGVXYXNWaXNpYmxlICYmIGkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXcml0ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRXcml0ZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpID49IGlkeCAmJlxyXG4gICAgICAgICAgICAgICAgd3JpdGVUcmVlUmVjb3JkQ29udGFpbnNQYXRoXyhjdXJyZW50V3JpdGUsIHdyaXRlVG9SZW1vdmUucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIHdyaXRlIHdhcyBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IGEgc3Vic2VxdWVudCB3cml0ZS5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXcml0ZVdhc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRoQ29udGFpbnMod3JpdGVUb1JlbW92ZS5wYXRoLCBjdXJyZW50V3JpdGUucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB3ZSdyZSBjb3ZlcmluZyBzb21lIHdyaXRlcyBvciB0aGV5J3JlIGNvdmVyaW5nIHBhcnQgb2YgdXMgKGRlcGVuZGluZyBvbiB3aGljaCBjYW1lIGZpcnN0KS5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpLS07XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlbW92ZWRXcml0ZVdhc1Zpc2libGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcykge1xyXG4gICAgICAgIC8vIFRoZXJlJ3Mgc29tZSBzaGFkb3dpbmcgZ29pbmcgb24uIEp1c3QgcmVidWlsZCB0aGUgdmlzaWJsZSB3cml0ZXMgZnJvbSBzY3JhdGNoLlxyXG4gICAgICAgIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gc2hhZG93aW5nLiAgV2UgY2FuIHNhZmVseSBqdXN0IHJlbW92ZSB0aGUgd3JpdGUocykgZnJvbSB2aXNpYmxlV3JpdGVzLlxyXG4gICAgICAgIGlmICh3cml0ZVRvUmVtb3ZlLnNuYXApIHtcclxuICAgICAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHdyaXRlVG9SZW1vdmUucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHdyaXRlVG9SZW1vdmUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGVhY2goY2hpbGRyZW4sIChjaGlsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoQ2hpbGQod3JpdGVUb1JlbW92ZS5wYXRoLCBjaGlsZE5hbWUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8od3JpdGVSZWNvcmQsIHBhdGgpIHtcclxuICAgIGlmICh3cml0ZVJlY29yZC5zbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWlucyh3cml0ZVJlY29yZC5wYXRoLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGROYW1lIGluIHdyaXRlUmVjb3JkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmICh3cml0ZVJlY29yZC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShjaGlsZE5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICBwYXRoQ29udGFpbnMocGF0aENoaWxkKHdyaXRlUmVjb3JkLnBhdGgsIGNoaWxkTmFtZSksIHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlLWxheWVyIHRoZSB3cml0ZXMgYW5kIG1lcmdlcyBpbnRvIGEgdHJlZSBzbyB3ZSBjYW4gZWZmaWNpZW50bHkgY2FsY3VsYXRlIGV2ZW50IHNuYXBzaG90c1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVzZXRUcmVlXyh3cml0ZVRyZWUpIHtcclxuICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCB3cml0ZVRyZWVEZWZhdWx0RmlsdGVyXywgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS5hbGxXcml0ZXNbd3JpdGVUcmVlLmFsbFdyaXRlcy5sZW5ndGggLSAxXS53cml0ZUlkO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGZpbHRlciB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSB0cmVlLiBLZWVwIGV2ZXJ5dGhpbmcgdGhhdCdzIHZpc2libGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVEZWZhdWx0RmlsdGVyXyh3cml0ZSkge1xyXG4gICAgcmV0dXJuIHdyaXRlLnZpc2libGU7XHJcbn1cclxuLyoqXHJcbiAqIFN0YXRpYyBtZXRob2QuIEdpdmVuIGFuIGFycmF5IG9mIFdyaXRlUmVjb3JkcywgYSBmaWx0ZXIgZm9yIHdoaWNoIG9uZXMgdG8gaW5jbHVkZSwgYW5kIGEgcGF0aCwgY29uc3RydWN0IHRoZSB0cmVlIG9mXHJcbiAqIGV2ZW50IGRhdGEgYXQgdGhhdCBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZXMsIGZpbHRlciwgdHJlZVJvb3QpIHtcclxuICAgIGxldCBjb21wb3VuZFdyaXRlID0gQ29tcG91bmRXcml0ZS5lbXB0eSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCB3cml0ZSA9IHdyaXRlc1tpXTtcclxuICAgICAgICAvLyBUaGVvcnksIGEgbGF0ZXIgc2V0IHdpbGwgZWl0aGVyOlxyXG4gICAgICAgIC8vIGEpIGFib3J0IGEgcmVsZXZhbnQgdHJhbnNhY3Rpb24sIHNvIG5vIG5lZWQgdG8gd29ycnkgYWJvdXQgZXhjbHVkaW5nIGl0IGZyb20gY2FsY3VsYXRpbmcgdGhhdCB0cmFuc2FjdGlvblxyXG4gICAgICAgIC8vIGIpIG5vdCBiZSByZWxldmFudCB0byBhIHRyYW5zYWN0aW9uIChzZXBhcmF0ZSBicmFuY2gpLCBzbyBhZ2FpbiB3aWxsIG5vdCBhZmZlY3QgdGhlIGRhdGEgZm9yIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICBpZiAoZmlsdGVyKHdyaXRlKSkge1xyXG4gICAgICAgICAgICBjb25zdCB3cml0ZVBhdGggPSB3cml0ZS5wYXRoO1xyXG4gICAgICAgICAgICBsZXQgcmVsYXRpdmVQYXRoO1xyXG4gICAgICAgICAgICBpZiAod3JpdGUuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHJlbGF0aXZlUGF0aCwgd3JpdGUuc25hcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoQ29udGFpbnMod3JpdGVQYXRoLCB0cmVlUm9vdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuc25hcC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW5zKHRyZWVSb290LCB3cml0ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIHJlbGF0aXZlUGF0aCwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIG5ld0VtcHR5UGF0aCgpLCB3cml0ZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNhZmVHZXQod3JpdGUuY2hpbGRyZW4sIHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBleGlzdHMgYSBjaGlsZCBpbiB0aGlzIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSByb290IHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZXBOb2RlID0gY2hpbGQuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgZGVlcE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignV3JpdGVSZWNvcmQgc2hvdWxkIGhhdmUgLnNuYXAgb3IgLmNoaWxkcmVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGFuZCBhbiBvcHRpb25hbCBzZXQgb2YgY29uc3RyYWludHMgKGV4Y2x1ZGUgc29tZSBzZXRzLCBpbmNsdWRlIGhpZGRlblxyXG4gKiB3cml0ZXMpLCBhdHRlbXB0IHRvIGNhbGN1bGF0ZSBhIGNvbXBsZXRlIHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gcGF0aFxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBBbiBvcHRpb25hbCBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcclxuICAgIGlmICghd3JpdGVJZHNUb0V4Y2x1ZGUgJiYgIWluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcclxuICAgICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KHN1Yk1lcmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUoc3ViTWVyZ2UsIG5ld0VtcHR5UGF0aCgpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd291bGRuJ3QgaGF2ZSBhIGNvbXBsZXRlIHNuYXBzaG90LCBzaW5jZSB0aGVyZSdzIG5vIHVuZGVybHlpbmcgZGF0YSBhbmQgbm8gY29tcGxldGUgc2hhZG93XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KHN1Yk1lcmdlLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmIGNvbXBvdW5kV3JpdGVJc0VtcHR5KG1lcmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVTZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgY2FjaGUgaXMgbnVsbCwgYW5kIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZSBjYWNoZSwgd2UgbmVlZCB0byByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICBpZiAoIWluY2x1ZGVIaWRkZW5Xcml0ZXMgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKG1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZnVuY3Rpb24gKHdyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgod3JpdGUudmlzaWJsZSB8fCBpbmNsdWRlSGlkZGVuV3JpdGVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXdyaXRlSWRzVG9FeGNsdWRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhfndyaXRlSWRzVG9FeGNsdWRlLmluZGV4T2Yod3JpdGUud3JpdGVJZCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoQ29udGFpbnMod3JpdGUucGF0aCwgdHJlZVBhdGgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ29udGFpbnModHJlZVBhdGgsIHdyaXRlLnBhdGgpKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VBdFBhdGggPSB3cml0ZVRyZWVMYXllclRyZWVfKHdyaXRlVHJlZS5hbGxXcml0ZXMsIGZpbHRlciwgdHJlZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkobWVyZ2VBdFBhdGgsIGxheWVyZWRDYWNoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdpdGggb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGF0dGVtcHQgdG8gcmV0dXJuIGEgY2hpbGRyZW4gbm9kZSBvZiBjaGlsZHJlbiB0aGF0IHdlIGhhdmUgY29tcGxldGUgZGF0YSBmb3IuXHJcbiAqIFVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmlld3MsIHRvIHByZS1maWxsIHRoZWlyIGNvbXBsZXRlIGV2ZW50IGNoaWxkcmVuIHNuYXBzaG90LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKSB7XHJcbiAgICBsZXQgY29tcGxldGVDaGlsZHJlbiA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgY29uc3QgdG9wTGV2ZWxTZXQgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBpZiAodG9wTGV2ZWxTZXQpIHtcclxuICAgICAgICBpZiAoIXRvcExldmVsU2V0LmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBzaGFkb3dpbmcgZXZlcnl0aGluZy4gUmV0dXJuIHRoZSBjaGlsZHJlbi5cclxuICAgICAgICAgICAgdG9wTGV2ZWxTZXQuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZFNuYXApID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgICAgIC8vIExheWVyIGFueSBjaGlsZHJlbiB3ZSBoYXZlIG9uIHRvcCBvZiB0aGlzXHJcbiAgICAgICAgLy8gV2Uga25vdyB3ZSBkb24ndCBoYXZlIGEgdG9wLWxldmVsIHNldCwgc28ganVzdCBlbnVtZXJhdGUgZXhpc3RpbmcgY2hpbGRyZW5cclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wbGV0ZVNlcnZlckNoaWxkcmVuLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjb21wb3VuZFdyaXRlQXBwbHkoY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZShtZXJnZSwgbmV3IFBhdGgoY2hpbGROYW1lKSksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQWRkIGFueSBjb21wbGV0ZSBjaGlsZHJlbiB3ZSBoYXZlIGZyb20gdGhlIHNldFxyXG4gICAgICAgIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKG1lcmdlKS5mb3JFYWNoKG5hbWVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGFueXRoaW5nIHRvIGxheWVyIG9uIHRvcCBvZi4gTGF5ZXIgb24gYW55IGNoaWxkcmVuIHdlIGhhdmVcclxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2FuIHJldHVybiBhbiBlbXB0eSBzbmFwIGlmIHdlIGhhdmUgYSBkZWZpbmVkIGRlbGV0ZVxyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKG1lcmdlKS5mb3JFYWNoKG5hbWVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaGFzIHVwZGF0ZWQsIGRldGVybWluZSB3aGF0LCBpZiBhbnl0aGluZywgbmVlZHMgdG8gYmVcclxuICogYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXHJcbiAqXHJcbiAqIFBvc3NpYmlsaXRpZXM6XHJcbiAqXHJcbiAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxyXG4gKlxyXG4gKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXHJcbiAqXHJcbiAqIDMuIElzIHBhcnRpYWxseSBzaGFkb3dlZC4gRXZlbnRzXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZFBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIGFzc2VydChleGlzdGluZ0V2ZW50U25hcCB8fCBleGlzdGluZ1NlcnZlclNuYXAsICdFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QnKTtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoQ2hpbGQodHJlZVBhdGgsIGNoaWxkUGF0aCk7XHJcbiAgICBpZiAoY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpKSB7XHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjYW4gcHJvYmFibHkgZ3VhcmFudGVlIHRoYXQgd2UncmUgaW4gY2FzZSAyLCBtZWFuaW5nIG5vIGV2ZW50c1xyXG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGNoZWNrIHZpc2liaWxpdHkgd2hpbGUgZG9pbmcgdGhlIGZpbmRSb290TW9zdFZhbHVlQW5kUGF0aCBjYWxsXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBObyBjb21wbGV0ZSBzaGFkb3dpbmcuIFdlJ3JlIGVpdGhlciBwYXJ0aWFsbHkgc2hhZG93aW5nIG9yIG5vdCBzaGFkb3dpbmcgYXQgYWxsLlxyXG4gICAgICAgIGNvbnN0IGNoaWxkTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxuICAgICAgICBpZiAoY29tcG91bmRXcml0ZUlzRW1wdHkoY2hpbGRNZXJnZSkpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHNoYWRvd2luZyBhdCBhbGwuIENhc2UgMVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIHRoZSBzZXJ2ZXJOb2RlICsgdXBkYXRlcyBkb2Vzbid0IGNoYW5nZSB0aGUgZXZlbnRTbmFwXHJcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBpcyB0cmlja3kgdG8gZmluZCBvdXQsIHNpbmNlIHVzZXIgdXBkYXRlcyBkb24ndCBuZWNlc3NhcnkgY2hhbmdlIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgLy8gc25hcCwgZS5nLiBwcmlvcml0eSB1cGRhdGVzIG9uIGVtcHR5IG5vZGVzLCBvciBkZWVwIGRlbGV0ZXMuIEFub3RoZXIgc3BlY2lhbCBjYXNlIGlzIGlmIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgLy8gYWRkcyBub2RlcywgYnV0IGRvZXNuJ3QgY2hhbmdlIGFueSBleGlzdGluZyB3cml0ZXMuIEl0IGlzIHRoZXJlZm9yZSBub3QgZW5vdWdoIHRvXHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgaWYgdGhlIHVwZGF0ZXMgY2hhbmdlIHRoZSBzZXJ2ZXJOb2RlLlxyXG4gICAgICAgICAgICAvLyBNYXliZSBjaGVjayBpZiB0aGUgbWVyZ2UgdHJlZSBjb250YWlucyB0aGVzZSBzcGVjaWFsIGNhc2VzIGFuZCBvbmx5IGRvIGEgZnVsbCBvdmVyd3JpdGUgaW4gdGhhdCBjYXNlP1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xyXG4gKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoQ2hpbGQodHJlZVBhdGgsIGNoaWxkS2V5KTtcclxuICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxuICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChleGlzdGluZ1NlcnZlclNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkoY2hpbGRNZXJnZSwgZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxyXG4gKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxyXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlU2hhZG93aW5nV3JpdGUod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjSW5kZXhlZFNsaWNlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpIHtcclxuICAgIGxldCB0b0l0ZXJhdGU7XHJcbiAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKG1lcmdlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdG9JdGVyYXRlID0gc2hhZG93aW5nTm9kZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyRGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgdG9JdGVyYXRlID0gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlLCBjb21wbGV0ZVNlcnZlckRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm8gY2hpbGRyZW4gdG8gaXRlcmF0ZSBvblxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHRvSXRlcmF0ZSA9IHRvSXRlcmF0ZS53aXRoSW5kZXgoaW5kZXgpO1xyXG4gICAgaWYgKCF0b0l0ZXJhdGUuaXNFbXB0eSgpICYmICF0b0l0ZXJhdGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBjbXAgPSBpbmRleC5nZXRDb21wYXJlKCk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHJldmVyc2VcclxuICAgICAgICAgICAgPyB0b0l0ZXJhdGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KVxyXG4gICAgICAgICAgICA6IHRvSXRlcmF0ZS5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCAmJiBub2Rlcy5sZW5ndGggPCBjb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoY21wKG5leHQsIHN0YXJ0UG9zdCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3V3JpdGVUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2aXNpYmxlV3JpdGVzOiBDb21wb3VuZFdyaXRlLmVtcHR5KCksXHJcbiAgICAgICAgYWxsV3JpdGVzOiBbXSxcclxuICAgICAgICBsYXN0V3JpdGVJZDogLTFcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY29tcGxldGUgZXZlbnQgY2FjaGUsIHVzaW5nIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGlmIHBvc3NpYmxlLiBJbiBhZGRpdGlvbiwgY2FuIGJlIHVzZWRcclxuICogdG8gZ2V0IGEgY2FjaGUgdGhhdCBpbmNsdWRlcyBoaWRkZW4gd3JpdGVzLCBhbmQgZXhjbHVkZXMgYXJiaXRyYXJ5IHdyaXRlcy4gTm90ZSB0aGF0IGN1c3RvbWl6aW5nIHRoZSByZXR1cm5lZCBub2RlXHJcbiAqIGNhbiBsZWFkIHRvIGEgbW9yZSBleHBlbnNpdmUgY2FsY3VsYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB3cml0ZUlkc1RvRXhjbHVkZSAtIE9wdGlvbmFsIHdyaXRlcyB0byBleGNsdWRlLlxyXG4gKiBAcGFyYW0gaW5jbHVkZUhpZGRlbldyaXRlcyAtIERlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIG9yIG5vdCB0byBsYXllciBvbiB3cml0ZXMgd2l0aCB2aXNpYmxlIHNldCB0byBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKTtcclxufVxyXG4vKipcclxuICogSWYgcG9zc2libGUsIHJldHVybnMgYSBjaGlsZHJlbiBub2RlIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjb21wbGV0ZSBjaGlsZHJlbiB3ZSBoYXZlIGRhdGEgZm9yLiBUaGUgcmV0dXJuZWQgZGF0YSBpcyBhXHJcbiAqIG1peCBvZiB0aGUgZ2l2ZW4gc2VydmVyIGRhdGEgYW5kIHdyaXRlIGRhdGEuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZiwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gdGhhdCBlaXRoZXIgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaGFzIHVwZGF0ZWQgb3IgdGhlIG91dHN0YW5kaW5nIHdyaXRlcyBoYXZlIHVwZGF0ZWQsIGRldGVybWluZSB3aGF0LFxyXG4gKiBpZiBhbnl0aGluZywgbmVlZHMgdG8gYmUgYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXHJcbiAqXHJcbiAqIFBvc3NpYmlsaXRpZXM6XHJcbiAqXHJcbiAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxyXG4gKlxyXG4gKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXHJcbiAqXHJcbiAqIDMuIElzIHBhcnRpYWxseSBzaGFkb3dlZC4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWRcclxuICpcclxuICogRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0LCB0aGlzIGlzIHZhbGlkYXRlZCB2aWEgYW4gYXNzZXJ0XHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZiwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZVJlZiwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcclxuICogdGhlIHdpbmRvdywgYnV0IG1heSBub3cgYmUgaW4gdGhlIHdpbmRvd1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjSW5kZXhlZFNsaWNlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xyXG4gKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyQ2FjaGUpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgV3JpdGVUcmVlUmVmIGZvciBhIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVUcmVlUmVmLCBjaGlsZE5hbWUpIHtcclxuICAgIHJldHVybiBuZXdXcml0ZVRyZWVSZWYocGF0aENoaWxkKHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY2hpbGROYW1lKSwgd3JpdGVUcmVlUmVmLndyaXRlVHJlZSk7XHJcbn1cclxuZnVuY3Rpb24gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0cmVlUGF0aDogcGF0aCxcclxuICAgICAgICB3cml0ZVRyZWVcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoYW5nZS50eXBlO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gY2hhbmdlLmNoaWxkTmFtZTtcclxuICAgICAgICBhc3NlcnQodHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8gfHxcclxuICAgICAgICAgICAgdHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgJ09ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nJyk7XHJcbiAgICAgICAgYXNzZXJ0KGNoaWxkS2V5ICE9PSAnLnByaW9yaXR5JywgJ09ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hhbmdlID0gdGhpcy5jaGFuZ2VNYXAuZ2V0KGNoaWxkS2V5KTtcclxuICAgICAgICBpZiAob2xkQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFR5cGUgPSBvbGRDaGFuZ2UudHlwZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuZGVsZXRlKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuc2V0KGNoaWxkS2V5LCBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoYW5nZS5vbGRTbmFwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuc2V0KGNoaWxkS2V5LCBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0lsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlICtcclxuICAgICAgICAgICAgICAgICAgICAnIG9jY3VycmVkIGFmdGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZENoYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hhbmdlTWFwLnZhbHVlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IG5ldmVyIHJldHVybnMgYW55IGFkZGl0aW9uYWwgY2hpbGRyZW5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuY2xhc3MgTm9Db21wbGV0ZUNoaWxkU291cmNlXyB7XHJcbiAgICBnZXRDb21wbGV0ZUNoaWxkKGNoaWxkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSA9IG5ldyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCk7XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgdXNlcyBhIFdyaXRlVHJlZSBpbiBhZGRpdGlvbiB0byBhbnkgb3RoZXIgc2VydmVyIGRhdGEgb3JcclxuICogb2xkIGV2ZW50IGNhY2hlcyBhdmFpbGFibGUgdG8gY2FsY3VsYXRlIGNvbXBsZXRlIGNoaWxkcmVuLlxyXG4gKi9cclxuY2xhc3MgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXNfLCB2aWV3Q2FjaGVfLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLndyaXRlc18gPSB3cml0ZXNfO1xyXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHZpZXdDYWNoZV87XHJcbiAgICAgICAgdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnZpZXdDYWNoZV8uZXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAobm9kZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBDYWNoZU5vZGUodGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXywgdHJ1ZSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5zZXJ2ZXJDYWNoZTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHRoaXMud3JpdGVzXywgY2hpbGRLZXksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENoaWxkQWZ0ZXJDaGlsZChpbmRleCwgY2hpbGQsIHJldmVyc2UpIHtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZVNlcnZlckRhdGEgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcclxuICAgICAgICAgICAgPyB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfXHJcbiAgICAgICAgICAgIDogdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHRoaXMudmlld0NhY2hlXyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB3cml0ZVRyZWVSZWZDYWxjSW5kZXhlZFNsaWNlKHRoaXMud3JpdGVzXywgY29tcGxldGVTZXJ2ZXJEYXRhLCBjaGlsZCwgMSwgcmV2ZXJzZSwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1ZpZXdQcm9jZXNzb3IoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4geyBmaWx0ZXIgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUpIHtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnRXZlbnQgc25hcCBub3QgaW5kZXhlZCcpO1xyXG4gICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnU2VydmVyIHNuYXAgbm90IGluZGV4ZWQnKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlKSB7XHJcbiAgICBjb25zdCBhY2N1bXVsYXRvciA9IG5ldyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCk7XHJcbiAgICBsZXQgbmV3Vmlld0NhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlO1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk9WRVJXUklURSkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAob3ZlcndyaXRlLnNvdXJjZS5mcm9tVXNlcikge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3ZlcndyaXRlLnBhdGgsIG92ZXJ3cml0ZS5zbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xyXG4gICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZCAgYW5kIHRoZVxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgaXMgbm90IGF0IHRoZSByb290IGluIHdoaWNoIGNhc2UgaXQgaXMgb2sgKGFuZCBuZWNlc3NhcnkpIHRvIG1hcmsgdGhlIG5vZGUgdW5maWx0ZXJlZFxyXG4gICAgICAgICAgICAvLyBhZ2FpblxyXG4gICAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cclxuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZS5zb3VyY2UudGFnZ2VkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkgJiYgIXBhdGhJc0VtcHR5KG92ZXJ3cml0ZS5wYXRoKSk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSkge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmIChtZXJnZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQobWVyZ2Uuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWRcclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKCFhY2tVc2VyV3JpdGUucmV2ZXJ0KSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEUpIHtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24ucGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdVbmtub3duIG9wZXJhdGlvbiB0eXBlOiAnICsgb3BlcmF0aW9uLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hhbmdlcyA9IGFjY3VtdWxhdG9yLmdldENoYW5nZXMoKTtcclxuICAgIHZpZXdQcm9jZXNzb3JNYXliZUFkZFZhbHVlRXZlbnQob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xyXG4gICAgcmV0dXJuIHsgdmlld0NhY2hlOiBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gbmV3Vmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNMZWFmT3JFbXB0eSA9IGV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpIHx8IGV2ZW50U25hcC5nZXROb2RlKCkuaXNFbXB0eSgpO1xyXG4gICAgICAgIGNvbnN0IG9sZENvbXBsZXRlU25hcCA9IHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSk7XHJcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yLmxlbmd0aCA+IDAgfHxcclxuICAgICAgICAgICAgIW9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgICAgIChpc0xlYWZPckVtcHR5ICYmICFldmVudFNuYXAuZ2V0Tm9kZSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXApKSB8fFxyXG4gICAgICAgICAgICAhZXZlbnRTbmFwLmdldE5vZGUoKS5nZXRQcmlvcml0eSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXAuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChjaGFuZ2VWYWx1ZSh2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChuZXdWaWV3Q2FjaGUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IHZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHNoYWRvd2luZyB3cml0ZSwgaWdub3JlIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5ld0V2ZW50Q2FjaGUsIHNlcnZlck5vZGU7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRoaXMgcGxheXMgd2l0aCBcInNsaWRpbmcgYWNrIHdpbmRvd3NcIlxyXG4gICAgICAgICAgICBhc3NlcnQodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YScpO1xyXG4gICAgICAgICAgICBpZiAodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcywgYmVjYXVzZSB3ZSBuZWVkIHRvIG9ubHkgYXBwbHkgd3JpdGVzIHRvIGNvbXBsZXRlIGNoaWxkcmVuLCBvclxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgZW5kIHVwIHJhaXNpbmcgZXZlbnRzIGZvciBpbmNvbXBsZXRlIGNoaWxkcmVuLiBJZiB0aGUgc2VydmVyIGRhdGEgaXMgZmlsdGVyZWQgZGVlcFxyXG4gICAgICAgICAgICAgICAgLy8gd3JpdGVzIGNhbm5vdCBiZSBndWFyYW50ZWVkIHRvIGJlIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVDaGlsZHJlbiA9IHNlcnZlckNhY2hlIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIDogQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlRXZlbnRDaGlsZHJlbiwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY29tcGxldGVOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA9PT0gMSwgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50Tm9kZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgb3ZlcndyaXRlcyBmb3IgdGhpcyBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCwgb2xkRXZlbnROb2RlLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkUHJpb3JpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRFdmVudE5vZGUsIHVwZGF0ZWRQcmlvcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmlvcml0eSBkaWRuJ3QgY2hhbmdlLCBrZWVwIG9sZCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIGxldCBuZXdFdmVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50U25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRDaGlsZFVwZGF0ZSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50U25hcC5nZXROb2RlKCksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudENoaWxkVXBkYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgZXZlbnRDaGlsZFVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQsIGp1c3Qga2VlcCB0aGUgb2xkIGNoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkS2V5LCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3RXZlbnRDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSBvciBubyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3Qgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGxldCBuZXdTZXJ2ZXJDYWNoZTtcclxuICAgIGNvbnN0IHNlcnZlckZpbHRlciA9IGZpbHRlclNlcnZlck5vZGVcclxuICAgICAgICA/IHZpZXdQcm9jZXNzb3IuZmlsdGVyXHJcbiAgICAgICAgOiB2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleGVkRmlsdGVyKCk7XHJcbiAgICBpZiAocGF0aElzRW1wdHkoY2hhbmdlUGF0aCkpIHtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpICYmICFvbGRTZXJ2ZXJTbmFwLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSwgYnV0IHdlIGRpZG4ndCBmaWx0ZXIgdGhlIHNlcnZlciBub2RlIHlldCwgc28gc2ltdWxhdGUgYSBmdWxsIHVwZGF0ZVxyXG4gICAgICAgIGNvbnN0IG5ld1NlcnZlck5vZGUgPSBvbGRTZXJ2ZXJTbmFwXHJcbiAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3U2VydmVyTm9kZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoIW9sZFNlcnZlclNuYXAuaXNDb21wbGV0ZUZvclBhdGgoY2hhbmdlUGF0aCkgJiZcclxuICAgICAgICAgICAgcGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA+IDEpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXBkYXRlIGluY29tcGxldGUgbm9kZXMgd2l0aCB1cGRhdGVzIGludGVuZGVkIGZvciBvdGhlciBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBjaGlsZE5vZGUudXBkYXRlQ2hpbGQoY2hpbGRDaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVQcmlvcml0eShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUNoaWxkKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGROb2RlLCBjaGlsZENoYW5nZVBhdGgsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcChvbGRWaWV3Q2FjaGUsIG5ld1NlcnZlckNhY2hlLCBvbGRTZXJ2ZXJTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCBzZXJ2ZXJGaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIG5ld1ZpZXdDYWNoZSwgY29tcGxldGVDYWNoZSk7XHJcbiAgICByZXR1cm4gdmlld1Byb2Nlc3NvckdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnQodmlld1Byb2Nlc3NvciwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VQYXRoLCB3cml0ZXNDYWNoZSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IG9sZFZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBvbGRWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudENhY2hlLCB0cnVlLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCBvbGRFdmVudFNuYXAuaXNGaWx0ZXJlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkO1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkoY2hpbGRDaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hpbGQgb3ZlcndyaXRlLCB3ZSBjYW4gcmVwbGFjZSB0aGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hhbmdlZFNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzb3VyY2UuZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aEdldEJhY2soY2hpbGRDaGFuZ2VQYXRoKSA9PT0gJy5wcmlvcml0eScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmdldENoaWxkKHBhdGhQYXJlbnQoY2hpbGRDaGFuZ2VQYXRoKSkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyIHdpbGwgc2VuZCBkb3duIHRoZSBwcmlvcml0eSBpbiB0aGUgdXBkYXRlLCBzbyBpZ25vcmUgZm9yIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbXBsZXRlIGNoaWxkIG5vZGUgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50U25hcCA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50U25hcCwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JDYWNoZUhhc0NoaWxkKHZpZXdDYWNoZSwgY2hpbGRLZXkpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICh2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY2hhbmdlZENoaWxkcmVuLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gcGF0aENoaWxkKHBhdGgsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKCF2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBub2RlLCBtZXJnZSkge1xyXG4gICAgbWVyZ2UuZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgeWV0LCB0aGlzIG1lcmdlIHdhcyBpbnRlbmRlZCBmb3IgYSBwcmV2aW91c2x5IGxpc3RlbiBpbiB0aGUgc2FtZSBsb2NhdGlvbi4gSWdub3JlIGl0IGFuZFxyXG4gICAgLy8gd2FpdCBmb3IgdGhlIGNvbXBsZXRlIGRhdGEgdXBkYXRlIGNvbWluZyBzb29uLlxyXG4gICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNFbXB0eSgpICYmXHJcbiAgICAgICAgIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICAvLyBIQUNLOiBJbiB0aGUgY2FzZSBvZiBhIGxpbWl0IHF1ZXJ5LCB0aGVyZSBtYXkgYmUgc29tZSBjaGFuZ2VzIHRoYXQgYnVtcCB0aGluZ3Mgb3V0IG9mIHRoZVxyXG4gICAgLy8gd2luZG93IGxlYXZpbmcgcm9vbSBmb3IgbmV3IGl0ZW1zLiAgSXQncyBpbXBvcnRhbnQgd2UgcHJvY2VzcyB0aGVzZSBjaGFuZ2VzIGZpcnN0LCBzbyB3ZVxyXG4gICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXHJcbiAgICAvLyBUT0RPOiBJIGNvbnNpZGVyIGFuIGl0ZW0gXCJpbiB2aWV3XCIgaWYgY2FjaGVIYXNDaGlsZCBpcyB0cnVlLCB3aGljaCBjaGVja3MgYm90aCB0aGUgc2VydmVyXHJcbiAgICAvLyBhbmQgZXZlbnQgc25hcC4gIEknbSBub3Qgc3VyZSBpZiB0aGlzIHdpbGwgcmVzdWx0IGluIGVkZ2UgY2FzZXMgd2hlbiBhIGNoaWxkIGlzIGluIG9uZSBidXRcclxuICAgIC8vIG5vdCB0aGUgb3RoZXIuXHJcbiAgICBsZXQgY3VyVmlld0NhY2hlID0gdmlld0NhY2hlO1xyXG4gICAgbGV0IHZpZXdNZXJnZVRyZWU7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICB2aWV3TWVyZ2VUcmVlID0gY2hhbmdlZENoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpLnNldFRyZWUocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgdmlld01lcmdlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkID0gdmlld0NhY2hlLnNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHZpZXdQcm9jZXNzb3JBcHBseU1lcmdlKHZpZXdQcm9jZXNzb3IsIHNlcnZlckNoaWxkLCBjaGlsZFRyZWUpO1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3NvciwgY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkTWVyZ2VUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNVbmtub3duRGVlcE1lcmdlID0gIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpICYmXHJcbiAgICAgICAgICAgIGNoaWxkTWVyZ2VUcmVlLnZhbHVlID09PSBudWxsO1xyXG4gICAgICAgIGlmICghc2VydmVyTm9kZS5oYXNDaGlsZChjaGlsZEtleSkgJiYgIWlzVW5rbm93bkRlZXBNZXJnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRNZXJnZVRyZWUpO1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3NvciwgY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFja1VzZXJXcml0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIGFja1BhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gT25seSBmaWx0ZXIgc2VydmVyIG5vZGUgaWYgaXQgaXMgY3VycmVudGx5IGZpbHRlcmVkXHJcbiAgICBjb25zdCBmaWx0ZXJTZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRmlsdGVyZWQoKTtcclxuICAgIC8vIEVzc2VudGlhbGx5IHdlJ2xsIGp1c3QgZ2V0IG91ciBleGlzdGluZyBzZXJ2ZXIgY2FjaGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRocyBhbmQgcmUtYXBwbHkgaXQgYXMgYSBzZXJ2ZXIgdXBkYXRlXHJcbiAgICAvLyBub3cgdGhhdCBpdCB3b24ndCBiZSBzaGFkb3dlZC5cclxuICAgIGNvbnN0IHNlcnZlckNhY2hlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlO1xyXG4gICAgaWYgKGFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvdmVyd3JpdGUuXHJcbiAgICAgICAgaWYgKChwYXRoSXNFbXB0eShhY2tQYXRoKSAmJiBzZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkgfHxcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoYWNrUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChhY2tQYXRoKSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0aElzRW1wdHkoYWNrUGF0aCkpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGdvb2Z5IGVkZ2UgY2FzZSB3aGVyZSB3ZSBhcmUgYWNraW5nIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBidXQgZG9uJ3QgaGF2ZSBmdWxsIGRhdGEuICBXZVxyXG4gICAgICAgICAgICAvLyBzaG91bGQganVzdCByZS1hcHBseSB3aGF0ZXZlciB3ZSBoYXZlIGluIG91ciBjYWNoZSBhcyBhIG1lcmdlLlxyXG4gICAgICAgICAgICBsZXQgY2hhbmdlZENoaWxkcmVuID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmdldE5vZGUoKS5mb3JFYWNoQ2hpbGQoS0VZX0lOREVYLCAobmFtZSwgbm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChuZXcgUGF0aChuYW1lKSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZS5cclxuICAgICAgICBsZXQgY2hhbmdlZENoaWxkcmVuID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgYWZmZWN0ZWRUcmVlLmZvcmVhY2goKG1lcmdlUGF0aCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGVQYXRoID0gcGF0aENoaWxkKGFja1BhdGgsIG1lcmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChzZXJ2ZXJDYWNoZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4gPSBjaGFuZ2VkQ2hpbGRyZW4uc2V0KG1lcmdlUGF0aCwgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmdldENoaWxkKHNlcnZlckNhY2hlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JMaXN0ZW5Db21wbGV0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3Qgb2xkU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBvbGRTZXJ2ZXJOb2RlLmdldE5vZGUoKSwgb2xkU2VydmVyTm9kZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShwYXRoKSwgb2xkU2VydmVyTm9kZS5pc0ZpbHRlcmVkKCkpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGxldCBjb21wbGV0ZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgcGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gdmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSB8fCBwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdOb2RlO1xyXG4gICAgICAgICAgICBpZiAodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHNlcnZlckNoaWxkcmVuIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlLCAnc2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgc2VydmVyQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkRXZlbnRDYWNoZSwgbmV3Tm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRDYWNoZSwgY2hpbGRLZXksIG5ld0NoaWxkLCBwYXRoUG9wRnJvbnQocGF0aCksIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKS5oYXNDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSwgZGVsZXRlIHRoZSBleGlzdGluZyBvbmUsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudENhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdFdmVudENhY2hlLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICAgICAgICAgdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJldmVydGVkIGFsbCBjaGlsZCB3cml0ZXMuIE1heWJlIHRoZSBvbGQgZXZlbnQgd2FzIGEgbGVhZiBub2RlXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUobmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wbGV0ZSA9XHJcbiAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAgICAgd3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIG5ld0VtcHR5UGF0aCgpKSAhPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAodmlld0NhY2hlLCBuZXdFdmVudENhY2hlLCBjb21wbGV0ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHZpZXcgcmVwcmVzZW50cyBhIHNwZWNpZmljIGxvY2F0aW9uIGFuZCBxdWVyeSB0aGF0IGhhcyAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucy5cclxuICpcclxuICogSXQgZG9lcyBzZXZlcmFsIHRoaW5nczpcclxuICogIC0gTWFpbnRhaW5zIHRoZSBsaXN0IG9mIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXHJcbiAqICAtIE1haW50YWlucyBhIGNhY2hlIG9mIHRoZSBkYXRhIHZpc2libGUgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXHJcbiAqICAtIEFwcGxpZXMgbmV3IG9wZXJhdGlvbnMgKHZpYSBhcHBseU9wZXJhdGlvbiksIHVwZGF0ZXMgdGhlIGNhY2hlLCBhbmQgYmFzZWQgb24gdGhlIGV2ZW50XHJcbiAqICAgIHJlZ2lzdHJhdGlvbnMgcmV0dXJucyB0aGUgc2V0IG9mIGV2ZW50cyB0byBiZSByYWlzZWQuXHJcbiAqL1xyXG5jbGFzcyBWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5XywgaW5pdGlhbFZpZXdDYWNoZSkge1xyXG4gICAgICAgIHRoaXMucXVlcnlfID0gcXVlcnlfO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucXVlcnlfLl9xdWVyeVBhcmFtcztcclxuICAgICAgICBjb25zdCBpbmRleEZpbHRlciA9IG5ldyBJbmRleGVkRmlsdGVyKHBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBxdWVyeVBhcmFtc0dldE5vZGVGaWx0ZXIocGFyYW1zKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3Nvcl8gPSBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcik7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFNlcnZlckNhY2hlID0gaW5pdGlhbFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgICAgICBjb25zdCBpbml0aWFsRXZlbnRDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgICAgICAvLyBEb24ndCBmaWx0ZXIgc2VydmVyIG5vZGUgd2l0aCBvdGhlciBmaWx0ZXIgdGhhbiBpbmRleCwgd2FpdCBmb3IgdGFnZ2VkIGxpc3RlblxyXG4gICAgICAgIGNvbnN0IHNlcnZlclNuYXAgPSBpbmRleEZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbFNlcnZlckNhY2hlLmdldE5vZGUoKSwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRTbmFwID0gZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBpbml0aWFsRXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IG5ld1NlcnZlckNhY2hlID0gbmV3IENhY2hlTm9kZShzZXJ2ZXJTbmFwLCBpbml0aWFsU2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGluZGV4RmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICBjb25zdCBuZXdFdmVudENhY2hlID0gbmV3IENhY2hlTm9kZShldmVudFNuYXAsIGluaXRpYWxFdmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBmaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IG5ld1ZpZXdDYWNoZShuZXdFdmVudENhY2hlLCBuZXdTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgdGhpcy5ldmVudEdlbmVyYXRvcl8gPSBuZXcgRXZlbnRHZW5lcmF0b3IodGhpcy5xdWVyeV8pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHF1ZXJ5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5XztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcudmlld0NhY2hlXy5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSh2aWV3LCBwYXRoKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pO1xyXG4gICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgLy8gSWYgdGhpcyBpc24ndCBhIFwibG9hZHNBbGxEYXRhXCIgdmlldywgdGhlbiBjYWNoZSBpc24ndCBhY3R1YWxseSBhIGNvbXBsZXRlIGNhY2hlIGFuZFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2VlIGlmIGl0IGNvbnRhaW5zIHRoZSBjaGlsZCB3ZSdyZSBpbnRlcmVzdGVkIGluLlxyXG4gICAgICAgIGlmICh2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSB8fFxyXG4gICAgICAgICAgICAoIXBhdGhJc0VtcHR5KHBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICAhY2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQocGF0aEdldEZyb250KHBhdGgpKS5pc0VtcHR5KCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXRDaGlsZChwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3SXNFbXB0eSh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aCA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiB2aWV3QWRkRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5wdXNoKGV2ZW50UmVnaXN0cmF0aW9uKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uIC0gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqIEBwYXJhbSBjYW5jZWxFcnJvciAtIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybnMgQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xyXG4gICAgY29uc3QgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICBpZiAoY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRSZWdpc3RyYXRpb24gPT0gbnVsbCwgJ0EgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuJyk7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHZpZXcucXVlcnkuX3BhdGg7XHJcbiAgICAgICAgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVFdmVudCA9IHJlZ2lzdHJhdGlvbi5jcmVhdGVDYW5jZWxFdmVudChjYW5jZWxFcnJvciwgcGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChtYXliZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudHMucHVzaChtYXliZUV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nLm1hdGNoZXMoZXZlbnRSZWdpc3RyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChleGlzdGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRSZWdpc3RyYXRpb24uaGFzQW55Q2FsbGJhY2soKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcganVzdCB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLmNvbmNhdCh2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18uc2xpY2UoaSArIDEpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXyA9IHJlbWFpbmluZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgZ2l2ZW4gT3BlcmF0aW9uLCB1cGRhdGVzIG91ciBjYWNoZSwgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKSB7XHJcbiAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UgJiZcclxuICAgICAgICBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQgIT09IG51bGwpIHtcclxuICAgICAgICBhc3NlcnQodmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXcudmlld0NhY2hlXyksICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXMnKTtcclxuICAgICAgICBhc3NlcnQodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlldy52aWV3Q2FjaGVfKSwgJ01pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZpZXdDYWNoZSA9IHZpZXcudmlld0NhY2hlXztcclxuICAgIGNvbnN0IHJlc3VsdCA9IHZpZXdQcm9jZXNzb3JBcHBseU9wZXJhdGlvbih2aWV3LnByb2Nlc3Nvcl8sIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCh2aWV3LnByb2Nlc3Nvcl8sIHJlc3VsdC52aWV3Q2FjaGUpO1xyXG4gICAgYXNzZXJ0KHJlc3VsdC52aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAhb2xkVmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFjaycpO1xyXG4gICAgdmlldy52aWV3Q2FjaGVfID0gcmVzdWx0LnZpZXdDYWNoZTtcclxuICAgIHJldHVybiB2aWV3R2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyh2aWV3LCByZXN1bHQuY2hhbmdlcywgcmVzdWx0LnZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldEluaXRpYWxFdmVudHModmlldywgcmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCBldmVudFNuYXAgPSB2aWV3LnZpZXdDYWNoZV8uZXZlbnRDYWNoZTtcclxuICAgIGNvbnN0IGluaXRpYWxDaGFuZ2VzID0gW107XHJcbiAgICBpZiAoIWV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnROb2RlID0gZXZlbnRTbmFwLmdldE5vZGUoKTtcclxuICAgICAgICBldmVudE5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChjaGFuZ2VWYWx1ZShldmVudFNuYXAuZ2V0Tm9kZSgpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgaW5pdGlhbENoYW5nZXMsIGV2ZW50U25hcC5nZXROb2RlKCksIHJlZ2lzdHJhdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgY2hhbmdlcywgZXZlbnRDYWNoZSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBldmVudFJlZ2lzdHJhdGlvblxyXG4gICAgICAgID8gW2V2ZW50UmVnaXN0cmF0aW9uXVxyXG4gICAgICAgIDogdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKHZpZXcuZXZlbnRHZW5lcmF0b3JfLCBjaGFuZ2VzLCBldmVudENhY2hlLCByZWdpc3RyYXRpb25zKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgcmVmZXJlbmNlQ29uc3RydWN0b3IkMTtcclxuLyoqXHJcbiAqIFN5bmNQb2ludCByZXByZXNlbnRzIGEgc2luZ2xlIGxvY2F0aW9uIGluIGEgU3luY1RyZWUgd2l0aCAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucywgbWVhbmluZyB3ZSBuZWVkIHRvXHJcbiAqIG1haW50YWluIDEgb3IgbW9yZSBWaWV3cyBhdCB0aGlzIGxvY2F0aW9uIHRvIGNhY2hlIHNlcnZlciBkYXRhIGFuZCByYWlzZSBhcHByb3ByaWF0ZSBldmVudHMgZm9yIHNlcnZlciBjaGFuZ2VzXHJcbiAqIGFuZCB1c2VyIHdyaXRlcyAoc2V0LCB0cmFuc2FjdGlvbiwgdXBkYXRlKS5cclxuICpcclxuICogSXQncyByZXNwb25zaWJsZSBmb3I6XHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBzZXQgb2YgMSBvciBtb3JlIHZpZXdzIG5lY2Vzc2FyeSBhdCB0aGlzIGxvY2F0aW9uIChhIFN5bmNQb2ludCB3aXRoIDAgdmlld3Mgc2hvdWxkIGJlIHJlbW92ZWQpLlxyXG4gKiAgLSBQcm94eWluZyB1c2VyIC8gc2VydmVyIG9wZXJhdGlvbnMgdG8gdGhlIHZpZXdzIGFzIGFwcHJvcHJpYXRlIChpLmUuIGFwcGx5U2VydmVyT3ZlcndyaXRlLFxyXG4gKiAgICBhcHBseVVzZXJPdmVyd3JpdGUsIGV0Yy4pXHJcbiAqL1xyXG5jbGFzcyBTeW5jUG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFZpZXdzIGJlaW5nIHRyYWNrZWQgYXQgdGhpcyBsb2NhdGlvbiBpbiB0aGUgdHJlZSwgc3RvcmVkIGFzIGEgbWFwIHdoZXJlIHRoZSBrZXkgaXMgYVxyXG4gICAgICAgICAqIHF1ZXJ5SWQgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgVmlldyBmb3IgdGhhdCBxdWVyeS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IFRoaXMgbGlzdCB3aWxsIGJlIHF1aXRlIHNtYWxsICh1c3VhbGx5IDEsIGJ1dCBwZXJoYXBzIDIgb3IgMzsgYW55IG1vcmUgaXMgYW4gb2RkIHVzZSBjYXNlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpZXdzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciQxLCAnX19yZWZlcmVuY2VDb25zdHJ1Y3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQnKTtcclxuICAgIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEgPSB2YWw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoKSB7XHJcbiAgICBhc3NlcnQocmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ1JlZmVyZW5jZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICByZXR1cm4gcmVmZXJlbmNlQ29uc3RydWN0b3IkMTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRJc0VtcHR5KHN5bmNQb2ludCkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludC52aWV3cy5zaXplID09PSAwO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgY29uc3QgcXVlcnlJZCA9IG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZDtcclxuICAgIGlmIChxdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXcgIT0gbnVsbCwgJ1N5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuJyk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodmlld0FwcGx5T3BlcmF0aW9uKHZpZXcsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2V0IGEgdmlldyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJldHVybiBhIHZpZXcgZm9yXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlQ29tcGxldGVcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICAvLyBUT0RPOiBtYWtlIHdyaXRlc0NhY2hlIHRha2UgZmxhZyBmb3IgY29tcGxldGUgc2VydmVyIG5vZGVcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUgPyBzZXJ2ZXJDYWNoZSA6IG51bGwpO1xyXG4gICAgICAgIGxldCBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlbnRDYWNoZSkge1xyXG4gICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSkge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZpZXdDYWNoZSA9IG5ld1ZpZXdDYWNoZShuZXcgQ2FjaGVOb2RlKGV2ZW50Q2FjaGUsIGV2ZW50Q2FjaGVDb21wbGV0ZSwgZmFsc2UpLCBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlLCBmYWxzZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlldyhxdWVyeSwgdmlld0NhY2hlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3O1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeVxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb25cclxuICogQHBhcmFtIHdyaXRlc0NhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZSAtIENvbXBsZXRlIHNlcnZlciBjYWNoZSwgaWYgd2UgaGF2ZSBpdC5cclxuICogQHBhcmFtIHNlcnZlckNhY2hlQ29tcGxldGVcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50QWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1BvaW50LCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSkge1xyXG4gICAgY29uc3QgdmlldyA9IHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKTtcclxuICAgIGlmICghc3luY1BvaW50LnZpZXdzLmhhcyhxdWVyeS5fcXVlcnlJZGVudGlmaWVyKSkge1xyXG4gICAgICAgIHN5bmNQb2ludC52aWV3cy5zZXQocXVlcnkuX3F1ZXJ5SWRlbnRpZmllciwgdmlldyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3Qgbm93LCB3ZSBqdXN0IGNyZWF0ZWQgYW55dGhpbmcgdGhhdCB3YXMgbWlzc2luZ1xyXG4gICAgdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIHJldHVybiB2aWV3R2V0SW5pdGlhbEV2ZW50cyh2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS4gIFJldHVybiBjYW5jZWxFdmVudHMgaWYgYSBjYW5jZWxFcnJvciBpcyBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgdmlld3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXHJcbiAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHZpZXcocykuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIHJlbW92ZWQgcXVlcmllcyBhbmQgYW55IGNhbmNlbCBldmVudHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludFJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xyXG4gICAgY29uc3QgcXVlcnlJZCA9IHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbiAgICBjb25zdCByZW1vdmVkID0gW107XHJcbiAgICBsZXQgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICBjb25zdCBoYWRDb21wbGV0ZVZpZXcgPSBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgIGlmIChxdWVyeUlkID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAvLyBXaGVuIHlvdSBkbyByZWYub2ZmKC4uLiksIHdlIHNlYXJjaCBhbGwgdmlld3MgZm9yIHRoZSByZWdpc3RyYXRpb24gdG8gcmVtb3ZlLlxyXG4gICAgICAgIGZvciAoY29uc3QgW3ZpZXdRdWVyeUlkLCB2aWV3XSBvZiBzeW5jUG9pbnQudmlld3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQodmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xyXG4gICAgICAgICAgICBpZiAodmlld0lzRW1wdHkodmlldykpIHtcclxuICAgICAgICAgICAgICAgIHN5bmNQb2ludC52aWV3cy5kZWxldGUodmlld1F1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgZGVhbCB3aXRoIGNvbXBsZXRlIHZpZXdzIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSB0aGUgc3BlY2lmaWMgdmlldy5cclxuICAgICAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgICAgICBpZiAodmlldykge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgZGVhbCB3aXRoIGNvbXBsZXRlIHZpZXdzIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYWRDb21wbGV0ZVZpZXcgJiYgIXN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpKSB7XHJcbiAgICAgICAgLy8gV2UgcmVtb3ZlZCBvdXIgbGFzdCBjb21wbGV0ZSB2aWV3LlxyXG4gICAgICAgIHJlbW92ZWQucHVzaChuZXcgKHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkpKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgcmVtb3ZlZCwgZXZlbnRzOiBjYW5jZWxFdmVudHMgfTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRRdWVyeVZpZXdzKHN5bmNQb2ludCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkZXNpcmVkIGNvbXBsZXRlIHNuYXBzaG90XHJcbiAqIEByZXR1cm5zIEEgY29tcGxldGUgY2FjaGUsIGlmIGl0IGV4aXN0c1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHBhdGgpIHtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZSB8fCB2aWV3R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSh2aWV3LCBwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gcXVlcnkuX3F1ZXJ5UGFyYW1zO1xyXG4gICAgaWYgKHBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHJldHVybiBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpICE9IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpICE9IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCkge1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICh2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgcmVmZXJlbmNlQ29uc3RydWN0b3I7XHJcbmZ1bmN0aW9uIHN5bmNUcmVlU2V0UmVmZXJlbmNlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICBhc3NlcnQoIXJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnX19yZWZlcmVuY2VDb25zdHJ1Y3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQnKTtcclxuICAgIHJlZmVyZW5jZUNvbnN0cnVjdG9yID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlR2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoKSB7XHJcbiAgICBhc3NlcnQocmVmZXJlbmNlQ29uc3RydWN0b3IsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgdHJhY2tlciBmb3IgbmV4dCBxdWVyeSB0YWcuXHJcbiAqL1xyXG5sZXQgc3luY1RyZWVOZXh0UXVlcnlUYWdfID0gMTtcclxuLyoqXHJcbiAqIFN5bmNUcmVlIGlzIHRoZSBjZW50cmFsIGNsYXNzIGZvciBtYW5hZ2luZyBldmVudCBjYWxsYmFjayByZWdpc3RyYXRpb24sIGRhdGEgY2FjaGluZywgdmlld3NcclxuICogKHF1ZXJ5IHByb2Nlc3NpbmcpLCBhbmQgZXZlbnQgZ2VuZXJhdGlvbi4gIFRoZXJlIGFyZSB0eXBpY2FsbHkgdHdvIFN5bmNUcmVlIGluc3RhbmNlcyBmb3JcclxuICogZWFjaCBSZXBvLCBvbmUgZm9yIHRoZSBub3JtYWwgRmlyZWJhc2UgZGF0YSwgYW5kIG9uZSBmb3IgdGhlIC5pbmZvIGRhdGEuXHJcbiAqXHJcbiAqIEl0IGhhcyBhIG51bWJlciBvZiByZXNwb25zaWJpbGl0aWVzLCBpbmNsdWRpbmc6XHJcbiAqICAtIFRyYWNraW5nIGFsbCB1c2VyIGV2ZW50IGNhbGxiYWNrcyAocmVnaXN0ZXJlZCB2aWEgYWRkRXZlbnRSZWdpc3RyYXRpb24oKSBhbmQgcmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oKSkuXHJcbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3IgdXNlciBzZXQoKSwgdHJhbnNhY3Rpb24oKSwgYW5kIHVwZGF0ZSgpIGNhbGxzXHJcbiAqICAgIChhcHBseVVzZXJPdmVyd3JpdGUoKSwgYXBwbHlVc2VyTWVyZ2UoKSkuXHJcbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3Igc2VydmVyIGRhdGEgY2hhbmdlcyAoYXBwbHlTZXJ2ZXJPdmVyd3JpdGUoKSxcclxuICogICAgYXBwbHlTZXJ2ZXJNZXJnZSgpKS5cclxuICogIC0gR2VuZXJhdGluZyB1c2VyLWZhY2luZyBldmVudHMgZm9yIHNlcnZlciBhbmQgdXNlciBjaGFuZ2VzIChhbGwgb2YgdGhlIGFwcGx5KiBtZXRob2RzXHJcbiAqICAgIHJldHVybiB0aGUgc2V0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgcmFpc2VkIGFzIGEgcmVzdWx0KS5cclxuICogIC0gTWFpbnRhaW5pbmcgdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzZXJ2ZXIgbGlzdGVucyB0byBlbnN1cmUgd2UgYXJlIGFsd2F5cyBzdWJzY3JpYmVkXHJcbiAqICAgIHRvIHRoZSBjb3JyZWN0IHNldCBvZiBwYXRocyBhbmQgcXVlcmllcyB0byBzYXRpc2Z5IHRoZSBjdXJyZW50IHNldCBvZiB1c2VyIGV2ZW50XHJcbiAqICAgIGNhbGxiYWNrcyAobGlzdGVucyBhcmUgc3RhcnRlZC9zdG9wcGVkIHVzaW5nIHRoZSBwcm92aWRlZCBsaXN0ZW5Qcm92aWRlcikuXHJcbiAqXHJcbiAqIE5PVEU6IEFsdGhvdWdoIFN5bmNUcmVlIHRyYWNrcyBldmVudCBjYWxsYmFja3MgYW5kIGNhbGN1bGF0ZXMgZXZlbnRzIHRvIHJhaXNlLCB0aGUgYWN0dWFsXHJcbiAqIGV2ZW50cyBhcmUgcmV0dXJuZWQgdG8gdGhlIGNhbGxlciByYXRoZXIgdGhhbiByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICovXHJcbmNsYXNzIFN5bmNUcmVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGxpc3RlblByb3ZpZGVyXyAtIFVzZWQgYnkgU3luY1RyZWUgdG8gc3RhcnQgLyBzdG9wIGxpc3RlbmluZ1xyXG4gICAgICogICB0byBzZXJ2ZXIgZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobGlzdGVuUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8gPSBsaXN0ZW5Qcm92aWRlcl87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJlZSBvZiBTeW5jUG9pbnRzLiAgVGhlcmUncyBhIFN5bmNQb2ludCBhdCBhbnkgbG9jYXRpb24gdGhhdCBoYXMgMSBvciBtb3JlIHZpZXdzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRyZWUgb2YgYWxsIHBlbmRpbmcgdXNlciB3cml0ZXMgKHVzZXItaW5pdGlhdGVkIHNldCgpJ3MsIHRyYW5zYWN0aW9uKCkncywgdXBkYXRlKCkncywgZXRjLikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXyA9IG5ld1dyaXRlVHJlZSgpO1xyXG4gICAgICAgIHRoaXMudGFnVG9RdWVyeU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IHRoZSBkYXRhIGNoYW5nZXMgZm9yIGEgdXNlci1nZW5lcmF0ZWQgc2V0KCkgb3IgdHJhbnNhY3Rpb24oKSBjYWxsLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXHJcbiAgICB3cml0ZVRyZWVBZGRPdmVyd3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpO1xyXG4gICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSwgcGF0aCwgbmV3RGF0YSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBmcm9tIGEgdXNlci1nZW5lcmF0ZWQgdXBkYXRlKCkgY2FsbFxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VXNlck1lcmdlKHN5bmNUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIG1lcmdlLlxyXG4gICAgd3JpdGVUcmVlQWRkTWVyZ2Uoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQWNrbm93bGVkZ2UgYSBwZW5kaW5nIHVzZXIgd3JpdGUgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYXBwbHlVc2VyT3ZlcndyaXRlKCkgb3IgYXBwbHlVc2VyTWVyZ2UoKS5cclxuICpcclxuICogQHBhcmFtIHJldmVydCAtIFRydWUgaWYgdGhlIGdpdmVuIHdyaXRlIGZhaWxlZCBhbmQgbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBY2tVc2VyV3JpdGUoc3luY1RyZWUsIHdyaXRlSWQsIHJldmVydCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB3cml0ZSA9IHdyaXRlVHJlZUdldFdyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCB3cml0ZUlkKTtcclxuICAgIGNvbnN0IG5lZWRUb1JlZXZhbHVhdGUgPSB3cml0ZVRyZWVSZW1vdmVXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBpZiAoIW5lZWRUb1JlZXZhbHVhdGUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgYWZmZWN0ZWRUcmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgaWYgKHdyaXRlLnNuYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBvdmVyd3JpdGVcclxuICAgICAgICAgICAgYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlLnNldChuZXdFbXB0eVBhdGgoKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlYWNoKHdyaXRlLmNoaWxkcmVuLCAocGF0aFN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlLnNldChuZXcgUGF0aChwYXRoU3RyaW5nKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBBY2tVc2VyV3JpdGUod3JpdGUucGF0aCwgYWZmZWN0ZWRUcmVlLCByZXZlcnQpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHN5bmNUcmVlLCBwYXRoLCBuZXdEYXRhKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBPdmVyd3JpdGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlTZXJ2ZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCwgY2hhbmdlVHJlZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSBxdWVyeVxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHBhdGgpIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHRhZ2dlZCBxdWVyeVxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHBhdGgsIHRhZykge1xyXG4gICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKTtcclxuICAgIGlmIChxdWVyeUtleSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBuZXcgTGlzdGVuQ29tcGxldGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcmVtb3ZlZCB0aGUgcXVlcnkuIE5vIGJpZyBkZWFsLCBpZ25vcmUgdGhlIHVwZGF0ZVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHF1ZXJpZXMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXHJcbiAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIGFsbCBjYWxsYmFja3MgYXJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBjYW5jZWxFcnJvciAtIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHNraXBMaXN0ZW5lckRlZHVwIC0gV2hlbiBwZXJmb3JtaW5nIGEgYGdldCgpYCwgd2UgZG9uJ3QgYWRkIGFueSBuZXcgbGlzdGVuZXJzLCBzbyBub1xyXG4gKiAgZGVkdXBpbmcgbmVlZHMgdG8gdGFrZSBwbGFjZS4gVGhpcyBmbGFnIGFsbG93cyB0b2dnbGluZyBvZiB0aGF0IGJlaGF2aW9yXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IsIHNraXBMaXN0ZW5lckRlZHVwID0gZmFsc2UpIHtcclxuICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgbWF5YmVTeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBsZXQgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICAvLyBBIHJlbW92YWwgb24gYSBkZWZhdWx0IHF1ZXJ5IGFmZmVjdHMgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gQSByZW1vdmFsIG9uIGFuIGluZGV4ZWQgcXVlcnksIGV2ZW4gb25lIHdpdGhvdXRcclxuICAgIC8vIG90aGVyIHF1ZXJ5IGNvbnN0cmFpbnRzLCBkb2VzICpub3QqIGFmZmVjdCBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBTbyB0aGlzIGNoZWNrIG11c3QgYmUgZm9yICdkZWZhdWx0JywgYW5kXHJcbiAgICAvLyBub3QgbG9hZHNBbGxEYXRhKCkuXHJcbiAgICBpZiAobWF5YmVTeW5jUG9pbnQgJiZcclxuICAgICAgICAocXVlcnkuX3F1ZXJ5SWRlbnRpZmllciA9PT0gJ2RlZmF1bHQnIHx8XHJcbiAgICAgICAgICAgIHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShtYXliZVN5bmNQb2ludCwgcXVlcnkpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBbmRFdmVudHMgPSBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihtYXliZVN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcik7XHJcbiAgICAgICAgaWYgKHN5bmNQb2ludElzRW1wdHkobWF5YmVTeW5jUG9pbnQpKSB7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8ucmVtb3ZlKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW1vdmVkID0gcmVtb3ZlZEFuZEV2ZW50cy5yZW1vdmVkO1xyXG4gICAgICAgIGNhbmNlbEV2ZW50cyA9IHJlbW92ZWRBbmRFdmVudHMuZXZlbnRzO1xyXG4gICAgICAgIGlmICghc2tpcExpc3RlbmVyRGVkdXApIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdlIG1heSBoYXZlIGp1c3QgcmVtb3ZlZCBvbmUgb2YgbWFueSBsaXN0ZW5lcnMgYW5kIGNhbiBzaG9ydC1jaXJjdWl0IHRoaXMgd2hvbGUgcHJvY2Vzc1xyXG4gICAgICAgICAgICAgKiBXZSBtYXkgYWxzbyBub3QgaGF2ZSByZW1vdmVkIGEgZGVmYXVsdCBsaXN0ZW5lciwgaW4gd2hpY2ggY2FzZSBhbGwgb2YgdGhlIGRlc2NlbmRhbnQgbGlzdGVuZXJzIHNob3VsZCBhbHJlYWR5IGJlXHJcbiAgICAgICAgICAgICAqIHByb3Blcmx5IHNldCB1cC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vIFNpbmNlIGluZGV4ZWQgcXVlcmllcyBjYW4gc2hhZG93IGlmIHRoZXkgZG9uJ3QgaGF2ZSBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgY2hlY2sgZm9yIGxvYWRzQWxsRGF0YSgpLCBpbnN0ZWFkIG9mXHJcbiAgICAgICAgICAgIC8vIHF1ZXJ5SWQgPT09ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmluZ0RlZmF1bHQgPSAtMSAhPT1cclxuICAgICAgICAgICAgICAgIHJlbW92ZWQuZmluZEluZGV4KHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdmVyZWQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChyZWxhdGl2ZVBhdGgsIHBhcmVudFN5bmNQb2ludCkgPT4gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHBhcmVudFN5bmNQb2ludCkpO1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0ICYmICFjb3ZlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJ0cmVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZm9sZCBvdmVyIG91ciBzdWJ0cmVlIGFuZCBjb2xsZWN0IHRoZSBsaXN0ZW5lcnMgdG8gc2VuZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdzID0gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Vmlld3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ld1ZpZXdzW2ldLCBuZXdRdWVyeSA9IHZpZXcucXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gc3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfKHN5bmNUcmVlLCB2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKG5ld1F1ZXJ5KSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgbmV3UXVlcnkpLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGVyZSdzIG5vdGhpbmcgYmVsb3cgdXMsIHNvIG5vdGhpbmcgd2UgbmVlZCB0byBzdGFydCBsaXN0ZW5pbmcgb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGFueXRoaW5nIGFuZCB3ZSdyZSBub3QgY292ZXJlZCBieSBhIGhpZ2hlciB1cCBsaXN0ZW4sIHdlIG5lZWQgdG8gc3RvcCBsaXN0ZW5pbmcgb24gdGhpcyBxdWVyeVxyXG4gICAgICAgICAgICAvLyBUaGUgYWJvdmUgYmxvY2sgaGFzIHVzIGNvdmVyZWQgaW4gdGVybXMgb2YgbWFraW5nIHN1cmUgd2UncmUgc2V0IHVwIG9uIGxpc3RlbnMgbG93ZXIgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxyXG4gICAgICAgICAgICBpZiAoIWNvdmVyZWQgJiYgcmVtb3ZlZC5sZW5ndGggPiAwICYmICFjYW5jZWxFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGRlZmF1bHQsIHRoZW4gd2Ugd2VyZW4ndCBsaXN0ZW5pbmcgb24gYW55IG9mIHRoZSBvdGhlciBxdWVyaWVzIGhlcmUuIEp1c3QgY2FuY2VsIHRoZSBvbmVcclxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZ0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB0YWcgZGVmYXVsdCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VGFnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jVHJlZS5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSksIGRlZmF1bHRUYWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKChxdWVyeVRvUmVtb3ZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1RvUmVtb3ZlID0gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQoc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5VG9SZW1vdmUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1JlbW92ZSksIHRhZ1RvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3csIGNsZWFyIGFsbCBvZiB0aGUgdGFncyB3ZSdyZSB0cmFja2luZyBmb3IgdGhlIHJlbW92ZWQgbGlzdGVuc1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHJlbW92ZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlKHN5bmNUcmVlLCBwYXRoLCBzbmFwLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIHNuYXApO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBRdWVyeSBtdXN0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHlcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU1lcmdlKHN5bmNUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHRhZykge1xyXG4gICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKTtcclxuICAgIGlmIChxdWVyeUtleSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE1lcmdlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIGNoYW5nZVRyZWUpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhbiBldmVudCBjYWxsYmFjayBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbihzeW5jVHJlZSwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBza2lwU2V0dXBMaXN0ZW5lciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcXVlcnkuX3BhdGg7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgbGV0IGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9IGZhbHNlO1xyXG4gICAgLy8gQW55IGNvdmVyaW5nIHdyaXRlcyB3aWxsIG5lY2Vzc2FyaWx5IGJlIGF0IHRoZSByb290LCBzbyByZWFsbHkgYWxsIHdlIG5lZWQgdG8gZmluZCBpcyB0aGUgc2VydmVyIGNhY2hlLlxyXG4gICAgLy8gQ29uc2lkZXIgb3B0aW1pemluZyB0aGlzIG9uY2UgdGhlcmUncyBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIHdoYXQgYWN0dWFsIGJlaGF2aW9yIHdpbGwgYmUuXHJcbiAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5mb3JlYWNoT25QYXRoKHBhdGgsIChwYXRoVG9TeW5jUG9pbnQsIHNwKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGhUb1N5bmNQb2ludCwgcGF0aCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHNwLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XHJcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3ApO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgc3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgaWYgKCFzeW5jUG9pbnQpIHtcclxuICAgICAgICBzeW5jUG9pbnQgPSBuZXcgU3luY1BvaW50KCk7XHJcbiAgICAgICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8gPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5zZXQocGF0aCwgc3luY1BvaW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XHJcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2VydmVyQ2FjaGVDb21wbGV0ZTtcclxuICAgIGlmIChzZXJ2ZXJDYWNoZSAhPSBudWxsKSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgICAgICBzdWJ0cmVlLmZvcmVhY2hDaGlsZCgoY2hpbGROYW1lLCBjaGlsZFN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZUNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShjaGlsZFN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgICAgICBpZiAoY29tcGxldGVDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2aWV3QWxyZWFkeUV4aXN0cyA9IHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KTtcclxuICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgYSB0YWcgZm9yIHRoaXMgcXVlcnlcclxuICAgICAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmhhcyhxdWVyeUtleSksICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZycpO1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN5bmNUcmVlR2V0TmV4dFF1ZXJ5VGFnXygpO1xyXG4gICAgICAgIHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuc2V0KHF1ZXJ5S2V5LCB0YWcpO1xyXG4gICAgICAgIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuc2V0KHRhZywgcXVlcnlLZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcGF0aCk7XHJcbiAgICBsZXQgZXZlbnRzID0gc3luY1BvaW50QWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1BvaW50LCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgJiYgIXNraXBTZXR1cExpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KTtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8oc3luY1RyZWUsIHF1ZXJ5LCB2aWV3KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gSWYgdGhlIGxvY2F0aW9uIGRvZXMgbm90IGhhdmUgYVxyXG4gKiBsaXN0ZW5lciBhYm92ZSBpdCwgd2Ugd2lsbCBnZXQgYSBmYWxzZSBcIm51bGxcIi4gVGhpcyBzaG91bGRuJ3QgYmUgYSBwcm9ibGVtIGJlY2F1c2UgdHJhbnNhY3Rpb25zIHdpbGwgYWx3YXlzXHJcbiAqIGhhdmUgYSBsaXN0ZW5lciBhYm92ZSwgYW5kIGF0b21pYyBvcGVyYXRpb25zIHdvdWxkIGNvcnJlY3RseSBzaG93IGEgaml0dGVyIG9mIDxpbmNyZW1lbnQgdmFsdWU+IC0+XHJcbiAqICAgICA8aW5jcmVtZW50ZWQgdG90YWw+IGFzIHRoZSB3cml0ZSBpcyBhcHBsaWVkIGxvY2FsbHkgYW5kIHRoZW4gYWNrbm93bGVkZ2VkIGF0IHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGRhdGEgd2Ugd2FudFxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBBIHNwZWNpZmljIHNldCB0byBiZSBleGNsdWRlZFxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHN5bmNUcmVlLCBwYXRoLCB3cml0ZUlkc1RvRXhjbHVkZSkge1xyXG4gICAgY29uc3QgaW5jbHVkZUhpZGRlblNldHMgPSB0cnVlO1xyXG4gICAgY29uc3Qgd3JpdGVUcmVlID0gc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV87XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgKHBhdGhTb0Zhciwgc3luY1BvaW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGhTb0ZhciwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAoc2VydmVyQ2FjaGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlLCBwYXRoLCBzZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5TZXRzKTtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHN5bmNUcmVlLCBxdWVyeSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gc2VydmVyQ2FjaGUgIT0gbnVsbDtcclxuICAgIGNvbnN0IHNlcnZlckNhY2hlTm9kZSA9IHNlcnZlckNhY2hlQ29tcGxldGVcclxuICAgICAgICA/IG5ldyBDYWNoZU5vZGUoc2VydmVyQ2FjaGUsIHRydWUsIGZhbHNlKVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHF1ZXJ5Ll9wYXRoKTtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGVOb2RlLmdldE5vZGUoKSA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKTtcclxuICAgIHJldHVybiB2aWV3R2V0Q29tcGxldGVOb2RlKHZpZXcpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBtZXRob2QgdGhhdCB2aXNpdHMgYWxsIGRlc2NlbmRhbnQgYW5kIGFuY2VzdG9yIFN5bmNQb2ludHMsIGFwcGx5aW5nIHRoZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIE5PVEVTOlxyXG4gKiAtIERlc2NlbmRhbnQgU3luY1BvaW50cyB3aWxsIGJlIHZpc2l0ZWQgZmlyc3QgKHNpbmNlIHdlIHJhaXNlIGV2ZW50cyBkZXB0aC1maXJzdCkuXHJcbiAqXHJcbiAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxyXG4gKiAgIDEuIEEgdmVyc2lvbiBvZiB0aGUgT3BlcmF0aW9uIHRoYXQgaGFzIGJlZW4gbWFkZSByZWxhdGl2ZSB0byB0aGUgU3luY1BvaW50IGxvY2F0aW9uLlxyXG4gKiAgIDIuIEEgV3JpdGVUcmVlUmVmIG9mIGFueSB3cml0ZXMgd2UgaGF2ZSBjYWNoZWQgYXQgdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXHJcbiAqXHJcbiAqIC0gV2UgY29uY2F0ZW5hdGUgYWxsIG9mIHRoZSBldmVudHMgcmV0dXJuZWQgYnkgZWFjaCBTeW5jUG9pbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG9wZXJhdGlvbikge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25IZWxwZXJfKG9wZXJhdGlvbiwgc3luY1RyZWUuc3luY1BvaW50VHJlZV8sIFxyXG4gICAgLypzZXJ2ZXJDYWNoZT0qLyBudWxsLCB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgbmV3RW1wdHlQYXRoKCkpKTtcclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlIGhlbHBlciBmb3IgYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KG9wZXJhdGlvbi5wYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKG9wZXJhdGlvbiwgc3luY1BvaW50VHJlZSwgc2VydmVyQ2FjaGUsIHdyaXRlc0NhY2hlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgc2VlIGlmIHdlIGNhbiBnZXQgaXQgZnJvbSB0aGlzIFN5bmNQb2ludC5cclxuICAgICAgICBpZiAoc2VydmVyQ2FjaGUgPT0gbnVsbCAmJiBzeW5jUG9pbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBwYXRoR2V0RnJvbnQob3BlcmF0aW9uLnBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gc3luY1BvaW50VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGROYW1lKTtcclxuICAgICAgICBpZiAoY2hpbGRUcmVlICYmIGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkU2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVSZWZDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGROYW1lKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xyXG4gICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQobmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgPT0gbnVsbCAmJiBzeW5jUG9pbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIH1cclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRPcGVyYXRpb24gPSBvcGVyYXRpb24ub3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKTtcclxuICAgICAgICBpZiAoY2hpbGRPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKGNoaWxkT3BlcmF0aW9uLCBjaGlsZFRyZWUsIGNoaWxkU2VydmVyQ2FjaGUsIGNoaWxkV3JpdGVzQ2FjaGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChzeW5jUG9pbnQpIHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfKHN5bmNUcmVlLCB2aWV3KSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IHZpZXcucXVlcnk7XHJcbiAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhhc2hGbjogKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHZpZXdHZXRTZXJ2ZXJDYWNoZSh2aWV3KSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmhhc2goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ29tcGxldGU6IChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoLCB0YWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlMaXN0ZW5Db21wbGV0ZShzeW5jVHJlZSwgcXVlcnkuX3BhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW4gZmFpbGVkLCBraWxsIGFsbCBvZiB0aGUgbGlzdGVuZXJzIGhlcmUsIG5vdCBqdXN0IHRoZSBvbmUgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IG5lZWQgdG8gYmUgc2NvcGVkIHRvIGp1c3QgdGhpcyBsaXN0ZW5lciBpZiB3ZSBjaGFuZ2UgcGVybWlzc2lvbnMgb24gZmlsdGVyZWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JGb3JTZXJ2ZXJDb2RlKHN0YXR1cywgcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qZXZlbnRSZWdpc3RyYXRpb24qLyBudWxsLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KTtcclxuICAgIHJldHVybiBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChxdWVyeUtleSk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnksIGNvbXB1dGVzIGEgXCJxdWVyeUtleVwiIHN1aXRhYmxlIGZvciB1c2UgaW4gb3VyIHF1ZXJ5VG9UYWdNYXBfLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICckJyArIHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgcXVlcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIHdlIGhhdmUgb25lXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWUudGFnVG9RdWVyeU1hcC5nZXQodGFnKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSkge1xyXG4gICAgY29uc3Qgc3BsaXRJbmRleCA9IHF1ZXJ5S2V5LmluZGV4T2YoJyQnKTtcclxuICAgIGFzc2VydChzcGxpdEluZGV4ICE9PSAtMSAmJiBzcGxpdEluZGV4IDwgcXVlcnlLZXkubGVuZ3RoIC0gMSwgJ0JhZCBxdWVyeUtleS4nKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcXVlcnlJZDogcXVlcnlLZXkuc3Vic3RyKHNwbGl0SW5kZXggKyAxKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChxdWVyeUtleS5zdWJzdHIoMCwgc3BsaXRJbmRleCkpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBtZXRob2QgdG8gYXBwbHkgdGFnZ2VkIG9wZXJhdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wZXJhdGlvbikge1xyXG4gICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHF1ZXJ5UGF0aCk7XHJcbiAgICBhc3NlcnQoc3luY1BvaW50LCBcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeVBhdGgpO1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY29sbGFwc2VzIG11bHRpcGxlIHVuZmlsdGVyZWQgdmlld3MgaW50byBhIHNpbmdsZSB2aWV3LCBzaW5jZSB3ZSBvbmx5IG5lZWQgYSBzaW5nbGVcclxuICogbGlzdGVuZXIgZm9yIHRoZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSkge1xyXG4gICAgcmV0dXJuIHN1YnRyZWUuZm9sZCgocmVsYXRpdmVQYXRoLCBtYXliZUNoaWxkU3luY1BvaW50LCBjaGlsZE1hcCkgPT4ge1xyXG4gICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50ICYmIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhtYXliZUNoaWxkU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZVZpZXcgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29tcGxldGVWaWV3XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIHZpZXcgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIGxpc3RlbnMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICBsZXQgdmlld3MgPSBbXTtcclxuICAgICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhtYXliZUNoaWxkU3luY1BvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlYWNoKGNoaWxkTWFwLCAoX2tleSwgY2hpbGRWaWV3cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmlld3MgPSB2aWV3cy5jb25jYXQoY2hpbGRWaWV3cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld3M7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgYSBxdWVyeSB0byBhIHF1ZXJ5IHdlIHNlbmQgdGhlIHNlcnZlciBmb3IgbGlzdGVuaW5nXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHF1ZXJ5XHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSAmJiAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpKSB7XHJcbiAgICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXHJcbiAgICAgICAgLy8gQ2FzdCBpcyBuZWNlc3NhcnkgYmVjYXVzZSByZWYoKSB0ZWNobmljYWxseSByZXR1cm5zIEZpcmViYXNlIHdoaWNoIGlzIGFjdHVhbGx5IGZiLmFwaS5GaXJlYmFzZSB3aGljaCBpbmhlcml0c1xyXG4gICAgICAgIC8vIGZyb20gUXVlcnlcclxuICAgICAgICByZXR1cm4gbmV3IChzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkpKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVSZW1vdmVUYWdzXyhzeW5jVHJlZSwgcXVlcmllcykge1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBxdWVyaWVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5ID0gcXVlcmllc1tqXTtcclxuICAgICAgICBpZiAoIXJlbW92ZWRRdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYSB0YWcgZm9yIHRoaXNcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHJlbW92ZWRRdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeVRhZyA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeVRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVOZXh0UXVlcnlUYWdfKys7XHJcbn1cclxuLyoqXHJcbiAqIEZvciBhIGdpdmVuIG5ldyBsaXN0ZW4sIG1hbmFnZSB0aGUgZGUtZHVwbGljYXRpb24gb2Ygb3V0c3RhbmRpbmcgc3Vic2NyaXB0aW9ucy5cclxuICpcclxuICogQHJldHVybnMgVGhpcyBtZXRob2QgY2FuIHJldHVybiBldmVudHMgdG8gc3VwcG9ydCBzeW5jaHJvbm91cyBkYXRhIHNvdXJjZXNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8oc3luY1RyZWUsIHF1ZXJ5LCB2aWV3KSB7XHJcbiAgICBjb25zdCBwYXRoID0gcXVlcnkuX3BhdGg7XHJcbiAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeSk7XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZS5saXN0ZW5Qcm92aWRlcl8uc3RhcnRMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCB0YWcsIGxpc3RlbmVyLmhhc2hGbiwgbGlzdGVuZXIub25Db21wbGV0ZSk7XHJcbiAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgIC8vIFRoZSByb290IG9mIHRoaXMgc3VidHJlZSBoYXMgb3VyIHF1ZXJ5LiBXZSdyZSBoZXJlIGJlY2F1c2Ugd2UgZGVmaW5pdGVseSBuZWVkIHRvIHNlbmQgYSBsaXN0ZW4gZm9yIHRoYXQsIGJ1dCB3ZVxyXG4gICAgLy8gbWF5IG5lZWQgdG8gc2hhZG93IG90aGVyIGxpc3RlbnMgYXMgd2VsbC5cclxuICAgIGlmICh0YWcpIHtcclxuICAgICAgICBhc3NlcnQoIXN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzdWJ0cmVlLnZhbHVlKSwgXCJJZiB3ZSdyZSBhZGRpbmcgYSBxdWVyeSwgaXQgc2hvdWxkbid0IGJlIHNoYWRvd2VkXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU2hhZG93IGV2ZXJ5dGhpbmcgYXQgb3IgYmVsb3cgdGhpcyBsb2NhdGlvbiwgdGhpcyBpcyBhIGRlZmF1bHQgbGlzdGVuZXIuXHJcbiAgICAgICAgY29uc3QgcXVlcmllc1RvU3RvcCA9IHN1YnRyZWUuZm9sZCgocmVsYXRpdmVQYXRoLCBtYXliZUNoaWxkU3luY1BvaW50LCBjaGlsZE1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkgJiZcclxuICAgICAgICAgICAgICAgIG1heWJlQ2hpbGRTeW5jUG9pbnQgJiZcclxuICAgICAgICAgICAgICAgIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhtYXliZUNoaWxkU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkucXVlcnldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gZGVmYXVsdCBsaXN0ZW5lciBoZXJlLCBmbGF0dGVuIGFueSBkZWVwZXIgcXVlcmllcyBpbnRvIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICBsZXQgcXVlcmllcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzID0gcXVlcmllcy5jb25jYXQoc3luY1BvaW50R2V0UXVlcnlWaWV3cyhtYXliZUNoaWxkU3luY1BvaW50KS5tYXAodmlldyA9PiB2aWV3LnF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlYWNoKGNoaWxkTWFwLCAoX2tleSwgY2hpbGRRdWVyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KGNoaWxkUXVlcmllcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyaWVzVG9TdG9wLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VG9TdG9wID0gcXVlcmllc1RvU3RvcFtpXTtcclxuICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1N0b3ApLCBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeVRvU3RvcCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLm5vZGVfLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxyXG5jbGFzcyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3luY1RyZWUsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLnN5bmNUcmVlXyA9IHN5bmNUcmVlO1xyXG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aENoaWxkKHRoaXMucGF0aF8sIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIodGhpcy5zeW5jVHJlZV8sIGNoaWxkUGF0aCk7XHJcbiAgICB9XHJcbiAgICBub2RlKCkge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodGhpcy5zeW5jVHJlZV8sIHRoaXMucGF0aF8pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBwbGFjZWhvbGRlcnMgZm9yIGRlZmVycmVkIHZhbHVlcy5cclxuICovXHJcbmNvbnN0IGdlbmVyYXRlV2l0aFZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcclxuICAgIHZhbHVlc1sndGltZXN0YW1wJ10gPSB2YWx1ZXNbJ3RpbWVzdGFtcCddIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufTtcclxuLyoqXHJcbiAqIFZhbHVlIHRvIHVzZSB3aGVuIGZpcmluZyBsb2NhbCBldmVudHMuIFdoZW4gd3JpdGluZyBzZXJ2ZXIgdmFsdWVzLCBmaXJlXHJcbiAqIGxvY2FsIGV2ZW50cyB3aXRoIGFuIGFwcHJveGltYXRlIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIGFzLWlzLlxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQoJy5zdicgaW4gdmFsdWUsICdVbmV4cGVjdGVkIGxlYWYgbm9kZSBvciBwcmlvcml0eSBjb250ZW50cycpO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZVsnLnN2J10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVTY2FsYXJEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUodmFsdWVbJy5zdiddLCBleGlzdGluZ1ZhbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIHNlcnZlciB2YWx1ZTogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlc29sdmVTY2FsYXJEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKG9wLCBleGlzdGluZywgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlclZhbHVlc1sndGltZXN0YW1wJ107XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBvcCk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlc29sdmVDb21wbGV4RGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHVudXNlZCkge1xyXG4gICAgaWYgKCFvcC5oYXNPd25Qcm9wZXJ0eSgnaW5jcmVtZW50JykpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIHNlcnZlciB2YWx1ZTogJyArIEpTT04uc3RyaW5naWZ5KG9wLCBudWxsLCAyKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWx0YSA9IG9wWydpbmNyZW1lbnQnXTtcclxuICAgIGlmICh0eXBlb2YgZGVsdGEgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBpbmNyZW1lbnQgdmFsdWU6ICcgKyBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSBleGlzdGluZy5ub2RlKCk7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdOb2RlICE9PSBudWxsICYmIHR5cGVvZiBleGlzdGluZ05vZGUgIT09ICd1bmRlZmluZWQnLCAnRXhwZWN0ZWQgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUgZm9yIG51bGxzJyk7XHJcbiAgICAvLyBJbmNyZW1lbnRpbmcgYSBub24tbnVtYmVyIHNldHMgdGhlIHZhbHVlIHRvIHRoZSBpbmNyZW1lbnRlZCBhbW91bnRcclxuICAgIGlmICghZXhpc3RpbmdOb2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlYWYgPSBleGlzdGluZ05vZGU7XHJcbiAgICBjb25zdCBleGlzdGluZ1ZhbCA9IGxlYWYuZ2V0VmFsdWUoKTtcclxuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdWYWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG4gICAgLy8gTm8gbmVlZCB0byBkbyBvdmVyL3VuZGVyZmxvdyBhcml0aG1ldGljIGhlcmUgYmVjYXVzZSBKUyBvbmx5IGhhbmRsZXMgZmxvYXRzIHVuZGVyIHRoZSBjb3ZlcnNcclxuICAgIHJldHVybiBleGlzdGluZ1ZhbCArIGRlbHRhO1xyXG59O1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSB0cmVlIHdpdGggdGhlXHJcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gd2hpY2ggd3JpdGUgaXMgcmVsYXRpdmVcclxuICogQHBhcmFtIG5vZGUgLSBuZXcgZGF0YSB3cml0dGVuIGF0IHBhdGhcclxuICogQHBhcmFtIHN5bmNUcmVlIC0gY3VycmVudCBkYXRhXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbiAocGF0aCwgbm9kZSwgc3luY1RyZWUsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIoc3luY1RyZWUsIHBhdGgpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSBub2RlIHdpdGggdGhlXHJcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLiAgSWYgdGhlcmUgYXJlIG5vIHNlcnZlciB2YWx1ZXMgaW4gdGhlIG5vZGUsXHJcbiAqIGl0J2xsIGJlIHJldHVybmVkIGFzLWlzLlxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdCA9IGZ1bmN0aW9uIChub2RlLCBleGlzdGluZywgc2VydmVyVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZURlZmVycmVkVmFsdWUobm9kZSwgbmV3IEV4aXN0aW5nVmFsdWVQcm92aWRlcihleGlzdGluZyksIHNlcnZlclZhbHVlcyk7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIGNvbnN0IHJhd1ByaSA9IG5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgIGNvbnN0IHByaW9yaXR5ID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKHJhd1ByaSwgZXhpc3RpbmdWYWwuZ2V0SW1tZWRpYXRlQ2hpbGQoJy5wcmlvcml0eScpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgbGV0IG5ld05vZGU7XHJcbiAgICBpZiAobm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCBsZWFmTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRGVmZXJyZWRMZWFmVmFsdWUobGVhZk5vZGUuZ2V0VmFsdWUoKSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBsZWFmTm9kZS5nZXRWYWx1ZSgpIHx8XHJcbiAgICAgICAgICAgIHByaW9yaXR5ICE9PSBsZWFmTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gbm9kZTtcclxuICAgICAgICBuZXdOb2RlID0gY2hpbGRyZW5Ob2RlO1xyXG4gICAgICAgIGlmIChwcmlvcml0eSAhPT0gY2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkudmFsKCkpIHtcclxuICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlUHJpb3JpdHkobmV3IExlYWZOb2RlKHByaW9yaXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZShjaGlsZE5vZGUsIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSksIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUgIT09IGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgbGlnaHQtd2VpZ2h0IHRyZWUsIHRyYXZlcnNhYmxlIGJ5IHBhdGguICBOb2RlcyBjYW4gaGF2ZSBib3RoIHZhbHVlcyBhbmQgY2hpbGRyZW4uXHJcbiAqIE5vZGVzIGFyZSBub3QgZW51bWVyYXRlZCAoYnkgZm9yRWFjaENoaWxkKSB1bmxlc3MgdGhleSBoYXZlIGEgdmFsdWUgb3Igbm9uLWVtcHR5XHJcbiAqIGNoaWxkcmVuLlxyXG4gKi9cclxuY2xhc3MgVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgbm9kZS5cclxuICAgICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbm9kZS5cclxuICAgICAqIEBwYXJhbSBub2RlIC0gT3B0aW9uYWwgbm9kZSB0byB3cmFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHBhcmVudCA9IG51bGwsIG5vZGUgPSB7IGNoaWxkcmVuOiB7fSwgY2hpbGRDb3VudDogMCB9KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3ViLVRyZWUgZm9yIHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aE9iaiAtIFBhdGggdG8gbG9vayB1cC5cclxuICogQHJldHVybnMgVHJlZSBmb3IgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVTdWJUcmVlKHRyZWUsIHBhdGhPYmopIHtcclxuICAgIC8vIFRPRE86IFJlcXVpcmUgcGF0aE9iaiB0byBiZSBQYXRoP1xyXG4gICAgbGV0IHBhdGggPSBwYXRoT2JqIGluc3RhbmNlb2YgUGF0aCA/IHBhdGhPYmogOiBuZXcgUGF0aChwYXRoT2JqKTtcclxuICAgIGxldCBjaGlsZCA9IHRyZWUsIG5leHQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHNhZmVHZXQoY2hpbGQubm9kZS5jaGlsZHJlbiwgbmV4dCkgfHwge1xyXG4gICAgICAgICAgICBjaGlsZHJlbjoge30sXHJcbiAgICAgICAgICAgIGNoaWxkQ291bnQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNoaWxkID0gbmV3IFRyZWUobmV4dCwgY2hpbGQsIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyZWUgbm9kZS5cclxuICpcclxuICogQHJldHVybnMgVGhlIGRhdGEgb3IgbnVsbCBpZiBubyBkYXRhIGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRWYWx1ZSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLnZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGRhdGEgdG8gdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIHNldC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVTZXRWYWx1ZSh0cmVlLCB2YWx1ZSkge1xyXG4gICAgdHJlZS5ub2RlLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgV2hldGhlciB0aGUgdHJlZSBoYXMgYW55IGNoaWxkcmVuLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUhhc0NoaWxkcmVuKHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlLm5vZGUuY2hpbGRDb3VudCA+IDA7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZSBydGhlIHRyZWUgaXMgZW1wdHkgKG5vIHZhbHVlIG9yIGNoaWxkcmVuKS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVJc0VtcHR5KHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlR2V0VmFsdWUodHJlZSkgPT09IHVuZGVmaW5lZCAmJiAhdHJlZUhhc0NoaWxkcmVuKHRyZWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gZm9yIGVhY2ggY2hpbGQgb2YgdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUZvckVhY2hDaGlsZCh0cmVlLCBhY3Rpb24pIHtcclxuICAgIGVhY2godHJlZS5ub2RlLmNoaWxkcmVuLCAoY2hpbGQsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGFjdGlvbihuZXcgVHJlZShjaGlsZCwgdHJlZSwgY2hpbGRUcmVlKSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogRG9lcyBhIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCBvZiB0aGlzIG5vZGUncyBkZXNjZW5kYW50cywgY2FsbGluZyBhY3Rpb24gZm9yIGVhY2ggb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC4gRGVmYXVsdHMgdG9cclxuICogICBmYWxzZS5cclxuICogQHBhcmFtIGNoaWxkcmVuRmlyc3QgLSBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIGNoaWxkcmVuIGJlZm9yZSBjYWxsaW5nIGl0IG9uXHJcbiAqICAgcGFyZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUZvckVhY2hEZXNjZW5kYW50KHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYsIGNoaWxkcmVuRmlyc3QpIHtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiAhY2hpbGRyZW5GaXJzdCkge1xyXG4gICAgICAgIGFjdGlvbih0cmVlKTtcclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudChjaGlsZCwgYWN0aW9uLCB0cnVlLCBjaGlsZHJlbkZpcnN0KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGluY2x1ZGVTZWxmICYmIGNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIGFjdGlvbiBvbiBlYWNoIGFuY2VzdG9yIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBBY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggcGFyZW50OyByZXR1cm5cclxuICogICB0cnVlIHRvIGFib3J0LlxyXG4gKiBAcGFyYW0gaW5jbHVkZVNlbGYgLSBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIHRoaXMgbm9kZSBhcyB3ZWxsLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhY3Rpb24gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQW5jZXN0b3IodHJlZSwgYWN0aW9uLCBpbmNsdWRlU2VsZikge1xyXG4gICAgbGV0IG5vZGUgPSBpbmNsdWRlU2VsZiA/IHRyZWUgOiB0cmVlLnBhcmVudDtcclxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGFjdGlvbihub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgcGF0aCBvZiB0aGlzIHRyZWUgbm9kZSwgYXMgYSBQYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUdldFBhdGgodHJlZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHRyZWUucGFyZW50ID09PSBudWxsXHJcbiAgICAgICAgPyB0cmVlLm5hbWVcclxuICAgICAgICA6IHRyZWVHZXRQYXRoKHRyZWUucGFyZW50KSArICcvJyArIHRyZWUubmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgb3IgcmVtb3ZlcyB0aGlzIGNoaWxkIGZyb20gaXRzIHBhcmVudCBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgZW1wdHkgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZVBhcmVudHModHJlZSkge1xyXG4gICAgaWYgKHRyZWUucGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdHJlZVVwZGF0ZUNoaWxkKHRyZWUucGFyZW50LCB0cmVlLm5hbWUsIHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhlIHBhc3NlZCBjaGlsZCB0byB0aGlzIHRyZWUgbm9kZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQncyBlbXB0eS5cclxuICpcclxuICogQHBhcmFtIGNoaWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byB1cGRhdGUuXHJcbiAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCB0byB1cGRhdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlVXBkYXRlQ2hpbGQodHJlZSwgY2hpbGROYW1lLCBjaGlsZCkge1xyXG4gICAgY29uc3QgY2hpbGRFbXB0eSA9IHRyZWVJc0VtcHR5KGNoaWxkKTtcclxuICAgIGNvbnN0IGNoaWxkRXhpc3RzID0gY29udGFpbnModHJlZS5ub2RlLmNoaWxkcmVuLCBjaGlsZE5hbWUpO1xyXG4gICAgaWYgKGNoaWxkRW1wdHkgJiYgY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICBkZWxldGUgdHJlZS5ub2RlLmNoaWxkcmVuW2NoaWxkTmFtZV07XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQtLTtcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFjaGlsZEVtcHR5ICYmICFjaGlsZEV4aXN0cykge1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdID0gY2hpbGQubm9kZTtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRDb3VudCsrO1xyXG4gICAgICAgIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcnVlIGZvciBpbnZhbGlkIEZpcmViYXNlIGtleXNcclxuICovXHJcbmNvbnN0IElOVkFMSURfS0VZX1JFR0VYXyA9IC9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBwYXRocy5cclxuICogQWxsb3dzICcvJyBpbiBwYXRocy5cclxuICovXHJcbmNvbnN0IElOVkFMSURfUEFUSF9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWxsb3cgaW4gbGVhZiB2YWx1ZVxyXG4gKi9cclxuY29uc3QgTUFYX0xFQUZfU0laRV8gPSAxMCAqIDEwMjQgKiAxMDI0O1xyXG5jb25zdCBpc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkubGVuZ3RoICE9PSAwICYmICFJTlZBTElEX0tFWV9SRUdFWF8udGVzdChrZXkpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcGF0aFN0cmluZyA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgICAgICFJTlZBTElEX1BBVEhfUkVHRVhfLnRlc3QocGF0aFN0cmluZykpO1xyXG59O1xyXG5jb25zdCBpc1ZhbGlkUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XHJcbiAgICByZXR1cm4gKHByaW9yaXR5ID09PSBudWxsIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInICYmICFpc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkgfHxcclxuICAgICAgICAocHJpb3JpdHkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb250YWlucyhwcmlvcml0eSwgJy5zdicpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBQcmUtdmFsaWRhdGUgYSBkYXR1bSBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gRmlyZWJhc2UgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZyA9IGZ1bmN0aW9uIChmbk5hbWUsIHZhbHVlLCBwYXRoLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShlcnJvclByZWZpeChmbk5hbWUsICd2YWx1ZScpLCB2YWx1ZSwgcGF0aCk7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIGRhdGEgb2JqZWN0IGNsaWVudC1zaWRlIGJlZm9yZSBzZW5kaW5nIHRvIHNlcnZlci5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VEYXRhID0gZnVuY3Rpb24gKGVycm9yUHJlZml4LCBkYXRhLCBwYXRoXykge1xyXG4gICAgY29uc3QgcGF0aCA9IHBhdGhfIGluc3RhbmNlb2YgUGF0aCA/IG5ldyBWYWxpZGF0aW9uUGF0aChwYXRoXywgZXJyb3JQcmVmaXgpIDogcGF0aF87XHJcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICsgJ2NvbnRhaW5zIHVuZGVmaW5lZCAnICsgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0ludmFsaWRKU09OTnVtYmVyKGRhdGEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgJ2NvbnRhaW5zICcgK1xyXG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgbWF4IGxlYWYgc2l6ZSwgYnV0IHRyeSB0byBhdm9pZCB0aGUgdXRmOCBjb252ZXJzaW9uIGlmIHdlIGNhbi5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBkYXRhLmxlbmd0aCA+IE1BWF9MRUFGX1NJWkVfIC8gMyAmJlxyXG4gICAgICAgIHN0cmluZ0xlbmd0aChkYXRhKSA+IE1BWF9MRUFGX1NJWkVfKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAnICtcclxuICAgICAgICAgICAgTUFYX0xFQUZfU0laRV8gK1xyXG4gICAgICAgICAgICAnIHV0ZjggYnl0ZXMgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgIFwiICgnXCIgK1xyXG4gICAgICAgICAgICBkYXRhLnN1YnN0cmluZygwLCA1MCkgK1xyXG4gICAgICAgICAgICBcIi4uLicpXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyA9IFBlcmYgPSBDb25zaWRlciBjb21iaW5pbmcgdGhlIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIG9mIGtleXMgaW50byBOb2RlRnJvbUpTT05cclxuICAgIC8vIHRvIHNhdmUgZXh0cmEgd2Fsa2luZyBvZiBsYXJnZSBvYmplY3RzLlxyXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbGV0IGhhc0RvdFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0FjdHVhbENoaWxkID0gZmFsc2U7XHJcbiAgICAgICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnLnZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgaGFzRG90VmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJy5wcmlvcml0eScgJiYga2V5ICE9PSAnLnN2Jykge1xyXG4gICAgICAgICAgICAgICAgaGFzQWN0dWFsQ2hpbGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFB1c2gocGF0aCwga2V5KTtcclxuICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgsIHZhbHVlLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQb3AocGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhc0RvdFZhbHVlICYmIGhhc0FjdHVhbENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIFwiLnZhbHVlXCIgY2hpbGQgJyArXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgJyBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIHBhdGhzIHBhc3NlZCBpbiB0aGUgZmlyZWJhc2UgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgbWVyZ2VQYXRocykge1xyXG4gICAgbGV0IGksIGN1clBhdGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWVyZ2VQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBwYXRoU2xpY2UoY3VyUGF0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlzW2pdID09PSAnLnByaW9yaXR5JyAmJiBqID09PSBrZXlzLmxlbmd0aCAtIDEpIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVmFsaWRLZXkoa2V5c1tqXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzW2pdICtcclxuICAgICAgICAgICAgICAgICAgICAnKSBpbiBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENoZWNrIHRoYXQgdXBkYXRlIGtleXMgYXJlIG5vdCBkZXNjZW5kYW50cyBvZiBlYWNoIG90aGVyLlxyXG4gICAgLy8gV2UgcmVseSBvbiB0aGUgcHJvcGVydHkgdGhhdCBzb3J0aW5nIGd1YXJhbnRlZXMgdGhhdCBhbmNlc3RvcnMgY29tZVxyXG4gICAgLy8gcmlnaHQgYmVmb3JlIGRlc2NlbmRhbnRzLlxyXG4gICAgbWVyZ2VQYXRocy5zb3J0KHBhdGhDb21wYXJlKTtcclxuICAgIGxldCBwcmV2UGF0aCA9IG51bGw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWVyZ2VQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xyXG4gICAgICAgIGlmIChwcmV2UGF0aCAhPT0gbnVsbCAmJiBwYXRoQ29udGFpbnMocHJldlBhdGgsIGN1clBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAnY29udGFpbnMgYSBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgcHJldlBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAnIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldlBhdGggPSBjdXJQYXRoO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogcHJlLXZhbGlkYXRlIGFuIG9iamVjdCBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gZmlyZWJhc2UgZnVuY3Rpb24gKFxyXG4gKiBtdXN0IGJlIGFuIG9iamVjdCAtIGUuZy4gZm9yIGZpcmViYXNlLnVwZGF0ZSgpKS5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBkYXRhLCBwYXRoLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yUHJlZml4JDEgPSBlcnJvclByZWZpeChmbk5hbWUsICd2YWx1ZXMnKTtcclxuICAgIGlmICghKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4JDEgKyAnIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXJnZVBhdGhzID0gW107XHJcbiAgICBlYWNoKGRhdGEsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VyUGF0aCA9IG5ldyBQYXRoKGtleSk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgkMSwgdmFsdWUsIHBhdGhDaGlsZChwYXRoLCBjdXJQYXRoKSk7XHJcbiAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGN1clBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRQcmlvcml0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICtcclxuICAgICAgICAgICAgICAgICAgICBcImNvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgICAgICBcIicsIHdoaWNoIG11c3QgYmUgYSB2YWxpZCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgJ0ZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZVBhdGhzLnB1c2goY3VyUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzKGVycm9yUHJlZml4JDEsIG1lcmdlUGF0aHMpO1xyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKGZuTmFtZSwgcHJpb3JpdHksIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ2lzICcgK1xyXG4gICAgICAgICAgICBwcmlvcml0eS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xyXG4gICAgICAgICAgICAnc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byBhbGxvdyBpbXBvcnRpbmcgZGF0YSB3aXRoIGEgLnN2LlxyXG4gICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ3ByaW9yaXR5JykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5ICcgK1xyXG4gICAgICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZUtleSA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TmFtZSwga2V5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICtcclxuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIGtleSA9IFwiJyArXHJcbiAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICdcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUGF0aFN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBwYXRoU3RyaW5nID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBwYXRoID0gXCInICtcclxuICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICdcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAocGF0aFN0cmluZykge1xyXG4gICAgICAgIC8vIEFsbG93ICcvLmluZm8vJyBhdCB0aGUgYmVnaW5uaW5nLlxyXG4gICAgICAgIHBhdGhTdHJpbmcgPSBwYXRoU3RyaW5nLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLCAnLycpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24gKGZuTmFtZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5pbmZvJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmbk5hbWUgKyBcIiBmYWlsZWQgPSBDYW4ndCBtb2RpZnkgZGF0YSB1bmRlciAvLmluZm8vXCIpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVVybCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhcnNlZFVybCkge1xyXG4gICAgLy8gVE9ETyA9IFZhbGlkYXRlIHNlcnZlciBiZXR0ZXIuXHJcbiAgICBjb25zdCBwYXRoU3RyaW5nID0gcGFyc2VkVXJsLnBhdGgudG9TdHJpbmcoKTtcclxuICAgIGlmICghKHR5cGVvZiBwYXJzZWRVcmwucmVwb0luZm8uaG9zdCA9PT0gJ3N0cmluZycpIHx8XHJcbiAgICAgICAgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QubGVuZ3RoID09PSAwIHx8XHJcbiAgICAgICAgKCFpc1ZhbGlkS2V5KHBhcnNlZFVybC5yZXBvSW5mby5uYW1lc3BhY2UpICYmXHJcbiAgICAgICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0LnNwbGl0KCc6JylbMF0gIT09ICdsb2NhbGhvc3QnKSB8fFxyXG4gICAgICAgIChwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJiAhaXNWYWxpZFJvb3RQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICd1cmwnKSArXHJcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCAnICtcclxuICAgICAgICAgICAgJ3RoZSBwYXRoIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCIuJyk7XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZXZlbnQgcXVldWUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxyXG4gKiAxLiBJdCBlbnN1cmVzIHdlIG1haW50YWluIGV2ZW50IG9yZGVyIGluIHRoZSBmYWNlIG9mIGV2ZW50IGNhbGxiYWNrcyBkb2luZyBvcGVyYXRpb25zIHRoYXQgcmVzdWx0IGluIG1vcmVcclxuICogICAgZXZlbnRzIGJlaW5nIHF1ZXVlZC5cclxuICogMi4gcmFpc2VRdWV1ZWRFdmVudHMoKSBoYW5kbGVzIGJlaW5nIGNhbGxlZCByZWVudHJhbnRseSBuaWNlbHkuICBUaGF0IGlzLCBpZiBpbiB0aGUgY291cnNlIG9mIHJhaXNpbmcgZXZlbnRzLFxyXG4gKiAgICByYWlzZVF1ZXVlZEV2ZW50cygpIGlzIGNhbGxlZCBhZ2FpbiwgdGhlIFwiaW5uZXJcIiBjYWxsIHdpbGwgcGljayB1cCByYWlzaW5nIGV2ZW50cyB3aGVyZSB0aGUgXCJvdXRlclwiIGNhbGxcclxuICogICAgbGVmdCBvZmYsIGVuc3VyaW5nIHRoYXQgdGhlIGV2ZW50cyBhcmUgc3RpbGwgcmFpc2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIG9yZGVyLlxyXG4gKiAzLiBZb3UgY2FuIHVzZSByYWlzZUV2ZW50c0F0UGF0aCBhbmQgcmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCB0byBlbnN1cmUgb25seSByZWxldmFudCBwcmV2aW91c2x5LXF1ZXVlZFxyXG4gKiAgICBldmVudHMgYXJlIHJhaXNlZCBzeW5jaHJvbm91c2x5LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGNhbiBhbGwgZ28gYXdheSBpZi93aGVuIHdlIG1vdmUgdG8gYXN5bmMgZXZlbnRzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TGlzdHNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIHJlY3Vyc2lvbiBkZXB0aCBvZiByYWlzZVF1ZXVlZEV2ZW50c18sIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWN1cnNpb25EZXB0aF8gPSAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIC8vIFdlIGdyb3VwIGV2ZW50cyBieSBwYXRoLCBzdG9yaW5nIHRoZW0gaW4gYSBzaW5nbGUgRXZlbnRMaXN0LCB0byBtYWtlIGl0IGVhc2llciB0byBza2lwIG92ZXIgdGhlbSBxdWlja2x5LlxyXG4gICAgbGV0IGN1cnJMaXN0ID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnREYXRhTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudERhdGFMaXN0W2ldO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBkYXRhLmdldFBhdGgoKTtcclxuICAgICAgICBpZiAoY3Vyckxpc3QgIT09IG51bGwgJiYgIXBhdGhFcXVhbHMocGF0aCwgY3Vyckxpc3QucGF0aCkpIHtcclxuICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgICAgICAgICAgY3Vyckxpc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3Vyckxpc3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY3Vyckxpc3QgPSB7IGV2ZW50czogW10sIHBhdGggfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3Vyckxpc3QuZXZlbnRzLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3Vyckxpc3QpIHtcclxuICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKVxyXG4gKiBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXHJcbiAqIEBwYXJhbSBldmVudERhdGFMaXN0IC0gVGhlIG5ldyBldmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgoZXZlbnRRdWV1ZSwgcGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhFcXVhbHMoZXZlbnRQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpIGZvclxyXG4gKiBsb2NhdGlvbnMgcmVsYXRlZCB0byB0aGUgc3BlY2lmaWVkIGNoYW5nZSBwYXRoIChpLmUuIGFsbCBhbmNlc3RvcnMgYW5kIGRlc2NlbmRhbnRzKS5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgcmVsYXRlZCAoYW5jZXN0b3Igb3IgZGVzY2VuZGFudCkgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hhbmdlZFBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBldmVudHMgdG8gcmFpc2VcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKGV2ZW50UXVldWUsIGNoYW5nZWRQYXRoLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMoZXZlbnRRdWV1ZSwgZXZlbnREYXRhTGlzdCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZShldmVudFF1ZXVlLCBldmVudFBhdGggPT4gcGF0aENvbnRhaW5zKGV2ZW50UGF0aCwgY2hhbmdlZFBhdGgpIHx8XHJcbiAgICAgICAgcGF0aENvbnRhaW5zKGNoYW5nZWRQYXRoLCBldmVudFBhdGgpKTtcclxufVxyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZShldmVudFF1ZXVlLCBwcmVkaWNhdGUpIHtcclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfKys7XHJcbiAgICBsZXQgc2VudEFsbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50UXVldWUuZXZlbnRMaXN0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBldmVudExpc3QgPSBldmVudFF1ZXVlLmV2ZW50TGlzdHNfW2ldO1xyXG4gICAgICAgIGlmIChldmVudExpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRQYXRoID0gZXZlbnRMaXN0LnBhdGg7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZXZlbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0UmFpc2UoZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSk7XHJcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbnRBbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZW50QWxsKSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZS5yZWN1cnNpb25EZXB0aF8tLTtcclxufVxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbGlzdCBhbmQgcmFpc2VzIGVhY2ggZXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50TGlzdFJhaXNlKGV2ZW50TGlzdCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExpc3QuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gZXZlbnRMaXN0LmV2ZW50c1tpXTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TGlzdC5ldmVudHNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudEZuID0gZXZlbnREYXRhLmdldEV2ZW50UnVubmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZXZlbnQ6ICcgKyBldmVudERhdGEudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoZXZlbnRGbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElOVEVSUlVQVF9SRUFTT04gPSAncmVwb19pbnRlcnJ1cHQnO1xyXG4vKipcclxuICogSWYgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBzdWNjZWVkIGFmdGVyIDI1IHJldHJpZXMsIHdlIGFib3J0IGl0LiBBbW9uZyBvdGhlclxyXG4gKiB0aGluZ3MgdGhpcyBlbnN1cmUgdGhhdCBpZiB0aGVyZSdzIGV2ZXIgYSBidWcgY2F1c2luZyBhIG1pc21hdGNoIGJldHdlZW5cclxuICogY2xpZW50IC8gc2VydmVyIGhhc2hlcyBmb3Igc29tZSBkYXRhLCB3ZSB3b24ndCByZXRyeSBpbmRlZmluaXRlbHkuXHJcbiAqL1xyXG5jb25zdCBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUyA9IDI1O1xyXG4vKipcclxuICogQSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGRhdGEgcmVwb3NpdG9yeS5cclxuICovXHJcbmNsYXNzIFJlcG8ge1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBmb3JjZVJlc3RDbGllbnRfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlc3RDbGllbnRfID0gZm9yY2VSZXN0Q2xpZW50XztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXJfID0gYXBwQ2hlY2tQcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8gPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMubmV4dFdyaXRlSWRfID0gMTtcclxuICAgICAgICB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIC8qKiBBIGxpc3Qgb2YgZGF0YSBwaWVjZXMgYW5kIHBhdGhzIHRvIGJlIHNldCB3aGVuIHRoaXMgY2xpZW50IGRpc2Nvbm5lY3RzLiAqL1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgICAgIC8qKiBTdG9yZXMgcXVldWVzIG9mIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9ucyBmb3IgRmlyZWJhc2UgbG9jYXRpb25zLiAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfID0gbmV3IFRyZWUoKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBAcHJpdmF0ZSBidXQgaXQncyB1c2VkIGJ5IHRlc3RfYWNjZXNzLmpzIGFuZCBpbnRlcm5hbC5qc1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbnVsbDtcclxuICAgICAgICAvLyBUaGlzIGtleSBpcyBpbnRlbnRpb25hbGx5IG5vdCB1cGRhdGVkIGlmIFJlcG9JbmZvIGlzIGxhdGVyIGNoYW5nZWQgb3IgcmVwbGFjZWRcclxuICAgICAgICB0aGlzLmtleSA9IHRoaXMucmVwb0luZm9fLnRvVVJMU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBvZiB0aGlzIEZpcmViYXNlLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9TdGFydChyZXBvLCBhcHBJZCwgYXV0aE92ZXJyaWRlKSB7XHJcbiAgICByZXBvLnN0YXRzXyA9IHN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24ocmVwby5yZXBvSW5mb18pO1xyXG4gICAgaWYgKHJlcG8uZm9yY2VSZXN0Q2xpZW50XyB8fCBiZWluZ0NyYXdsZWQoKSkge1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IG5ldyBSZWFkb25seVJlc3RDbGllbnQocmVwby5yZXBvSW5mb18sIChwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uRGF0YVVwZGF0ZShyZXBvLCBwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfKTtcclxuICAgICAgICAvLyBNaW5vciBoYWNrOiBGaXJlIG9uQ29ubmVjdCBpbW1lZGlhdGVseSwgc2luY2UgdGhlcmUncyBubyBhY3R1YWwgY29ubmVjdGlvbi5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlcG9PbkNvbm5lY3RTdGF0dXMocmVwbywgLyogY29ubmVjdFN0YXR1cz0gKi8gdHJ1ZSksIDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgYXV0aE92ZXJyaWRlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICd1bmRlZmluZWQnICYmIGF1dGhPdmVycmlkZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvYmplY3RzIGFyZSBzdXBwb3J0ZWQgZm9yIG9wdGlvbiBkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aE92ZXJyaWRlIHByb3ZpZGVkOiAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gPSBuZXcgUGVyc2lzdGVudENvbm5lY3Rpb24ocmVwby5yZXBvSW5mb18sIGFwcElkLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCAoY29ubmVjdFN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIGNvbm5lY3RTdGF0dXMpO1xyXG4gICAgICAgIH0sICh1cGRhdGVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcyk7XHJcbiAgICAgICAgfSwgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8sIHJlcG8uYXBwQ2hlY2tQcm92aWRlcl8sIGF1dGhPdmVycmlkZSk7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl87XHJcbiAgICB9XHJcbiAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXy5hZGRUb2tlbkNoYW5nZUxpc3RlbmVyKHRva2VuID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEF1dGhUb2tlbih0b2tlbik7XHJcbiAgICB9KTtcclxuICAgIHJlcG8uYXBwQ2hlY2tQcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihyZXN1bHQgPT4ge1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5yZWZyZXNoQXBwQ2hlY2tUb2tlbihyZXN1bHQudG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBSZXBvcyBmb3IgdGhlIHNhbWUgcmVwb0luZm8gKGkuZS4gdGhlcmUgYXJlIG11bHRpcGxlIEZpcmViYXNlLkNvbnRleHRzIGJlaW5nIHVzZWQpLFxyXG4gICAgLy8gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBvbmUgU3RhdHNSZXBvcnRlci4gIEFzIHN1Y2gsIHdlJ2xsIHJlcG9ydCBzdGF0cyBvdmVyIHRoZSBmaXJzdCBSZXBvIGNyZWF0ZWQuXHJcbiAgICByZXBvLnN0YXRzUmVwb3J0ZXJfID0gc3RhdHNNYW5hZ2VyR2V0T3JDcmVhdGVSZXBvcnRlcihyZXBvLnJlcG9JbmZvXywgKCkgPT4gbmV3IFN0YXRzUmVwb3J0ZXIocmVwby5zdGF0c18sIHJlcG8uc2VydmVyXykpO1xyXG4gICAgLy8gVXNlZCBmb3IgLmluZm8uXHJcbiAgICByZXBvLmluZm9EYXRhXyA9IG5ldyBTbmFwc2hvdEhvbGRlcigpO1xyXG4gICAgcmVwby5pbmZvU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlKHtcclxuICAgICAgICBzdGFydExpc3RlbmluZzogKHF1ZXJ5LCB0YWcsIGN1cnJlbnRIYXNoRm4sIG9uQ29tcGxldGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluZm9FdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJlcG8uaW5mb0RhdGFfLmdldE5vZGUocXVlcnkuX3BhdGgpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvc3NpYmx5IGEgaGFjaywgYnV0IHdlIGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgLmluZm8gZW5kcG9pbnRzLiBXZSBkb24ndCByYWlzZSBudWxsIGV2ZW50c1xyXG4gICAgICAgICAgICAvLyBvbiBpbml0aWFsIGRhdGEuLi5cclxuICAgICAgICAgICAgaWYgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaW5mb0V2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5pbmZvU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCdvaycpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluZm9FdmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiAoKSA9PiB7IH1cclxuICAgIH0pO1xyXG4gICAgcmVwb1VwZGF0ZUluZm8ocmVwbywgJ2Nvbm5lY3RlZCcsIGZhbHNlKTtcclxuICAgIHJlcG8uc2VydmVyU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlKHtcclxuICAgICAgICBzdGFydExpc3RlbmluZzogKHF1ZXJ5LCB0YWcsIGN1cnJlbnRIYXNoRm4sIG9uQ29tcGxldGUpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLmxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCAoc3RhdHVzLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBvbkNvbXBsZXRlKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBxdWVyeS5fcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIE5vIHN5bmNocm9ub3VzIGV2ZW50cyBmb3IgbmV0d29yay1iYWNrZWQgc3luYyB0cmVlc1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiAocXVlcnksIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvLnNlcnZlcl8udW5saXN0ZW4ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcywgdGFraW5nIHRoZSBzZXJ2ZXIgb2Zmc2V0IGludG8gYWNjb3VudCBpZiB3ZSBoYXZlIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZXJ2ZXJUaW1lKHJlcG8pIHtcclxuICAgIGNvbnN0IG9mZnNldE5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKG5ldyBQYXRoKCcuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0JykpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0Tm9kZS52YWwoKSB8fCAwO1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgb2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBTZXJ2ZXJWYWx1ZXMgdXNpbmcgc29tZSB2YXJpYWJsZXMgZnJvbSB0aGUgcmVwbyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbykge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlV2l0aFZhbHVlcyh7XHJcbiAgICAgICAgdGltZXN0YW1wOiByZXBvU2VydmVyVGltZShyZXBvKVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxlZCBieSByZWFsdGltZSB3aGVuIHdlIGdldCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb09uRGF0YVVwZGF0ZShyZXBvLCBwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpIHtcclxuICAgIC8vIEZvciB0ZXN0aW5nLlxyXG4gICAgcmVwby5kYXRhVXBkYXRlQ291bnQrKztcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aChwYXRoU3RyaW5nKTtcclxuICAgIGRhdGEgPSByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja19cclxuICAgICAgICA/IHJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrXyhwYXRoU3RyaW5nLCBkYXRhKVxyXG4gICAgICAgIDogZGF0YTtcclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIGlmICh0YWcpIHtcclxuICAgICAgICBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCB0YWdnZWRDaGlsZHJlbiwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ2dlZFNuYXAgPSBub2RlRnJvbUpTT04oZGF0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkU25hcCwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01lcmdlKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZENoaWxkcmVuID0gbWFwKGRhdGEsIChyYXcpID0+IG5vZGVGcm9tSlNPTihyYXcpKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2UocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgbGV0IGFmZmVjdGVkUGF0aCA9IHBhdGg7XHJcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIGEgbGlzdGVuZXIgb3V0c3RhbmRpbmcgZm9yIGVhY2ggdHJhbnNhY3Rpb24sIHJlY2VpdmluZyBhbnkgZXZlbnRzXHJcbiAgICAgICAgLy8gaXMgYSBwcm94eSBmb3Igc29tZSBjaGFuZ2UgaGF2aW5nIG9jY3VycmVkLlxyXG4gICAgICAgIGFmZmVjdGVkUGF0aCA9IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIGNvbm5lY3RTdGF0dXMpIHtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBjb25uZWN0U3RhdHVzKTtcclxuICAgIGlmIChjb25uZWN0U3RhdHVzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJlcG9SdW5PbkRpc2Nvbm5lY3RFdmVudHMocmVwbyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uU2VydmVySW5mb1VwZGF0ZShyZXBvLCB1cGRhdGVzKSB7XHJcbiAgICBlYWNoKHVwZGF0ZXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcmVwb1VwZGF0ZUluZm8ocmVwbywga2V5LCB2YWx1ZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvVXBkYXRlSW5mbyhyZXBvLCBwYXRoU3RyaW5nLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKCcvLmluZm8vJyArIHBhdGhTdHJpbmcpO1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XHJcbiAgICByZXBvLmluZm9EYXRhXy51cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdOb2RlKTtcclxuICAgIGNvbnN0IGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5pbmZvU3luY1RyZWVfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pIHtcclxuICAgIHJldHVybiByZXBvLm5leHRXcml0ZUlkXysrO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgcHVycG9zZSBvZiBgZ2V0VmFsdWVgIGlzIHRvIHJldHVybiB0aGUgbGF0ZXN0IGtub3duIHZhbHVlXHJcbiAqIHNhdGlzZnlpbmcgYHF1ZXJ5YC5cclxuICpcclxuICogVGhpcyBtZXRob2Qgd2lsbCBmaXJzdCBjaGVjayBmb3IgaW4tbWVtb3J5IGNhY2hlZCB2YWx1ZXNcclxuICogYmVsb25naW5nIHRvIGFjdGl2ZSBsaXN0ZW5lcnMuIElmIHRoZXkgYXJlIGZvdW5kLCBzdWNoIHZhbHVlc1xyXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgbW9zdCB1cC10by1kYXRlLlxyXG4gKlxyXG4gKiBJZiB0aGUgY2xpZW50IGlzIG5vdCBjb25uZWN0ZWQsIHRoaXMgbWV0aG9kIHdpbGwgd2FpdCB1bnRpbCB0aGVcclxuICogIHJlcG8gaGFzIGVzdGFibGlzaGVkIGEgY29ubmVjdGlvbiBhbmQgdGhlbiByZXF1ZXN0IHRoZSB2YWx1ZSBmb3IgYHF1ZXJ5YC5cclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgYWJsZSB0byByZXRyaWV2ZSB0aGUgcXVlcnkgcmVzdWx0IGZvciBhbm90aGVyIHJlYXNvbixcclxuICogaXQgcmVwb3J0cyBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHN1cmZhY2UgYSB2YWx1ZSBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0VmFsdWUocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAvLyBPbmx5IGFjdGl2ZSBxdWVyaWVzIGFyZSBjYWNoZWQuIFRoZXJlIGlzIG5vIHBlcnNpc3RlZCBjYWNoZS5cclxuICAgIGNvbnN0IGNhY2hlZCA9IHN5bmNUcmVlR2V0U2VydmVyVmFsdWUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5KTtcclxuICAgIGlmIChjYWNoZWQgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvLnNlcnZlcl8uZ2V0KHF1ZXJ5KS50aGVuKHBheWxvYWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlRnJvbUpTT04ocGF5bG9hZCkud2l0aEluZGV4KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWxvdyB3ZSBzaW11bGF0ZSB0aGUgYWN0aW9ucyBvZiBhbiBgb25seU9uY2VgIGBvblZhbHVlKClgIGV2ZW50IHdoZXJlOlxyXG4gICAgICAgICAqIEFkZCBhbiBldmVudCByZWdpc3RyYXRpb24sXHJcbiAgICAgICAgICogVXBkYXRlIGRhdGEgYXQgdGhlIHBhdGgsXHJcbiAgICAgICAgICogUmFpc2UgYW55IGV2ZW50cyxcclxuICAgICAgICAgKiBDbGVhbnVwIHRoZSBTeW5jVHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cztcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5Ll9wYXRoLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHN5bmNUcmVlVGFnRm9yUXVlcnkocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5KTtcclxuICAgICAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBXZSBuZWVkIHRvIHJhaXNlIGV2ZW50cyBpbiB0aGUgc2NlbmFyaW8gd2hlcmUgYGdldCgpYCBpcyBjYWxsZWQgYXQgYSBwYXJlbnQgcGF0aCwgYW5kXHJcbiAgICAgICAgICogd2hpbGUgdGhlIGBnZXQoKWAgaXMgcGVuZGluZywgYG9uVmFsdWVgIGlzIGNhbGxlZCBhdCBhIGNoaWxkIGxvY2F0aW9uLiBXaGlsZSBnZXQoKSBpcyB3YWl0aW5nXHJcbiAgICAgICAgICogZm9yIHRoZSBkYXRhLCBgb25WYWx1ZWAgd2lsbCByZWdpc3RlciBhIG5ldyBldmVudC4gVGhlbiwgZ2V0KCkgd2lsbCBjb21lIGJhY2ssIGFuZCB1cGRhdGUgdGhlIHN5bmNUcmVlXHJcbiAgICAgICAgICogYW5kIGl0cyBjb3JyZXNwb25kaW5nIHNlcnZlckNhY2hlLCBpbmNsdWRpbmcgdGhlIGNoaWxkIGxvY2F0aW9uIHdoZXJlIGBvblZhbHVlYCBpcyBjYWxsZWQuIFRoZW4sXHJcbiAgICAgICAgICogYG9uVmFsdWVgIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQgZnJvbSB0aGUgc2VydmVyLCBidXQgbG9vayBhdCB0aGUgc3luY1RyZWUgYW5kIHNlZSB0aGF0IHRoZSBkYXRhIHJlY2VpdmVkXHJcbiAgICAgICAgICogZnJvbSB0aGUgc2VydmVyIGlzIGFscmVhZHkgYXQgdGhlIFN5bmNQb2ludCwgYW5kIHNvIHRoZSBgb25WYWx1ZWAgY2FsbGJhY2sgd2lsbCBuZXZlciBnZXQgZmlyZWQuXHJcbiAgICAgICAgICogQ2FsbGluZyBgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoKWAgaXMgdGhlIGNvcnJlY3Qgd2F5IHRvIHByb3BhZ2F0ZSB0aGUgZXZlbnRzIGFuZFxyXG4gICAgICAgICAqIGVuc3VyZSB0aGUgY29ycmVzcG9uZGluZyBjaGlsZCBldmVudHMgd2lsbCBnZXQgZmlyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBudWxsLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgcmVwb0xvZyhyZXBvLCAnZ2V0IGZvciBxdWVyeSAnICsgc3RyaW5naWZ5KHF1ZXJ5KSArICcgZmFpbGVkOiAnICsgZXJyKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1NldFdpdGhQcmlvcml0eShyZXBvLCBwYXRoLCBuZXdWYWwsIG5ld1ByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdzZXQnLCB7XHJcbiAgICAgICAgcGF0aDogcGF0aC50b1N0cmluZygpLFxyXG4gICAgICAgIHZhbHVlOiBuZXdWYWwsXHJcbiAgICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XHJcbiAgICB9KTtcclxuICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgYmVoYXZpb3IgdG8gZWl0aGVyIChhKSBzdG9yZSBmbGFnIHRvIHNraXAgcmVzb2x2aW5nIHdoZXJlIHBvc3NpYmxlIGFuZCAvIG9yXHJcbiAgICAvLyAoYikgc3RvcmUgdW5yZXNvbHZlZCBwYXRocyBvbiBKU09OIHBhcnNlXHJcbiAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIG5ld1ByaW9yaXR5KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBleGlzdGluZywgc2VydmVyVmFsdWVzKTtcclxuICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgd3JpdGVJZCwgdHJ1ZSk7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgIHJlcG8uc2VydmVyXy5wdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlVW5yZXNvbHZlZC52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgd2Fybignc2V0IGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjbGVhckV2ZW50cyA9IHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB3cml0ZUlkLCAhc3VjY2Vzcyk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIFtdKTtcclxufVxyXG5mdW5jdGlvbiByZXBvVXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndXBkYXRlJywgeyBwYXRoOiBwYXRoLnRvU3RyaW5nKCksIHZhbHVlOiBjaGlsZHJlblRvTWVyZ2UgfSk7XHJcbiAgICAvLyBTdGFydCB3aXRoIG91ciBleGlzdGluZyBkYXRhIGFuZCBtZXJnZSBlYWNoIGNoaWxkIGludG8gaXQuXHJcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgY2hhbmdlZENoaWxkcmVuID0ge307XHJcbiAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRLZXksIGNoYW5nZWRWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgY2hhbmdlZENoaWxkcmVuW2NoYW5nZWRLZXldID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkS2V5KSwgbm9kZUZyb21KU09OKGNoYW5nZWRWYWx1ZSksIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhyZXBvLmV2ZW50UXVldWVfLCBldmVudHMpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5tZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCd1cGRhdGUgYXQgJyArIHBhdGggKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSBjbGVhckV2ZW50cy5sZW5ndGggPiAwID8gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIDogcGF0aDtcclxuICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBjbGVhckV2ZW50cyk7XHJcbiAgICAgICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hhbmdlZFBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkUGF0aCkpO1xyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIFtdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZyhcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyBhbGwgb2YgdGhlIGNoYW5nZXMgc3RvcmVkIHVwIGluIHRoZSBvbkRpc2Nvbm5lY3RfIHRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ29uRGlzY29ubmVjdEV2ZW50cycpO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXBvLm9uRGlzY29ubmVjdF8sIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgbm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGgsIG5vZGUsIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSwgcGF0aCwgcmVzb2x2ZWQpO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgc25hcCkgPT4ge1xyXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgc25hcCkpO1xyXG4gICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgcmVwby5vbkRpc2Nvbm5lY3RfID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBuZXdFbXB0eVBhdGgoKSwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0Q2FuY2VsKHJlcG8sIHBhdGgsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RDYW5jZWwocGF0aC50b1N0cmluZygpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHJlcG8ub25EaXNjb25uZWN0XywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdFNldChyZXBvLCBwYXRoLCB2YWx1ZSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZUZyb21KU09OKHZhbHVlLCBwcmlvcml0eSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RVcGRhdGUocmVwbywgcGF0aCwgY2hpbGRyZW5Ub01lcmdlLCBvbkNvbXBsZXRlKSB7XHJcbiAgICBpZiAoaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XHJcbiAgICAgICAgbG9nKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCAnb2snLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoQ2hpbGQocGF0aCwgY2hpbGROYW1lKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGxldCBldmVudHM7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHF1ZXJ5Ll9wYXRoKSA9PT0gJy5pbmZvJykge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5pbmZvU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbihyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0F0UGF0aChyZXBvLmV2ZW50UXVldWVfLCBxdWVyeS5fcGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gVGhlc2UgYXJlIGd1YXJhbnRlZWQgbm90IHRvIHJhaXNlIGV2ZW50cywgc2luY2Ugd2UncmUgbm90IHBhc3NpbmcgaW4gYSBjYW5jZWxFcnJvci4gSG93ZXZlciwgd2UgY2FuIGZ1dHVyZS1wcm9vZlxyXG4gICAgLy8gYSBsaXR0bGUgYml0IGJ5IGhhbmRsaW5nIHRoZSByZXR1cm4gdmFsdWVzIGFueXdheXMuXHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0ludGVycnVwdChyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pbnRlcnJ1cHQoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb1Jlc3VtZShyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5yZXN1bWUoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb0xvZyhyZXBvLCAuLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgcHJlZml4ID0gJyc7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICBwcmVmaXggPSByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pZCArICc6JztcclxuICAgIH1cclxuICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIGNhbGxiYWNrLCBzdGF0dXMsIGVycm9yUmVhc29uKSB7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBleGNlcHRpb25HdWFyZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IChzdGF0dXMgfHwgJ2Vycm9yJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gY29kZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvclJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJzogJyArIGVycm9yUmVhc29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiwgYWRkcyBpdCB0byB0aGUgdHJhbnNhY3Rpb25zIHdlJ3JlIHRyYWNraW5nLCBhbmRcclxuICogc2VuZHMgaXQgdG8gdGhlIHNlcnZlciBpZiBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGF0IHdoaWNoIHRvIGRvIHRyYW5zYWN0aW9uLlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBVcGRhdGUgY2FsbGJhY2suXHJcbiAqIEBwYXJhbSBvbkNvbXBsZXRlIC0gQ29tcGxldGlvbiBjYWxsYmFjay5cclxuICogQHBhcmFtIHVud2F0Y2hlciAtIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gbm8gbG9uZ2VyXHJcbiAqIG5lZWQgZGF0YSB1cGRhdGVzIGZvciBgcGF0aGAuXHJcbiAqIEBwYXJhbSBhcHBseUxvY2FsbHkgLSBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIGludGVybWVkaWF0ZSByZXN1bHRzIHZpc2libGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlcG8sIHBhdGgsIHRyYW5zYWN0aW9uVXBkYXRlLCBvbkNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndHJhbnNhY3Rpb24gb24gJyArIHBhdGgpO1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB0cmFuc2FjdGlvbi5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgdXBkYXRlOiB0cmFuc2FjdGlvblVwZGF0ZSxcclxuICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgIC8vIE9uZSBvZiBUcmFuc2FjdGlvblN0YXR1cyBlbnVtcy5cclxuICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgLy8gVXNlZCB3aGVuIGNvbWJpbmluZyB0cmFuc2FjdGlvbnMgYXQgZGlmZmVyZW50IGxvY2F0aW9ucyB0byBmaWd1cmUgb3V0XHJcbiAgICAgICAgLy8gd2hpY2ggb25lIGdvZXMgZmlyc3QuXHJcbiAgICAgICAgb3JkZXI6IExVSURHZW5lcmF0b3IoKSxcclxuICAgICAgICAvLyBXaGV0aGVyIHRvIHJhaXNlIGxvY2FsIGV2ZW50cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICBhcHBseUxvY2FsbHksXHJcbiAgICAgICAgLy8gQ291bnQgb2YgaG93IG1hbnkgdGltZXMgd2UndmUgcmV0cmllZCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgcmV0cnlDb3VudDogMCxcclxuICAgICAgICAvLyBGdW5jdGlvbiB0byBjYWxsIHRvIGNsZWFuIHVwIG91ciAub24oKSBsaXN0ZW5lci5cclxuICAgICAgICB1bndhdGNoZXIsXHJcbiAgICAgICAgLy8gU3RvcmVzIHdoeSBhIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxyXG4gICAgICAgIGFib3J0UmVhc29uOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRXcml0ZUlkOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdzogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZDogbnVsbFxyXG4gICAgfTtcclxuICAgIC8vIFJ1biB0cmFuc2FjdGlvbiBpbml0aWFsbHkuXHJcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgdW5kZWZpbmVkKTtcclxuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRJbnB1dFNuYXBzaG90ID0gY3VycmVudFN0YXRlO1xyXG4gICAgY29uc3QgbmV3VmFsID0gdHJhbnNhY3Rpb24udXBkYXRlKGN1cnJlbnRTdGF0ZS52YWwoKSk7XHJcbiAgICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBBYm9ydCB0cmFuc2FjdGlvbi5cclxuICAgICAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBudWxsO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbnVsbDtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdWYWwsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIC8vIE1hcmsgYXMgcnVuIGFuZCBhZGQgdG8gb3VyIHF1ZXVlLlxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgIGNvbnN0IHF1ZXVlTm9kZSA9IHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUocXVldWVOb2RlKSB8fCBbXTtcclxuICAgICAgICBub2RlUXVldWUucHVzaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKHF1ZXVlTm9kZSwgbm9kZVF1ZXVlKTtcclxuICAgICAgICAvLyBVcGRhdGUgdmlzaWJsZURhdGEgYW5kIHJhaXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgcmFpc2UgZXZlbnRzIGFmdGVyIHVwZGF0aW5nIGFsbCBvZiBvdXJcclxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIHVzZXIgY291bGQgc3RhcnQgbmV3IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrcy5cclxuICAgICAgICBsZXQgcHJpb3JpdHlGb3JOb2RlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBuZXdWYWwgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgY29udGFpbnMobmV3VmFsLCAnLnByaW9yaXR5JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gc2FmZUdldChuZXdWYWwsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGlzVmFsaWRQcmlvcml0eShwcmlvcml0eUZvck5vZGUpLCAnSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gJyArXHJcbiAgICAgICAgICAgICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgpIHx8XHJcbiAgICAgICAgICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OKG5ld1ZhbCwgcHJpb3JpdHlGb3JOb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgY3VycmVudFN0YXRlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld05vZGVVbnJlc29sdmVkO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV4Y2x1ZGVTZXRzIC0gQSBzcGVjaWZpYyBzZXQgdG8gZXhjbHVkZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB7XHJcbiAgICByZXR1cm4gKHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgZXhjbHVkZVNldHMpIHx8XHJcbiAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhbnkgYWxyZWFkeS1ydW4gdHJhbnNhY3Rpb25zIHRoYXQgYXJlbid0IHdhaXRpbmcgZm9yIG91dHN0YW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyB0byBjb21wbGV0ZS5cclxuICpcclxuICogRXh0ZXJuYWxseSBpdCdzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgYnV0IGl0IGNhbGxzIGl0c2VsZiByZWN1cnNpdmVseVxyXG4gKiB3aXRoIGEgcGFydGljdWxhciB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHJlY3Vyc2UgdGhyb3VnaCB0aGUgdHJlZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCBub2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pIHtcclxuICAgIC8vIEJlZm9yZSByZWN1cnNpbmcsIG1ha2Ugc3VyZSBhbnkgY29tcGxldGVkIHRyYW5zYWN0aW9ucyBhcmUgcmVtb3ZlZC5cclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKTtcclxuICAgIH1cclxuICAgIGlmICh0cmVlR2V0VmFsdWUobm9kZSkpIHtcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgbm9kZSk7XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXVlLmxlbmd0aCA+IDAsICdTZW5kaW5nIHplcm8gbGVuZ3RoIHRyYW5zYWN0aW9uIHF1ZXVlJyk7XHJcbiAgICAgICAgY29uc3QgYWxsUnVuID0gcXVldWUuZXZlcnkoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovKTtcclxuICAgICAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXHJcbiAgICAgICAgaWYgKGFsbFJ1bikge1xyXG4gICAgICAgICAgICByZXBvU2VuZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJlZUdldFBhdGgobm9kZSksIHF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmVlSGFzQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgY2hpbGROb2RlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBsaXN0IG9mIHJ1biB0cmFuc2FjdGlvbnMsIHNlbmQgdGhlbSB0byB0aGUgc2VydmVyIGFuZCB0aGVuIGhhbmRsZVxyXG4gKiB0aGUgcmVzdWx0IChzdWNjZXNzIG9yIGZhaWx1cmUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgcXVldWUuXHJcbiAqIEBwYXJhbSBxdWV1ZSAtIFF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB1bmRlciB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHBhdGgsIHF1ZXVlKSB7XHJcbiAgICAvLyBNYXJrIHRyYW5zYWN0aW9ucyBhcyBzZW50IGFuZCBpbmNyZW1lbnQgcmV0cnkgY291bnQhXHJcbiAgICBjb25zdCBzZXRzVG9JZ25vcmUgPSBxdWV1ZS5tYXAodHhuID0+IHtcclxuICAgICAgICByZXR1cm4gdHhuLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgbGV0IHNuYXBUb1NlbmQgPSBsYXRlc3RTdGF0ZTtcclxuICAgIGNvbnN0IGxhdGVzdEhhc2ggPSBsYXRlc3RTdGF0ZS5oYXNoKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHhuID0gcXVldWVbaV07XHJcbiAgICAgICAgYXNzZXJ0KHR4bi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovLCAndHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLicpO1xyXG4gICAgICAgIHR4bi5zdGF0dXMgPSAxIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQgKi87XHJcbiAgICAgICAgdHhuLnJldHJ5Q291bnQrKztcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHhuLnBhdGgpO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB0aGUgb3V0cHV0IHNuYXBzaG90IG11c3QgYmUgZGVmaW5lZC5cclxuICAgICAgICBzbmFwVG9TZW5kID0gc25hcFRvU2VuZC51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGggLyoqIEB0eXBlIHshTm9kZX0gKi8sIHR4bi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YVRvU2VuZCA9IHNuYXBUb1NlbmQudmFsKHRydWUpO1xyXG4gICAgY29uc3QgcGF0aFRvU2VuZCA9IHBhdGg7XHJcbiAgICAvLyBTZW5kIHRoZSBwdXQuXHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGhUb1NlbmQudG9TdHJpbmcoKSwgZGF0YVRvU2VuZCwgKHN0YXR1cykgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIHB1dCByZXNwb25zZScsIHtcclxuICAgICAgICAgICAgcGF0aDogcGF0aFRvU2VuZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBzdGF0dXNcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZVxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cclxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmV2ZXIgdW5zZXQgdGhlIG91dHB1dCBzbmFwc2hvdCwgYW5kIGdpdmVuIHRoYXQgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShudWxsLCB0cnVlLCBxdWV1ZVtpXS5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm93IHJlbW92ZSB0aGUgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgICAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKSk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cclxuICAgICAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgb25Db21wbGV0ZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIG5vIGxvbmdlciBzZW50LiAgVXBkYXRlIHRoZWlyIHN0YXR1cyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnZGF0YXN0YWxlJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5zdGF0dXMgPT09IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybigndHJhbnNhY3Rpb24gYXQgJyArIHBhdGhUb1NlbmQudG9TdHJpbmcoKSArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBsYXRlc3RIYXNoKTtcclxufVxyXG4vKipcclxuICogRmluZHMgYWxsIHRyYW5zYWN0aW9ucyBkZXBlbmRlbnQgb24gdGhlIGRhdGEgYXQgY2hhbmdlZFBhdGggYW5kIHJlcnVucyB0aGVtLlxyXG4gKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFueSB0aW1lIGNhY2hlZCBkYXRhIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuIFRoaXNcclxuICogaXMgdGhlIHBhdGggYXQgd2hpY2ggZXZlbnRzIG5lZWQgdG8gYmUgcmFpc2VkIGZvci5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggaW4gbWVyZ2VkRGF0YSB0aGF0IGNoYW5nZWQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgY2hhbmdlZFBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlID0gcmVwb0dldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlKHJlcG8sIGNoYW5nZWRQYXRoKTtcclxuICAgIGNvbnN0IHBhdGggPSB0cmVlR2V0UGF0aChyb290TW9zdFRyYW5zYWN0aW9uTm9kZSk7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG4vKipcclxuICogRG9lcyBhbGwgdGhlIHdvcmsgb2YgcmVydW5uaW5nIHRyYW5zYWN0aW9ucyAoYXMgd2VsbCBhcyBjbGVhbnMgdXAgYWJvcnRlZFxyXG4gKiB0cmFuc2FjdGlvbnMgYW5kIHdoYXRub3QpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVldWUgLSBUaGUgcXVldWUgb2YgdHJhbnNhY3Rpb25zIHRvIHJ1bi5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0aGUgcXVldWUgaXMgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCkge1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcclxuICAgIH1cclxuICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3JcclxuICAgIC8vIHNldHMuXHJcbiAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIC8vIElnbm9yZSBhbGwgb2YgdGhlIHNldHMgd2UncmUgZ29pbmcgdG8gcmUtcnVuLlxyXG4gICAgY29uc3QgdHhuc1RvUmVydW4gPSBxdWV1ZS5maWx0ZXIocSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHEuc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gdHhuc1RvUmVydW4ubWFwKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBxdWV1ZVtpXTtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgbGV0IGFib3J0VHJhbnNhY3Rpb24gPSBmYWxzZSwgYWJvcnRSZWFzb247XHJcbiAgICAgICAgYXNzZXJ0KHJlbGF0aXZlUGF0aCAhPT0gbnVsbCwgJ3JlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC4nKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovKSB7XHJcbiAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHRyYW5zYWN0aW9uLmFib3J0UmVhc29uO1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZXRyeUNvdW50ID49IE1BWF9UUkFOU0FDVElPTl9SRVRSSUVTKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gJ21heHJldHJ5JztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgcmVydW5zIGEgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHRyYW5zYWN0aW9uLnBhdGgsIHNldHNUb0lnbm9yZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHF1ZXVlW2ldLnVwZGF0ZShjdXJyZW50Tm9kZS52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdEYXRhLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RGF0YU5vZGUgPSBub2RlRnJvbUpTT04obmV3RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwbGljaXRQcmlvcml0eSA9IHR5cGVvZiBuZXdEYXRhID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMobmV3RGF0YSwgJy5wcmlvcml0eScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRQcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGFOb2RlID0gbmV3RGF0YU5vZGUudXBkYXRlUHJpb3JpdHkoY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFdyaXRlSWQgPSB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZVJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdEYXRhTm9kZSwgY3VycmVudE5vZGUsIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbmV3RGF0YU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlcyBzZXRzVG9JZ25vcmUgaW4gcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICBzZXRzVG9JZ25vcmUuc3BsaWNlKHNldHNUb0lnbm9yZS5pbmRleE9mKG9sZFdyaXRlSWQpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlVc2VyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5wYXRoLCBuZXdOb2RlUmVzb2x2ZWQsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBvbGRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdub2RhdGEnO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICBldmVudHMgPSBbXTtcclxuICAgICAgICBpZiAoYWJvcnRUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBBYm9ydC5cclxuICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMiAvKiBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQgKi87XHJcbiAgICAgICAgICAgIC8vIFJlbW92aW5nIGEgbGlzdGVuZXIgY2FuIHRyaWdnZXIgcHJ1bmluZyB3aGljaCBjYW4gbXVjayB3aXRoXHJcbiAgICAgICAgICAgIC8vIG1lcmdlZERhdGEvdmlzaWJsZURhdGEgKGFzIGl0IHBydW5lcyBkYXRhKS4gU28gZGVmZXIgdGhlIHVud2F0Y2hlclxyXG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSdyZSBkb25lLlxyXG4gICAgICAgICAgICAoZnVuY3Rpb24gKHVud2F0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh1bndhdGNoZXIsIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9KShxdWV1ZVtpXS51bndhdGNoZXIpO1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0UmVhc29uID09PSAnbm9kYXRhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgZmFsc2UsIHF1ZXVlW2ldLmN1cnJlbnRJbnB1dFNuYXBzaG90KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG5ldyBFcnJvcihhYm9ydFJlYXNvbiksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIC8vIE5vdyBmaXJlIGNhbGxiYWNrcywgbm93IHRoYXQgd2UncmUgaW4gYSBnb29kLCBrbm93biBzdGF0ZS5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgIH1cclxuICAgIC8vIFRyeSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiByZXN1bHQgdG8gdGhlIHNlcnZlci5cclxuICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByb290bW9zdCBhbmNlc3RvciBub2RlIG9mIHRoZSBzcGVjaWZpZWQgcGF0aCB0aGF0IGhhcyBhIHBlbmRpbmdcclxuICogdHJhbnNhY3Rpb24gb24gaXQsIG9yIGp1c3QgcmV0dXJucyB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUgYXJlXHJcbiAqIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9uIGFueSBhbmNlc3Rvci5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gdG8gc3RhcnQgYXQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBub2RlIHdpdGggYSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSB7XHJcbiAgICBsZXQgZnJvbnQ7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgcm9vdCBhbmQgd2FsayBkZWVwZXIgaW50byB0aGUgdHJlZSB0b3dhcmRzIHBhdGggdW50aWwgd2VcclxuICAgIC8vIGZpbmQgYSBub2RlIHdpdGggcGVuZGluZyB0cmFuc2FjdGlvbnMuXHJcbiAgICBsZXQgdHJhbnNhY3Rpb25Ob2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV87XHJcbiAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIHdoaWxlIChmcm9udCAhPT0gbnVsbCAmJiB0cmVlR2V0VmFsdWUodHJhbnNhY3Rpb25Ob2RlKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUodHJhbnNhY3Rpb25Ob2RlLCBmcm9udCk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2FjdGlvbk5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgcXVldWUgb2YgYWxsIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkXHJcbiAqIHRyYW5zYWN0aW9uTm9kZS5cclxuICpcclxuICogQHBhcmFtIHRyYW5zYWN0aW9uTm9kZVxyXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0J1aWxkVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpIHtcclxuICAgIC8vIFdhbGsgYW55IGNoaWxkIHRyYW5zYWN0aW9uIHF1ZXVlcyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhIHNpbmdsZSBxdWV1ZS5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uUXVldWUgPSBbXTtcclxuICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlLCB0cmFuc2FjdGlvblF1ZXVlKTtcclxuICAgIC8vIFNvcnQgdGhlbSBieSB0aGUgb3JkZXIgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIGNyZWF0ZWQuXHJcbiAgICB0cmFuc2FjdGlvblF1ZXVlLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcclxuICAgIHJldHVybiB0cmFuc2FjdGlvblF1ZXVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgbm9kZSwgcXVldWUpIHtcclxuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChub2RlUXVldWUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVRdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGVRdWV1ZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZCA9PiB7XHJcbiAgICAgICAgcmVwb0FnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZShyZXBvLCBjaGlsZCwgcXVldWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBDT01QTEVURUQgdHJhbnNhY3Rpb25zIGF0IG9yIGJlbG93IHRoaXMgbm9kZSBpbiB0aGUgdHJhbnNhY3Rpb25RdWV1ZVRyZWVfLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIG5vZGUpIHtcclxuICAgIGNvbnN0IHF1ZXVlID0gdHJlZUdldFZhbHVlKG5vZGUpO1xyXG4gICAgaWYgKHF1ZXVlKSB7XHJcbiAgICAgICAgbGV0IHRvID0gMDtcclxuICAgICAgICBmb3IgKGxldCBmcm9tID0gMDsgZnJvbSA8IHF1ZXVlLmxlbmd0aDsgZnJvbSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZVtmcm9tXS5zdGF0dXMgIT09IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVt0b10gPSBxdWV1ZVtmcm9tXTtcclxuICAgICAgICAgICAgICAgIHRvKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gdG87XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZSA6IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQWJvcnRzIGFsbCB0cmFuc2FjdGlvbnMgb24gYW5jZXN0b3JzIG9yIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICogQ2FsbGVkIHdoZW4gZG9pbmcgYSBzZXQoKSBvciB1cGRhdGUoKSBzaW5jZSB3ZSBjb25zaWRlciB0aGVtIGluY29tcGF0aWJsZVxyXG4gKiB3aXRoIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGZvciB3aGljaCB3ZSB3YW50IHRvIGFib3J0IHJlbGF0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIHtcclxuICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHRyZWVHZXRQYXRoKHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSk7XHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbk5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgdHJlZUZvckVhY2hEZXNjZW5kYW50KHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZmZlY3RlZFBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0IHRyYW5zYWN0aW9ucyBzdG9yZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBxdWV1ZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYWJvcnQgdHJhbnNhY3Rpb25zIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgLy8gb3Igc2V0cy5cclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAvLyBHbyB0aHJvdWdoIHF1ZXVlLiAgQW55IGFscmVhZHktc2VudCB0cmFuc2FjdGlvbnMgbXVzdCBiZSBtYXJrZWQgZm9yXHJcbiAgICAgICAgLy8gYWJvcnQsIHdoaWxlIHRoZSB1bnNlbnQgb25lcyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgbGV0IGxhc3RTZW50ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAocXVldWVbaV0uc3RhdHVzID09PSAxIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChsYXN0U2VudCA9PT0gaSAtIDEsICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLicpO1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gTWFyayB0cmFuc2FjdGlvbiBmb3IgYWJvcnQgd2hlbiBpdCBjb21lcyBiYWNrLlxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSAnc2V0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChxdWV1ZVtpXS5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovLCAnVW5leHBlY3RlZCB0cmFuc2FjdGlvbiBzdGF0dXMgaW4gYWJvcnQnKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhYm9ydCBpdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG5ldyBFcnJvcignc2V0JyksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RTZW50ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBub3Qgd2FpdGluZyBmb3IgYW55IHNlbnQgdHJhbnNhY3Rpb25zLiAgV2UgY2FuIGNsZWFyIHRoZSBxdWV1ZS5cclxuICAgICAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zYWN0aW9ucyB3ZSBhYm9ydGVkLlxyXG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSBsYXN0U2VudCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBmaXJlIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgdHJlZUdldFBhdGgobm9kZSksIGV2ZW50cyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoU3RyaW5nKSB7XHJcbiAgICBsZXQgcGF0aFN0cmluZ0RlY29kZWQgPSAnJztcclxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGhTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwaWVjZSA9IHBpZWNlc1tpXTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmdEZWNvZGVkICs9ICcvJyArIHBpZWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoU3RyaW5nRGVjb2RlZDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMga2V5IHZhbHVlIGhhc2hcclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5KHF1ZXJ5U3RyaW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0ge307XHJcbiAgICBpZiAocXVlcnlTdHJpbmcuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBxdWVyeVN0cmluZy5zcGxpdCgnJicpKSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrdiA9IHNlZ21lbnQuc3BsaXQoJz0nKTtcclxuICAgICAgICBpZiAoa3YubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNbZGVjb2RlVVJJQ29tcG9uZW50KGt2WzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQoa3ZbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCBxdWVyeSBzZWdtZW50ICcke3NlZ21lbnR9JyBpbiBxdWVyeSAnJHtxdWVyeVN0cmluZ30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuY29uc3QgcGFyc2VSZXBvSW5mbyA9IGZ1bmN0aW9uIChkYXRhVVJMLCBub2RlQWRtaW4pIHtcclxuICAgIGNvbnN0IHBhcnNlZFVybCA9IHBhcnNlRGF0YWJhc2VVUkwoZGF0YVVSTCksIG5hbWVzcGFjZSA9IHBhcnNlZFVybC5uYW1lc3BhY2U7XHJcbiAgICBpZiAocGFyc2VkVXJsLmRvbWFpbiA9PT0gJ2ZpcmViYXNlLmNvbScpIHtcclxuICAgICAgICBmYXRhbChwYXJzZWRVcmwuaG9zdCArXHJcbiAgICAgICAgICAgICcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkJyk7XHJcbiAgICB9XHJcbiAgICAvLyBDYXRjaCBjb21tb24gZXJyb3Igb2YgdW5pbml0aWFsaXplZCBuYW1lc3BhY2UgdmFsdWUuXHJcbiAgICBpZiAoKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJykgJiZcclxuICAgICAgICBwYXJzZWRVcmwuZG9tYWluICE9PSAnbG9jYWxob3N0Jykge1xyXG4gICAgICAgIGZhdGFsKCdDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcnNlZFVybC5zZWN1cmUpIHtcclxuICAgICAgICB3YXJuSWZQYWdlSXNTZWN1cmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdlYlNvY2tldE9ubHkgPSBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3MnIHx8IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3c3MnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXBvSW5mbzogbmV3IFJlcG9JbmZvKHBhcnNlZFVybC5ob3N0LCBwYXJzZWRVcmwuc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiwgXHJcbiAgICAgICAgLypwZXJzaXN0ZW5jZUtleT0qLyAnJywgXHJcbiAgICAgICAgLyppbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcz0qLyBuYW1lc3BhY2UgIT09IHBhcnNlZFVybC5zdWJkb21haW4pLFxyXG4gICAgICAgIHBhdGg6IG5ldyBQYXRoKHBhcnNlZFVybC5wYXRoU3RyaW5nKVxyXG4gICAgfTtcclxufTtcclxuY29uc3QgcGFyc2VEYXRhYmFzZVVSTCA9IGZ1bmN0aW9uIChkYXRhVVJMKSB7XHJcbiAgICAvLyBEZWZhdWx0IHRvIGVtcHR5IHN0cmluZ3MgaW4gdGhlIGV2ZW50IG9mIGEgbWFsZm9ybWVkIHN0cmluZy5cclxuICAgIGxldCBob3N0ID0gJycsIGRvbWFpbiA9ICcnLCBzdWJkb21haW4gPSAnJywgcGF0aFN0cmluZyA9ICcnLCBuYW1lc3BhY2UgPSAnJztcclxuICAgIC8vIEFsd2F5cyBkZWZhdWx0IHRvIFNTTCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXHJcbiAgICBsZXQgc2VjdXJlID0gdHJ1ZSwgc2NoZW1lID0gJ2h0dHBzJywgcG9ydCA9IDQ0MztcclxuICAgIC8vIERvbid0IGRvIGFueSB2YWxpZGF0aW9uIGhlcmUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHJlc3VsdCBvZiBwYXJzaW5nLlxyXG4gICAgaWYgKHR5cGVvZiBkYXRhVVJMID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFBhcnNlIHNjaGVtZS5cclxuICAgICAgICBsZXQgY29sb25JbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8vJyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgY29sb25JbmQgLSAxKTtcclxuICAgICAgICAgICAgZGF0YVVSTCA9IGRhdGFVUkwuc3Vic3RyaW5nKGNvbG9uSW5kICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIGhvc3QsIHBhdGgsIGFuZCBxdWVyeSBzdHJpbmcuXHJcbiAgICAgICAgbGV0IHNsYXNoSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvJyk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICBzbGFzaEluZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgaWYgKHF1ZXN0aW9uTWFya0luZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3QgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBNYXRoLm1pbihzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kIDwgcXVlc3Rpb25NYXJrSW5kKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBwYXRoU3RyaW5nLCBxdWVzdGlvbk1hcmtJbmQgd2lsbCBhbHdheXMgY29tZSBhZnRlciBzbGFzaEluZFxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gZGVjb2RlUGF0aChkYXRhVVJMLnN1YnN0cmluZyhzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZGVjb2RlUXVlcnkoZGF0YVVSTC5zdWJzdHJpbmcoTWF0aC5taW4oZGF0YVVSTC5sZW5ndGgsIHF1ZXN0aW9uTWFya0luZCkpKTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydCwgdXNlIHNjaGVtZSBmb3IgZGV0ZXJtaW5pbmcgaWYgaXQncyBzZWN1cmUuXHJcbiAgICAgICAgY29sb25JbmQgPSBob3N0LmluZGV4T2YoJzonKTtcclxuICAgICAgICBpZiAoY29sb25JbmQgPj0gMCkge1xyXG4gICAgICAgICAgICBzZWN1cmUgPSBzY2hlbWUgPT09ICdodHRwcycgfHwgc2NoZW1lID09PSAnd3NzJztcclxuICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKGNvbG9uSW5kICsgMSksIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9uSW5kID0gaG9zdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RXaXRob3V0UG9ydCA9IGhvc3Quc2xpY2UoMCwgY29sb25JbmQpO1xyXG4gICAgICAgIGlmIChob3N0V2l0aG91dFBvcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gJ2xvY2FsaG9zdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvc3RXaXRob3V0UG9ydC5zcGxpdCgnLicpLmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IGhvc3RXaXRob3V0UG9ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEludGVycHJldCB0aGUgc3ViZG9tYWluIG9mIGEgMyBvciBtb3JlIGNvbXBvbmVudCBVUkwgYXMgdGhlIG5hbWVzcGFjZSBuYW1lLlxyXG4gICAgICAgICAgICBjb25zdCBkb3RJbmQgPSBob3N0LmluZGV4T2YoJy4nKTtcclxuICAgICAgICAgICAgc3ViZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoMCwgZG90SW5kKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0LnN1YnN0cmluZyhkb3RJbmQgKyAxKTtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5hbWVzcGFjZXMgdG8gbG93ZXJjYXNlIHRvIHNoYXJlIHN0b3JhZ2UgLyBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBzdWJkb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsd2F5cyB0cmVhdCB0aGUgdmFsdWUgb2YgdGhlIGBuc2AgYXMgdGhlIG5hbWVzcGFjZSBuYW1lIGlmIGl0IGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKCducycgaW4gcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gcXVlcnlQYXJhbXNbJ25zJ107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3N0LFxyXG4gICAgICAgIHBvcnQsXHJcbiAgICAgICAgZG9tYWluLFxyXG4gICAgICAgIHN1YmRvbWFpbixcclxuICAgICAgICBzZWN1cmUsXHJcbiAgICAgICAgc2NoZW1lLFxyXG4gICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgbmFtZXNwYWNlXHJcbiAgICB9O1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNb2RlbGVkIGFmdGVyIGJhc2U2NCB3ZWItc2FmZSBjaGFycywgYnV0IG9yZGVyZWQgYnkgQVNDSUkuXHJcbmNvbnN0IFBVU0hfQ0hBUlMgPSAnLTAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl9hYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcbi8qKlxyXG4gKiBGYW5jeSBJRCBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIDIwLWNoYXJhY3RlciBzdHJpbmcgaWRlbnRpZmllcnMgd2l0aCB0aGVcclxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqIDEuIFRoZXkncmUgYmFzZWQgb24gdGltZXN0YW1wIHNvIHRoYXQgdGhleSBzb3J0ICphZnRlciogYW55IGV4aXN0aW5nIGlkcy5cclxuICogMi4gVGhleSBjb250YWluIDcyLWJpdHMgb2YgcmFuZG9tIGRhdGEgYWZ0ZXIgdGhlIHRpbWVzdGFtcCBzbyB0aGF0IElEcyB3b24ndFxyXG4gKiAgICBjb2xsaWRlIHdpdGggb3RoZXIgY2xpZW50cycgSURzLlxyXG4gKiAzLiBUaGV5IHNvcnQgKmxleGljb2dyYXBoaWNhbGx5KiAoc28gdGhlIHRpbWVzdGFtcCBpcyBjb252ZXJ0ZWQgdG8gY2hhcmFjdGVyc1xyXG4gKiAgICB0aGF0IHdpbGwgc29ydCBwcm9wZXJseSkuXHJcbiAqIDQuIFRoZXkncmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLiBFdmVuIGlmIHlvdSBnZW5lcmF0ZSBtb3JlIHRoYW4gb25lIGluXHJcbiAqICAgIHRoZSBzYW1lIHRpbWVzdGFtcCwgdGhlIGxhdHRlciBvbmVzIHdpbGwgc29ydCBhZnRlciB0aGUgZm9ybWVyIG9uZXMuIFdlIGRvXHJcbiAqICAgIHRoaXMgYnkgdXNpbmcgdGhlIHByZXZpb3VzIHJhbmRvbSBiaXRzIGJ1dCBcImluY3JlbWVudGluZ1wiIHRoZW0gYnkgMSAob25seVxyXG4gKiAgICBpbiB0aGUgY2FzZSBvZiBhIHRpbWVzdGFtcCBjb2xsaXNpb24pLlxyXG4gKi9cclxuY29uc3QgbmV4dFB1c2hJZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgb2YgbGFzdCBwdXNoLCB1c2VkIHRvIHByZXZlbnQgbG9jYWwgY29sbGlzaW9ucyBpZiB5b3UgcHVzaCB0d2ljZVxyXG4gICAgLy8gaW4gb25lIG1zLlxyXG4gICAgbGV0IGxhc3RQdXNoVGltZSA9IDA7XHJcbiAgICAvLyBXZSBnZW5lcmF0ZSA3Mi1iaXRzIG9mIHJhbmRvbW5lc3Mgd2hpY2ggZ2V0IHR1cm5lZCBpbnRvIDEyIGNoYXJhY3RlcnMgYW5kXHJcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXHJcbiAgICAvLyBzdG9yZSB0aGUgbGFzdCBjaGFyYWN0ZXJzIHdlIGdlbmVyYXRlZCBiZWNhdXNlIGluIHRoZSBldmVudCBvZiBhIGNvbGxpc2lvbixcclxuICAgIC8vIHdlJ2xsIHVzZSB0aG9zZSBzYW1lIGNoYXJhY3RlcnMgZXhjZXB0IFwiaW5jcmVtZW50ZWRcIiBieSBvbmUuXHJcbiAgICBjb25zdCBsYXN0UmFuZENoYXJzID0gW107XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vdykge1xyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZVRpbWUgPSBub3cgPT09IGxhc3RQdXNoVGltZTtcclxuICAgICAgICBsYXN0UHVzaFRpbWUgPSBub3c7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wQ2hhcnMgPSBuZXcgQXJyYXkoOCk7XHJcbiAgICAgICAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGltZVN0YW1wQ2hhcnNbaV0gPSBQVVNIX0NIQVJTLmNoYXJBdChub3cgJSA2NCk7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbid0IHVzZSA8PCBoZXJlIGJlY2F1c2UgamF2YXNjcmlwdCB3aWxsIGNvbnZlcnQgdG8gaW50IGFuZCBsb3NlXHJcbiAgICAgICAgICAgIC8vIHRoZSB1cHBlciBiaXRzLlxyXG4gICAgICAgICAgICBub3cgPSBNYXRoLmZsb29yKG5vdyAvIDY0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KG5vdyA9PT0gMCwgJ0Nhbm5vdCBwdXNoIGF0IHRpbWUgPT0gMCcpO1xyXG4gICAgICAgIGxldCBpZCA9IHRpbWVTdGFtcENoYXJzLmpvaW4oJycpO1xyXG4gICAgICAgIGlmICghZHVwbGljYXRlVGltZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCBoYXNuJ3QgY2hhbmdlZCBzaW5jZSBsYXN0IHB1c2gsIHVzZSB0aGUgc2FtZSByYW5kb21cclxuICAgICAgICAgICAgLy8gbnVtYmVyLCBleGNlcHQgaW5jcmVtZW50ZWQgYnkgMS5cclxuICAgICAgICAgICAgZm9yIChpID0gMTE7IGkgPj0gMCAmJiBsYXN0UmFuZENoYXJzW2ldID09PSA2MzsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlkICs9IFBVU0hfQ0hBUlMuY2hhckF0KGxhc3RSYW5kQ2hhcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoaWQubGVuZ3RoID09PSAyMCwgJ25leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuJyk7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgZGF0YSBuZWVkZWQgdG8gcmFpc2UgYW4gZXZlbnRcclxuICovXHJcbmNsYXNzIERhdGFFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBPbmUgb2Y6IHZhbHVlLCBjaGlsZF9hZGRlZCwgY2hpbGRfY2hhbmdlZCwgY2hpbGRfbW92ZWQsIGNoaWxkX3JlbW92ZWRcclxuICAgICAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHdpdGggdGhlIGV2ZW50IGRhdGEuIFVzZXIgcHJvdmlkZWRcclxuICAgICAqIEBwYXJhbSBzbmFwc2hvdCAtIFRoZSBkYXRhIGJhY2tpbmcgdGhlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gcHJldk5hbWUgLSBPcHRpb25hbCwgdGhlIG5hbWUgb2YgdGhlIHByZXZpb3VzIGNoaWxkIGZvciBjaGlsZF8qIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnRUeXBlLCBldmVudFJlZ2lzdHJhdGlvbiwgc25hcHNob3QsIHByZXZOYW1lKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcclxuICAgICAgICB0aGlzLnByZXZOYW1lID0gcHJldk5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuc25hcHNob3QucmVmO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmLl9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5wYXJlbnQuX3BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50VHlwZTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFBhdGgoKS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFR5cGUgK1xyXG4gICAgICAgICAgICAnOicgK1xyXG4gICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5zbmFwc2hvdC5leHBvcnRWYWwoKSkpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENhbmNlbEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50UmVnaXN0cmF0aW9uLCBlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKSArICc6Y2FuY2VsJztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB3cmFwcGVyIGNsYXNzIHRoYXQgY29udmVydHMgZXZlbnRzIGZyb20gdGhlIGRhdGFiYXNlQGV4cCBTREsgdG8gdGhlIGxlZ2FjeVxyXG4gKiBEYXRhYmFzZSBTREsuIEV2ZW50cyBhcmUgbm90IGNvbnZlcnRlZCBkaXJlY3RseSBhcyBldmVudCByZWdpc3RyYXRpb24gcmVsaWVzXHJcbiAqIG9uIHJlZmVyZW5jZSBjb21wYXJpc29uIG9mIHRoZSBvcmlnaW5hbCB1c2VyIGNhbGxiYWNrIChzZWUgYG1hdGNoZXMoKWApIGFuZFxyXG4gKiByZWxpZXMgb24gZXF1YWxpdHkgb2YgdGhlIGxlZ2FjeSBTREsncyBgY29udGV4dGAgb2JqZWN0LlxyXG4gKi9cclxuY2xhc3MgQ2FsbGJhY2tDb250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKHNuYXBzaG90Q2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrID0gc25hcHNob3RDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvblZhbHVlKGV4cERhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpIHtcclxuICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY2FsbChudWxsLCBleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKTtcclxuICAgIH1cclxuICAgIG9uQ2FuY2VsKGVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGFzQ2FuY2VsQ2FsbGJhY2ssICdSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2snKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxDYWxsYmFjay5jYWxsKG51bGwsIGVycm9yKTtcclxuICAgIH1cclxuICAgIGdldCBoYXNDYW5jZWxDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zbmFwc2hvdENhbGxiYWNrID09PSBvdGhlci5zbmFwc2hvdENhbGxiYWNrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjay51c2VyQ2FsbGJhY2sgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuc25hcHNob3RDYWxsYmFjay51c2VyQ2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjay5jb250ZXh0ID09PSBvdGhlci5zbmFwc2hvdENhbGxiYWNrLmNvbnRleHQpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGBvbkRpc2Nvbm5lY3RgIGNsYXNzIGFsbG93cyB5b3UgdG8gd3JpdGUgb3IgY2xlYXIgZGF0YSB3aGVuIHlvdXIgY2xpZW50XHJcbiAqIGRpc2Nvbm5lY3RzIGZyb20gdGhlIERhdGFiYXNlIHNlcnZlci4gVGhlc2UgdXBkYXRlcyBvY2N1ciB3aGV0aGVyIHlvdXJcclxuICogY2xpZW50IGRpc2Nvbm5lY3RzIGNsZWFubHkgb3Igbm90LCBzbyB5b3UgY2FuIHJlbHkgb24gdGhlbSB0byBjbGVhbiB1cCBkYXRhXHJcbiAqIGV2ZW4gaWYgYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgb3IgYSBjbGllbnQgY3Jhc2hlcy5cclxuICpcclxuICogVGhlIGBvbkRpc2Nvbm5lY3RgIGNsYXNzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCB0byBtYW5hZ2UgcHJlc2VuY2UgaW5cclxuICogYXBwbGljYXRpb25zIHdoZXJlIGl0IGlzIHVzZWZ1bCB0byBkZXRlY3QgaG93IG1hbnkgY2xpZW50cyBhcmUgY29ubmVjdGVkIGFuZFxyXG4gKiB3aGVuIG90aGVyIGNsaWVudHMgZGlzY29ubmVjdC4gU2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogVG8gYXZvaWQgcHJvYmxlbXMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgZHJvcHBlZCBiZWZvcmUgdGhlIHJlcXVlc3RzIGNhbiBiZVxyXG4gKiB0cmFuc2ZlcnJlZCB0byB0aGUgRGF0YWJhc2Ugc2VydmVyLCB0aGVzZSBmdW5jdGlvbnMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmVcclxuICogd3JpdGluZyBhbnkgZGF0YS5cclxuICpcclxuICogTm90ZSB0aGF0IGBvbkRpc2Nvbm5lY3RgIG9wZXJhdGlvbnMgYXJlIG9ubHkgdHJpZ2dlcmVkIG9uY2UuIElmIHlvdSB3YW50IGFuXHJcbiAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAqIHRoZSBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGVhY2ggdGltZSB5b3UgcmVjb25uZWN0LlxyXG4gKi9cclxuY2xhc3MgT25EaXNjb25uZWN0IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVwbywgX3BhdGgpIHtcclxuICAgICAgICB0aGlzLl9yZXBvID0gX3JlcG87XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIGFsbCBwcmV2aW91c2x5IHF1ZXVlZCBgb25EaXNjb25uZWN0KClgIHNldCBvciB1cGRhdGUgZXZlbnRzIGZvciB0aGlzXHJcbiAgICAgKiBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkcmVuLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgd3JpdGUgaGFzIGJlZW4gcXVldWVkIGZvciB0aGlzIGxvY2F0aW9uIHZpYSBhIGBzZXQoKWAgb3IgYHVwZGF0ZSgpYCBhdCBhXHJcbiAgICAgKiBwYXJlbnQgbG9jYXRpb24sIHRoZSB3cml0ZSBhdCB0aGlzIGxvY2F0aW9uIHdpbGwgYmUgY2FuY2VsZWQsIHRob3VnaCB3cml0ZXNcclxuICAgICAqIHRvIHNpYmxpbmcgbG9jYXRpb25zIHdpbGwgc3RpbGwgb2NjdXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdENhbmNlbCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBkZWxldGVkIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWRcclxuICAgICAqIChkdWUgdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKCkge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGlzIHNldCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoZW4gdGhlXHJcbiAgICAgKiBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWUgdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLFxyXG4gICAgICogb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIGBzZXQoKWAgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGltcGxlbWVudGluZyBcInByZXNlbmNlXCIgc3lzdGVtcywgd2hlcmUgYVxyXG4gICAgICogdmFsdWUgc2hvdWxkIGJlIGNoYW5nZWQgb3IgY2xlYXJlZCB3aGVuIGEgdXNlciBkaXNjb25uZWN0cyBzbyB0aGF0IHRoZXlcclxuICAgICAqIGFwcGVhciBcIm9mZmxpbmVcIiB0byBvdGhlciB1c2Vycy4gU2VlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gICAgICogb3BlcmF0aW9uIHRvIG9jY3VyIGVhY2ggdGltZSBhIGRpc2Nvbm5lY3Qgb2NjdXJzLCB5b3UnbGwgbmVlZCB0byByZS1lc3RhYmxpc2hcclxuICAgICAqIHRoZSBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGVhY2ggdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiB0byB0aGlzIGxvY2F0aW9uIG9uIGRpc2Nvbm5lY3QgKGNhblxyXG4gICAgICogYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwpLlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIERhdGFiYXNlIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBzZXQodmFsdWUpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldCcsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXQodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGlzIHNldCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBwcmlvcml0eVxyXG4gICAgICogd2hlbiB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYVxyXG4gICAgICogbmV3IHBhZ2UsIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiB0byB0aGlzIGxvY2F0aW9uIG9uIGRpc2Nvbm5lY3QgKGNhblxyXG4gICAgICogYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwpLlxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0V2l0aFByaW9yaXR5KHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCB2YWx1ZSwgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIG11bHRpcGxlIHZhbHVlcyBhdCB0aGlzIGxvY2F0aW9uIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZVxyXG4gICAgICogdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGB2YWx1ZXNgIGFyZ3VtZW50IGNvbnRhaW5zIG11bHRpcGxlIHByb3BlcnR5LXZhbHVlIHBhaXJzIHRoYXQgd2lsbCBiZVxyXG4gICAgICogd3JpdHRlbiB0byB0aGUgRGF0YWJhc2UgdG9nZXRoZXIuIEVhY2ggY2hpbGQgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxyXG4gICAgICogcHJvcGVydHkgKGZvciBleGFtcGxlLCBcIm5hbWVcIikgb3IgYSByZWxhdGl2ZSBwYXRoIChmb3IgZXhhbXBsZSwgXCJuYW1lL2ZpcnN0XCIpXHJcbiAgICAgKiBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIHRoZSBkYXRhIHRvIHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBBcyBvcHBvc2VkIHRvIHRoZSBgc2V0KClgIG1ldGhvZCwgYHVwZGF0ZSgpYCBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5IHVwZGF0ZVxyXG4gICAgICogb25seSB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIHJlcGxhY2luZ1xyXG4gICAgICogYWxsIHRoZSBjaGlsZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIERhdGFiYXNlIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUodmFsdWVzKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC51cGRhdGUnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdmFsdWVzLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0VXBkYXRlKHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlcywgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFF1ZXJ5SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoLCBfcXVlcnlQYXJhbXMsIF9vcmRlckJ5Q2FsbGVkKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICB0aGlzLl9xdWVyeVBhcmFtcyA9IF9xdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLl9vcmRlckJ5Q2FsbGVkID0gX29yZGVyQnlDYWxsZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLl9wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoR2V0QmFjayh0aGlzLl9wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoKTtcclxuICAgIH1cclxuICAgIGdldCBfcXVlcnlJZGVudGlmaWVyKCkge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IGlkID0gT2JqZWN0VG9VbmlxdWVLZXkob2JqKTtcclxuICAgICAgICByZXR1cm4gaWQgPT09ICd7fScgPyAnZGVmYXVsdCcgOiBpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBRdWVyeS5cclxuICAgICAqL1xyXG4gICAgZ2V0IF9xdWVyeU9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gcXVlcnlQYXJhbXNHZXRRdWVyeU9iamVjdCh0aGlzLl9xdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgb3RoZXIgPSBnZXRNb2R1bGFySW5zdGFuY2Uob3RoZXIpO1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUXVlcnlJbXBsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNhbWVSZXBvID0gdGhpcy5fcmVwbyA9PT0gb3RoZXIuX3JlcG87XHJcbiAgICAgICAgY29uc3Qgc2FtZVBhdGggPSBwYXRoRXF1YWxzKHRoaXMuX3BhdGgsIG90aGVyLl9wYXRoKTtcclxuICAgICAgICBjb25zdCBzYW1lUXVlcnlJZGVudGlmaWVyID0gdGhpcy5fcXVlcnlJZGVudGlmaWVyID09PSBvdGhlci5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHJldHVybiBzYW1lUmVwbyAmJiBzYW1lUGF0aCAmJiBzYW1lUXVlcnlJZGVudGlmaWVyO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwby50b1N0cmluZygpICsgcGF0aFRvVXJsRW5jb2RlZFN0cmluZyh0aGlzLl9wYXRoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbm8gb3RoZXIgb3JkZXIgYnkgY2FsbCBoYXMgYmVlbiBtYWRlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgZm5OYW1lKSB7XHJcbiAgICBpZiAocXVlcnkuX29yZGVyQnlDYWxsZWQgPT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgc3RhcnQvZW5kIHZhbHVlcyBmb3IgcXVlcmllcy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMocGFyYW1zKSB7XHJcbiAgICBsZXQgc3RhcnROb2RlID0gbnVsbDtcclxuICAgIGxldCBlbmROb2RlID0gbnVsbDtcclxuICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgIHN0YXJ0Tm9kZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICBlbmROb2RlID0gcGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgY29uc3QgdG9vTWFueUFyZ3NFcnJvciA9ICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLic7XHJcbiAgICAgICAgY29uc3Qgd3JvbmdBcmdUeXBlRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgc3RhcnRBZnRlcigpLCAnICtcclxuICAgICAgICAgICAgJ2VuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy4nO1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0TmFtZSAhPT0gTUlOX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnROb2RlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmROYW1lICE9PSBNQVhfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbmROb2RlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBQUklPUklUWV9JTkRFWCkge1xyXG4gICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgIWlzVmFsaWRQcmlvcml0eShzdGFydE5vZGUpKSB8fFxyXG4gICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoZW5kTm9kZSkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEFmdGVyKCkgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgJyArXHJcbiAgICAgICAgICAgICAgICAnKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHBhcmFtcy5nZXRJbmRleCgpIGluc3RhbmNlb2YgUGF0aEluZGV4IHx8XHJcbiAgICAgICAgICAgIHBhcmFtcy5nZXRJbmRleCgpID09PSBWQUxVRV9JTkRFWCwgJ3Vua25vd24gaW5kZXggdHlwZS4nKTtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmIHR5cGVvZiBzdGFydE5vZGUgPT09ICdvYmplY3QnKSB8fFxyXG4gICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmIHR5cGVvZiBlbmROb2RlID09PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgc3RhcnRBZnRlcigpLCBlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbygpIGNhbm5vdCBiZSBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCBsaW1pdCogaGFzIGJlZW4gY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgY29tYmluYXRpb24gb2YgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVMaW1pdChwYXJhbXMpIHtcclxuICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSAmJlxyXG4gICAgICAgIHBhcmFtcy5oYXNFbmQoKSAmJlxyXG4gICAgICAgIHBhcmFtcy5oYXNMaW1pdCgpICYmXHJcbiAgICAgICAgIXBhcmFtcy5oYXNBbmNob3JlZExpbWl0KCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIGFuZCBsaW1pdCgpLiBVc2UgXCIgK1xyXG4gICAgICAgICAgICAnbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlZmVyZW5jZUltcGwgZXh0ZW5kcyBRdWVyeUltcGwge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG8sIHBhdGgpIHtcclxuICAgICAgICBzdXBlcihyZXBvLCBwYXRoLCBuZXcgUXVlcnlQYXJhbXMoKSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aFBhcmVudCh0aGlzLl9wYXRoKTtcclxuICAgICAgICByZXR1cm4gcGFyZW50UGF0aCA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgOiBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBwYXJlbnRQYXRoKTtcclxuICAgIH1cclxuICAgIGdldCByb290KCkge1xyXG4gICAgICAgIGxldCByZWYgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZWYucGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlZiA9IHJlZi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWY7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYERhdGFTbmFwc2hvdGAgY29udGFpbnMgZGF0YSBmcm9tIGEgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFueSB0aW1lIHlvdSByZWFkIGRhdGEgZnJvbSB0aGUgRGF0YWJhc2UsIHlvdSByZWNlaXZlIHRoZSBkYXRhIGFzIGFcclxuICogYERhdGFTbmFwc2hvdGAuIEEgYERhdGFTbmFwc2hvdGAgaXMgcGFzc2VkIHRvIHRoZSBldmVudCBjYWxsYmFja3MgeW91IGF0dGFjaFxyXG4gKiB3aXRoIGBvbigpYCBvciBgb25jZSgpYC4gWW91IGNhbiBleHRyYWN0IHRoZSBjb250ZW50cyBvZiB0aGUgc25hcHNob3QgYXMgYVxyXG4gKiBKYXZhU2NyaXB0IG9iamVjdCBieSBjYWxsaW5nIHRoZSBgdmFsKClgIG1ldGhvZC4gQWx0ZXJuYXRpdmVseSwgeW91IGNhblxyXG4gKiB0cmF2ZXJzZSBpbnRvIHRoZSBzbmFwc2hvdCBieSBjYWxsaW5nIGBjaGlsZCgpYCB0byByZXR1cm4gY2hpbGQgc25hcHNob3RzXHJcbiAqICh3aGljaCB5b3UgY291bGQgdGhlbiBjYWxsIGB2YWwoKWAgb24pLlxyXG4gKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGlzIGFuIGVmZmljaWVudGx5IGdlbmVyYXRlZCwgaW1tdXRhYmxlIGNvcHkgb2YgdGhlIGRhdGEgYXRcclxuICogYSBEYXRhYmFzZSBsb2NhdGlvbi4gSXQgY2Fubm90IGJlIG1vZGlmaWVkIGFuZCB3aWxsIG5ldmVyIGNoYW5nZSAodG8gbW9kaWZ5XHJcbiAqIGRhdGEsIHlvdSBhbHdheXMgY2FsbCB0aGUgYHNldCgpYCBtZXRob2Qgb24gYSBgUmVmZXJlbmNlYCBkaXJlY3RseSkuXHJcbiAqL1xyXG5jbGFzcyBEYXRhU25hcHNob3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gX25vZGUgLSBBIFNuYXBzaG90Tm9kZSB0byB3cmFwLlxyXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90IGNhbWUgZnJvbS5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggLSBUaGUgaXRlcmF0aW9uIG9yZGVyIGZvciB0aGlzIHNuYXBzaG90XHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9ub2RlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvY2F0aW9uIG9mIHRoaXMgRGF0YVNuYXBzaG90LlxyXG4gICAgICovXHJcbiAgICByZWYsIF9pbmRleCkge1xyXG4gICAgICAgIHRoaXMuX25vZGUgPSBfbm9kZTtcclxuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IF9pbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcHJpb3JpdHkgdmFsdWUgb2YgdGhlIGRhdGEgaW4gdGhpcyBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICAgICAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHxTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICAgICAqICkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcmlvcml0eSgpIHtcclxuICAgICAgICAvLyB0eXBlY2FzdCBoZXJlIGJlY2F1c2Ugd2UgbmV2ZXIgcmV0dXJuIGRlZmVycmVkIHZhbHVlcyBvciBpbnRlcm5hbCBwcmlvcml0aWVzIChNQVhfUFJJT1JJVFkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGtleSAobGFzdCBwYXJ0IG9mIHRoZSBwYXRoKSBvZiB0aGUgbG9jYXRpb24gb2YgdGhpcyBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbGFzdCB0b2tlbiBpbiBhIERhdGFiYXNlIGxvY2F0aW9uIGlzIGNvbnNpZGVyZWQgaXRzIGtleS4gRm9yIGV4YW1wbGUsXHJcbiAgICAgKiBcImFkYVwiIGlzIHRoZSBrZXkgZm9yIHRoZSAvdXNlcnMvYWRhLyBub2RlLiBBY2Nlc3NpbmcgdGhlIGtleSBvbiBhbnlcclxuICAgICAqIGBEYXRhU25hcHNob3RgIHdpbGwgcmV0dXJuIHRoZSBrZXkgZm9yIHRoZSBsb2NhdGlvbiB0aGF0IGdlbmVyYXRlZCBpdC5cclxuICAgICAqIEhvd2V2ZXIsIGFjY2Vzc2luZyB0aGUga2V5IG9uIHRoZSByb290IFVSTCBvZiBhIERhdGFiYXNlIHdpbGwgcmV0dXJuXHJcbiAgICAgKiBgbnVsbGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLmtleTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGQgcHJvcGVydGllcyBvZiB0aGlzIGBEYXRhU25hcHNob3RgLiAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIFBhc3NpbmcgYSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBgY2hpbGQoKWAgbWV0aG9kIG9mIGEgRGF0YVNuYXBzaG90IHJldHVybnNcclxuICAgICAqIGFub3RoZXIgYERhdGFTbmFwc2hvdGAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguIFRoZVxyXG4gICAgICogcmVsYXRpdmUgcGF0aCBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGNoaWxkIG5hbWUgKGZvciBleGFtcGxlLCBcImFkYVwiKSBvciBhXHJcbiAgICAgKiBkZWVwZXIsIHNsYXNoLXNlcGFyYXRlZCBwYXRoIChmb3IgZXhhbXBsZSwgXCJhZGEvbmFtZS9maXJzdFwiKS4gSWYgdGhlIGNoaWxkXHJcbiAgICAgKiBsb2NhdGlvbiBoYXMgbm8gZGF0YSwgYW4gZW1wdHkgYERhdGFTbmFwc2hvdGAgKHRoYXQgaXMsIGEgYERhdGFTbmFwc2hvdGBcclxuICAgICAqIHdob3NlIHZhbHVlIGlzIGBudWxsYCkgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIGNoaWxkIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBuZXcgUGF0aChwYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZFJlZiA9IGNoaWxkKHRoaXMucmVmLCBwYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFTbmFwc2hvdCh0aGlzLl9ub2RlLmdldENoaWxkKGNoaWxkUGF0aCksIGNoaWxkUmVmLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGFueSBkYXRhLiBJdCBpcyBzbGlnaHRseSBtb3JlXHJcbiAgICAgKiBlZmZpY2llbnQgdGhhbiB1c2luZyBgc25hcHNob3QudmFsKCkgIT09IG51bGxgLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBEYXRhU25hcHNob3QgYXMgYSBKYXZhU2NyaXB0IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYGV4cG9ydFZhbCgpYCBtZXRob2QgaXMgc2ltaWxhciB0byBgdmFsKClgLCBleGNlcHQgcHJpb3JpdHkgaW5mb3JtYXRpb25cclxuICAgICAqIGlzIGluY2x1ZGVkIChpZiBhdmFpbGFibGUpLCBtYWtpbmcgaXQgc3VpdGFibGUgZm9yIGJhY2tpbmcgdXAgeW91ciBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBEYXRhU25hcHNob3QncyBjb250ZW50cyBhcyBhIEphdmFTY3JpcHQgdmFsdWUgKE9iamVjdCxcclxuICAgICAqICAgQXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBgbnVsbGApLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZXhwb3J0VmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLnZhbCh0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRlcyB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGluIHRoZSBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSB3YXkgSmF2YVNjcmlwdCBvYmplY3RzIHdvcmssIHRoZSBvcmRlcmluZyBvZiBkYXRhIGluIHRoZVxyXG4gICAgICogSmF2YVNjcmlwdCBvYmplY3QgcmV0dXJuZWQgYnkgYHZhbCgpYCBpcyBub3QgZ3VhcmFudGVlZCB0byBtYXRjaCB0aGVcclxuICAgICAqIG9yZGVyaW5nIG9uIHRoZSBzZXJ2ZXIgbm9yIHRoZSBvcmRlcmluZyBvZiBgb25DaGlsZEFkZGVkKClgIGV2ZW50cy4gVGhhdCBpc1xyXG4gICAgICogd2hlcmUgYGZvckVhY2goKWAgY29tZXMgaW4gaGFuZHkuIEl0IGd1YXJhbnRlZXMgdGhlIGNoaWxkcmVuIG9mIGFcclxuICAgICAqIGBEYXRhU25hcHNob3RgIHdpbGwgYmUgaXRlcmF0ZWQgaW4gdGhlaXIgcXVlcnkgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gZXhwbGljaXQgYG9yZGVyQnkqKClgIG1ldGhvZCBpcyB1c2VkLCByZXN1bHRzIGFyZSByZXR1cm5lZFxyXG4gICAgICogb3JkZXJlZCBieSBrZXkgKHVubGVzcyBwcmlvcml0aWVzIGFyZSB1c2VkLCBpbiB3aGljaCBjYXNlLCByZXN1bHRzIGFyZVxyXG4gICAgICogcmV0dXJuZWQgYnkgcHJpb3JpdHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQgRGF0YVNuYXBzaG90LlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gdHJ1ZSB0byBjYW5jZWwgZnVydGhlciBlbnVtZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZW51bWVyYXRpb24gd2FzIGNhbmNlbGVkIGR1ZSB0byB5b3VyIGNhbGxiYWNrIHJldHVybmluZ1xyXG4gICAgICogdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChhY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZHJlbk5vZGUgPSB0aGlzLl9ub2RlO1xyXG4gICAgICAgIC8vIFNhbml0aXplIHRoZSByZXR1cm4gdmFsdWUgdG8gYSBib29sZWFuLiBDaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkIGhhcyBhIHdlaXJkIHJldHVybiB0eXBlLi4uXHJcbiAgICAgICAgcmV0dXJuICEhY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCh0aGlzLl9pbmRleCwgKGtleSwgbm9kZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uKG5ldyBEYXRhU25hcHNob3Qobm9kZSwgY2hpbGQodGhpcy5yZWYsIGtleSksIFBSSU9SSVRZX0lOREVYKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNoaWxkIHBhdGggaGFzIChub24tbnVsbCkgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCB0byB0aGUgbG9jYXRpb24gb2YgYSBwb3RlbnRpYWwgY2hpbGQuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZGF0YSBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBjaGlsZCBwYXRoOyBlbHNlXHJcbiAgICAgKiAgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgaGFzQ2hpbGQocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IG5ldyBQYXRoKHBhdGgpO1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYERhdGFTbmFwc2hvdGAgaGFzIGFueSBub24tYG51bGxgIGNoaWxkXHJcbiAgICAgKiBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gdXNlIGBoYXNDaGlsZHJlbigpYCB0byBkZXRlcm1pbmUgaWYgYSBgRGF0YVNuYXBzaG90YCBoYXMgYW55XHJcbiAgICAgKiBjaGlsZHJlbi4gSWYgaXQgZG9lcywgeW91IGNhbiBlbnVtZXJhdGUgdGhlbSB1c2luZyBgZm9yRWFjaCgpYC4gSWYgaXRcclxuICAgICAqIGRvZXNuJ3QsIHRoZW4gZWl0aGVyIHRoaXMgc25hcHNob3QgY29udGFpbnMgYSBwcmltaXRpdmUgdmFsdWUgKHdoaWNoIGNhbiBiZVxyXG4gICAgICogcmV0cmlldmVkIHdpdGggYHZhbCgpYCkgb3IgaXQgaXMgZW1wdHkgKGluIHdoaWNoIGNhc2UsIGB2YWwoKWAgd2lsbCByZXR1cm5cclxuICAgICAqIGBudWxsYCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHNuYXBzaG90IGhhcyBhbnkgY2hpbGRyZW47IGVsc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkcmVuKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuaXNFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIGEgSmF2YVNjcmlwdCB2YWx1ZSBmcm9tIGEgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBkYXRhIGluIGEgYERhdGFTbmFwc2hvdGAsIHRoZSBgdmFsKClgIG1ldGhvZCBtYXkgcmV0dXJuIGFcclxuICAgICAqIHNjYWxhciB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiksIGFuIGFycmF5LCBvciBhbiBvYmplY3QuIEl0IG1heVxyXG4gICAgICogYWxzbyByZXR1cm4gbnVsbCwgaW5kaWNhdGluZyB0aGF0IHRoZSBgRGF0YVNuYXBzaG90YCBpcyBlbXB0eSAoY29udGFpbnMgbm9cclxuICAgICAqIGRhdGEpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBEYXRhU25hcHNob3QncyBjb250ZW50cyBhcyBhIEphdmFTY3JpcHQgdmFsdWUgKE9iamVjdCxcclxuICAgICAqICAgQXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBgbnVsbGApLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgdmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLnZhbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBSZXR1cm5zIGEgYFJlZmVyZW5jZWAgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgRGF0YWJhc2VcclxuICogY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgcGF0aC4gSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwgdGhlIGBSZWZlcmVuY2VgXHJcbiAqIHdpbGwgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgZGF0YWJhc2UgaW5zdGFuY2UgdG8gb2J0YWluIGEgcmVmZXJlbmNlIGZvci5cclxuICogQHBhcmFtIHBhdGggLSBPcHRpb25hbCBwYXRoIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gdGhlIHJldHVybmVkXHJcbiAqICAgYFJlZmVyZW5jZWAgd2lsbCBwb2ludC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAgd2lsbFxyXG4gKiAgIHBvaW50IHRvIHRoZSByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICogQHJldHVybnMgSWYgYSBwYXRoIGlzIHByb3ZpZGVkLCBhIGBSZWZlcmVuY2VgXHJcbiAqICAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkIHBhdGguIE90aGVyd2lzZSwgYSBgUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGVcclxuICogICByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZihkYiwgcGF0aCkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgncmVmJyk7XHJcbiAgICByZXR1cm4gcGF0aCAhPT0gdW5kZWZpbmVkID8gY2hpbGQoZGIuX3Jvb3QsIHBhdGgpIDogZGIuX3Jvb3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBgUmVmZXJlbmNlYCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBEYXRhYmFzZVxyXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBGaXJlYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIFVSTCBpcyBub3QgYSB2YWxpZCBGaXJlYmFzZSBEYXRhYmFzZSBVUkwgb3IgaXRcclxuICogaGFzIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGBEYXRhYmFzZWAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBhbGwgcXVlcnkgcGFyYW1ldGVycyAoYG9yZGVyQnlgLCBgbGltaXRUb0xhc3RgLCBldGMuKSBhcmUgaWdub3JlZFxyXG4gKiBhbmQgYXJlIG5vdCBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYC5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGRhdGFiYXNlIGluc3RhbmNlIHRvIG9idGFpbiBhIHJlZmVyZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSB1cmwgLSBUaGUgRmlyZWJhc2UgVVJMIGF0IHdoaWNoIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYCB3aWxsXHJcbiAqICAgcG9pbnQuXHJcbiAqIEByZXR1cm5zIEEgYFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkXHJcbiAqICAgRmlyZWJhc2UgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmRnJvbVVSTChkYiwgdXJsKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdyZWZGcm9tVVJMJyk7XHJcbiAgICBjb25zdCBwYXJzZWRVUkwgPSBwYXJzZVJlcG9JbmZvKHVybCwgZGIuX3JlcG8ucmVwb0luZm9fLm5vZGVBZG1pbik7XHJcbiAgICB2YWxpZGF0ZVVybCgncmVmRnJvbVVSTCcsIHBhcnNlZFVSTCk7XHJcbiAgICBjb25zdCByZXBvSW5mbyA9IHBhcnNlZFVSTC5yZXBvSW5mbztcclxuICAgIGlmICghZGIuX3JlcG8ucmVwb0luZm9fLmlzQ3VzdG9tSG9zdCgpICYmXHJcbiAgICAgICAgcmVwb0luZm8uaG9zdCAhPT0gZGIuX3JlcG8ucmVwb0luZm9fLmhvc3QpIHtcclxuICAgICAgICBmYXRhbCgncmVmRnJvbVVSTCcgK1xyXG4gICAgICAgICAgICAnOiBIb3N0IG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgZGF0YWJhc2U6ICcgK1xyXG4gICAgICAgICAgICAnKGZvdW5kICcgK1xyXG4gICAgICAgICAgICByZXBvSW5mby5ob3N0ICtcclxuICAgICAgICAgICAgJyBidXQgZXhwZWN0ZWQgJyArXHJcbiAgICAgICAgICAgIGRiLl9yZXBvLnJlcG9JbmZvXy5ob3N0ICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWYoZGIsIHBhcnNlZFVSTC5wYXRoLnRvU3RyaW5nKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIGEgYFJlZmVyZW5jZWAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguXHJcbiAqXHJcbiAqIFRoZSByZWxhdGl2ZSBwYXRoIGNhbiBlaXRoZXIgYmUgYSBzaW1wbGUgY2hpbGQgbmFtZSAoZm9yIGV4YW1wbGUsIFwiYWRhXCIpIG9yXHJcbiAqIGEgZGVlcGVyIHNsYXNoLXNlcGFyYXRlZCBwYXRoIChmb3IgZXhhbXBsZSwgXCJhZGEvbmFtZS9maXJzdFwiKS5cclxuICpcclxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgbG9jYXRpb24uXHJcbiAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIGZyb20gdGhpcyBsb2NhdGlvbiB0byB0aGUgZGVzaXJlZCBjaGlsZFxyXG4gKiAgIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBUaGUgc3BlY2lmaWVkIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hpbGQocGFyZW50LCBwYXRoKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGFyZW50Ll9wYXRoKSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwocGFyZW50Ll9yZXBvLCBwYXRoQ2hpbGQocGFyZW50Ll9wYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYE9uRGlzY29ubmVjdGAgb2JqZWN0IC0gc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gdXNlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIHJlZmVyZW5jZSB0byBhZGQgT25EaXNjb25uZWN0IHRyaWdnZXJzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIG9uRGlzY29ubmVjdChyZWYpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIG5ldyBPbkRpc2Nvbm5lY3QocmVmLl9yZXBvLCByZWYuX3BhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgY2hpbGQgbG9jYXRpb24gdXNpbmcgYSB1bmlxdWUga2V5IGFuZCByZXR1cm5zIGl0c1xyXG4gKiBgUmVmZXJlbmNlYC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gcGF0dGVybiBmb3IgYWRkaW5nIGRhdGEgdG8gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLlxyXG4gKlxyXG4gKiBJZiB5b3UgcHJvdmlkZSBhIHZhbHVlIHRvIGBwdXNoKClgLCB0aGUgdmFsdWUgaXMgd3JpdHRlbiB0byB0aGVcclxuICogZ2VuZXJhdGVkIGxvY2F0aW9uLiBJZiB5b3UgZG9uJ3QgcGFzcyBhIHZhbHVlLCBub3RoaW5nIGlzIHdyaXR0ZW4gdG8gdGhlXHJcbiAqIGRhdGFiYXNlIGFuZCB0aGUgY2hpbGQgcmVtYWlucyBlbXB0eSAoYnV0IHlvdSBjYW4gdXNlIHRoZSBgUmVmZXJlbmNlYFxyXG4gKiBlbHNld2hlcmUpLlxyXG4gKlxyXG4gKiBUaGUgdW5pcXVlIGtleXMgZ2VuZXJhdGVkIGJ5IGBwdXNoKClgIGFyZSBvcmRlcmVkIGJ5IHRoZSBjdXJyZW50IHRpbWUsIHNvIHRoZVxyXG4gKiByZXN1bHRpbmcgbGlzdCBvZiBpdGVtcyBpcyBjaHJvbm9sb2dpY2FsbHkgc29ydGVkLiBUaGUga2V5cyBhcmUgYWxzb1xyXG4gKiBkZXNpZ25lZCB0byBiZSB1bmd1ZXNzYWJsZSAodGhleSBjb250YWluIDcyIHJhbmRvbSBiaXRzIG9mIGVudHJvcHkpLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2FwcGVuZF90b19hX2xpc3Rfb2ZfZGF0YSB8IEFwcGVuZCB0byBhIGxpc3Qgb2YgZGF0YX0uXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGVibG9nLmNvbS8yMDE1LzAyL3RoZS0yMTIwLXdheXMtdG8tZW5zdXJlLXVuaXF1ZV82OC5odG1sIHwgVGhlIDJeMTIwIFdheXMgdG8gRW5zdXJlIFVuaXF1ZSBJZGVudGlmaWVyc30uXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IGxvY2F0aW9uLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBPcHRpb25hbCB2YWx1ZSB0byBiZSB3cml0dGVuIGF0IHRoZSBnZW5lcmF0ZWQgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIENvbWJpbmVkIGBQcm9taXNlYCBhbmQgYFJlZmVyZW5jZWA7IHJlc29sdmVzIHdoZW4gd3JpdGUgaXMgY29tcGxldGUsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCBpbW1lZGlhdGVseSBhcyB0aGUgYFJlZmVyZW5jZWAgdG8gdGhlIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaChwYXJlbnQsIHZhbHVlKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdwdXNoJywgcGFyZW50Ll9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdwdXNoJywgdmFsdWUsIHBhcmVudC5fcGF0aCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBub3cgPSByZXBvU2VydmVyVGltZShwYXJlbnQuX3JlcG8pO1xyXG4gICAgY29uc3QgbmFtZSA9IG5leHRQdXNoSWQobm93KTtcclxuICAgIC8vIHB1c2goKSByZXR1cm5zIGEgVGhlbm5hYmxlUmVmZXJlbmNlIHdob3NlIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYVxyXG4gICAgLy8gcmVndWxhciBSZWZlcmVuY2UuIFdlIHVzZSBjaGlsZCgpIHRvIGNyZWF0ZSBoYW5kbGVzIHRvIHR3byBkaWZmZXJlbnRcclxuICAgIC8vIHJlZmVyZW5jZXMuIFRoZSBmaXJzdCBpcyB0dXJuZWQgaW50byBhIFRoZW5uYWJsZVJlZmVyZW5jZSBiZWxvdyBieSBhZGRpbmdcclxuICAgIC8vIHRoZW4oKSBhbmQgY2F0Y2goKSBtZXRob2RzIGFuZCBpcyB1c2VkIGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgcHVzaCgpLiBUaGVcclxuICAgIC8vIHNlY29uZCByZW1haW5zIGEgcmVndWxhciBSZWZlcmVuY2UgYW5kIGlzIHVzZWQgYXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZlxyXG4gICAgLy8gdGhlIGZpcnN0IFRoZW5uYWJsZVJlZmVyZW5jZS5cclxuICAgIGNvbnN0IHRoZW5uYWJsZVB1c2hSZWYgPSBjaGlsZChwYXJlbnQsIG5hbWUpO1xyXG4gICAgY29uc3QgcHVzaFJlZiA9IGNoaWxkKHBhcmVudCwgbmFtZSk7XHJcbiAgICBsZXQgcHJvbWlzZTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHNldChwdXNoUmVmLCB2YWx1ZSkudGhlbigoKSA9PiBwdXNoUmVmKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHVzaFJlZik7XHJcbiAgICB9XHJcbiAgICB0aGVubmFibGVQdXNoUmVmLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcclxuICAgIHRoZW5uYWJsZVB1c2hSZWYuY2F0Y2ggPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlLCB1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHRoZW5uYWJsZVB1c2hSZWY7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGRhdGEgYXQgdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogQW55IGRhdGEgYXQgY2hpbGQgbG9jYXRpb25zIHdpbGwgYWxzbyBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSByZW1vdmUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5IGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudCAndmFsdWUnIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2YgdGhlIHJlbW92ZSB0byB0aGVcclxuICogRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZCBQcm9taXNlIHdpbGwgcmVzb2x2ZVxyXG4gKiB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIG9uQ29tcGxldGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcclxuICogYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gcmVtb3ZlIG9uIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZShyZWYpIHtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdyZW1vdmUnLCByZWYuX3BhdGgpO1xyXG4gICAgcmV0dXJuIHNldChyZWYsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgZGF0YSB0byB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYW5kIGFsbCBjaGlsZCBsb2NhdGlvbnMuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHdyaXRlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSwgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50cyAoXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIGV0Yy4pIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2ZcclxuICogdGhlIGRhdGEgdG8gdGhlIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWRcclxuICogUHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2tcclxuICogd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogUGFzc2luZyBgbnVsbGAgZm9yIHRoZSBuZXcgdmFsdWUgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGByZW1vdmUoKWA7IG5hbWVseSxcclxuICogYWxsIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkIGxvY2F0aW9ucyB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAqXHJcbiAqIGBzZXQoKWAgd2lsbCByZW1vdmUgYW55IHByaW9yaXR5IHN0b3JlZCBhdCB0aGlzIGxvY2F0aW9uLCBzbyBpZiBwcmlvcml0eSBpc1xyXG4gKiBtZWFudCB0byBiZSBwcmVzZXJ2ZWQsIHlvdSBuZWVkIHRvIHVzZSBgc2V0V2l0aFByaW9yaXR5KClgIGluc3RlYWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBtb2RpZnlpbmcgZGF0YSB3aXRoIGBzZXQoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNhY3Rpb25zXHJcbiAqIGF0IHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nIGBzZXQoKWAgYW5kXHJcbiAqIGB0cmFuc2FjdGlvbigpYCB0byBtb2RpZnkgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogQSBzaW5nbGUgYHNldCgpYCB3aWxsIGdlbmVyYXRlIGEgc2luZ2xlIFwidmFsdWVcIiBldmVudCBhdCB0aGUgbG9jYXRpb24gd2hlcmVcclxuICogdGhlIGBzZXQoKWAgd2FzIHBlcmZvcm1lZC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsXHJcbiAqICAgYXJyYXksIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldChyZWYsIHZhbHVlKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXQnLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3NldCcsIHZhbHVlLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZSwgXHJcbiAgICAvKnByaW9yaXR5PSovIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGEgcHJpb3JpdHkgZm9yIHRoZSBkYXRhIGF0IHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHwgU29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAqICkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UHJpb3JpdHkocmVmLCBwcmlvcml0eSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0UHJpb3JpdHknLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVQcmlvcml0eSgnc2V0UHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCBwYXRoQ2hpbGQocmVmLl9wYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5LCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIGRhdGEgdGhlIERhdGFiYXNlIGxvY2F0aW9uLiBMaWtlIGBzZXQoKWAgYnV0IGFsc28gc3BlY2lmaWVzIHRoZVxyXG4gKiBwcmlvcml0eSBmb3IgdGhhdCBkYXRhLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8IFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gKiApLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCxcclxuICogICBhcnJheSwgb3IgbnVsbCkuXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0V2l0aFByaW9yaXR5KHJlZiwgdmFsdWUsIHByaW9yaXR5KSB7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0V2l0aFByaW9yaXR5JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzZXRXaXRoUHJpb3JpdHknLCB2YWx1ZSwgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICB2YWxpZGF0ZVByaW9yaXR5KCdzZXRXaXRoUHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgaWYgKHJlZi5rZXkgPT09ICcubGVuZ3RoJyB8fCByZWYua2V5ID09PSAnLmtleXMnKSB7XHJcbiAgICAgICAgdGhyb3cgJ3NldFdpdGhQcmlvcml0eSBmYWlsZWQ6ICcgKyByZWYua2V5ICsgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgbXVsdGlwbGUgdmFsdWVzIHRvIHRoZSBEYXRhYmFzZSBhdCBvbmNlLlxyXG4gKlxyXG4gKiBUaGUgYHZhbHVlc2AgYXJndW1lbnQgY29udGFpbnMgbXVsdGlwbGUgcHJvcGVydHktdmFsdWUgcGFpcnMgdGhhdCB3aWxsIGJlXHJcbiAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICogcHJvcGVydHkgKGZvciBleGFtcGxlLCBcIm5hbWVcIikgb3IgYSByZWxhdGl2ZSBwYXRoIChmb3IgZXhhbXBsZSxcclxuICogXCJuYW1lL2ZpcnN0XCIpIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24gdG8gdGhlIGRhdGEgdG8gdXBkYXRlLlxyXG4gKlxyXG4gKiBBcyBvcHBvc2VkIHRvIHRoZSBgc2V0KClgIG1ldGhvZCwgYHVwZGF0ZSgpYCBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5IHVwZGF0ZVxyXG4gKiBvbmx5IHRoZSByZWZlcmVuY2VkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKGluc3RlYWQgb2YgcmVwbGFjaW5nXHJcbiAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHdyaXRlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSwgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50cyAoJ3ZhbHVlJywgJ2NoaWxkX2FkZGVkJywgZXRjLikgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZlxyXG4gKiB0aGUgZGF0YSB0byB0aGUgRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZFxyXG4gKiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIGBvbkNvbXBsZXRlYCBjYWxsYmFja1xyXG4gKiB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBBIHNpbmdsZSBgdXBkYXRlKClgIHdpbGwgZ2VuZXJhdGUgYSBzaW5nbGUgXCJ2YWx1ZVwiIGV2ZW50IGF0IHRoZSBsb2NhdGlvblxyXG4gKiB3aGVyZSB0aGUgYHVwZGF0ZSgpYCB3YXMgcGVyZm9ybWVkLCByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGNoaWxkcmVuIHdlcmVcclxuICogbW9kaWZpZWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBtb2RpZnlpbmcgZGF0YSB3aXRoIGB1cGRhdGUoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmdcclxuICogdHJhbnNhY3Rpb25zIGF0IHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nXHJcbiAqIGB1cGRhdGUoKWAgYW5kIGB0cmFuc2FjdGlvbigpYCB0byBtb2RpZnkgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogUGFzc2luZyBgbnVsbGAgdG8gYHVwZGF0ZSgpYCB3aWxsIHJlbW92ZSB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBTZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYmxvZy5jb20vMjAxNS8wOS9pbnRyb2R1Y2luZy1tdWx0aS1sb2NhdGlvbi11cGRhdGVzLWFuZF84Ni5odG1sIHwgSW50cm9kdWNpbmcgbXVsdGktbG9jYXRpb24gdXBkYXRlcyBhbmQgbW9yZX0uXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdXBkYXRlIG9uIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZShyZWYsIHZhbHVlcykge1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygndXBkYXRlJywgdmFsdWVzLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvVXBkYXRlKHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtb3N0IHVwLXRvLWRhdGUgcmVzdWx0IGZvciB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdG8gcnVuLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB3aGljaCByZXNvbHZlcyB0byB0aGUgcmVzdWx0aW5nIERhdGFTbmFwc2hvdCBpZiBhIHZhbHVlIGlzXHJcbiAqIGF2YWlsYWJsZSwgb3IgcmVqZWN0cyBpZiB0aGUgY2xpZW50IGlzIHVuYWJsZSB0byByZXR1cm4gYSB2YWx1ZSAoZS5nLiwgaWYgdGhlXHJcbiAqIHNlcnZlciBpcyB1bnJlYWNoYWJsZSBhbmQgdGhlcmUgaXMgbm90aGluZyBjYWNoZWQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0KHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBjb25zdCBjYWxsYmFja0NvbnRleHQgPSBuZXcgQ2FsbGJhY2tDb250ZXh0KCgpID0+IHsgfSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja0NvbnRleHQpO1xyXG4gICAgcmV0dXJuIHJlcG9HZXRWYWx1ZShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcikudGhlbihub2RlID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFTbmFwc2hvdChub2RlLCBuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyByZWdpc3RyYXRpb24gZm9yICd2YWx1ZScgZXZlbnRzLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxuICAgIHJlc3BvbmRzVG8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJztcclxuICAgIH1cclxuICAgIGNyZWF0ZUV2ZW50KGNoYW5nZSwgcXVlcnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KCd2YWx1ZScsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgaW5kZXgpKTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YSkge1xyXG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vbkNhbmNlbChldmVudERhdGEuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uVmFsdWUoZXZlbnREYXRhLnNuYXBzaG90LCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYW5jZWxFdmVudChlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQ29udGV4dC5oYXNDYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW90aGVyLmNhbGxiYWNrQ29udGV4dCB8fCAhdGhpcy5jYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3ZSBjb25zaWRlciBpdCB0byBtYXRjaCBhbnkgY2FsbGJhY2suXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmNhbGxiYWNrQ29udGV4dC5tYXRjaGVzKHRoaXMuY2FsbGJhY2tDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNBbnlDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja0NvbnRleHQgIT09IG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHJlZ2lzdHJhdGlvbiBvZiBhIGNoaWxkX3ggZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNwb25kc1RvKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGxldCBldmVudFRvQ2hlY2sgPSBldmVudFR5cGUgPT09ICdjaGlsZHJlbl9hZGRlZCcgPyAnY2hpbGRfYWRkZWQnIDogZXZlbnRUeXBlO1xyXG4gICAgICAgIGV2ZW50VG9DaGVjayA9XHJcbiAgICAgICAgICAgIGV2ZW50VG9DaGVjayA9PT0gJ2NoaWxkcmVuX3JlbW92ZWQnID8gJ2NoaWxkX3JlbW92ZWQnIDogZXZlbnRUb0NoZWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50VHlwZSA9PT0gZXZlbnRUb0NoZWNrO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FuY2VsRXZlbnQoZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0NvbnRleHQuaGFzQ2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudChjaGFuZ2UsIHF1ZXJ5KSB7XHJcbiAgICAgICAgYXNzZXJ0KGNoYW5nZS5jaGlsZE5hbWUgIT0gbnVsbCwgJ0NoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS4nKTtcclxuICAgICAgICBjb25zdCBjaGlsZFJlZiA9IGNoaWxkKG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIGNoYW5nZS5jaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRXZlbnQoY2hhbmdlLnR5cGUsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgY2hpbGRSZWYsIGluZGV4KSwgY2hhbmdlLnByZXZOYW1lKTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YSkge1xyXG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vbkNhbmNlbChldmVudERhdGEuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uVmFsdWUoZXZlbnREYXRhLnNuYXBzaG90LCBldmVudERhdGEucHJldk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5ldmVudFR5cGUgPT09IG90aGVyLmV2ZW50VHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgKCF0aGlzLmNhbGxiYWNrQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFvdGhlci5jYWxsYmFja0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dC5tYXRjaGVzKG90aGVyLmNhbGxiYWNrQ29udGV4dCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaGFzQW55Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIGxldCBjYW5jZWxDYWxsYmFjaztcclxuICAgIGlmICh0eXBlb2YgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgb3B0aW9ucyA9IGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9ubHlPbmNlKSB7XHJcbiAgICAgICAgY29uc3QgdXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgY29uc3Qgb25jZUNhbGxiYWNrID0gKGRhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHVzZXJDYWxsYmFjayhkYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uY2VDYWxsYmFjay51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjay51c2VyQ2FsbGJhY2s7XHJcbiAgICAgICAgb25jZUNhbGxiYWNrLmNvbnRleHQgPSBjYWxsYmFjay5jb250ZXh0O1xyXG4gICAgICAgIGNhbGxiYWNrID0gb25jZUNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FsbGJhY2tDb250ZXh0ID0gbmV3IENhbGxiYWNrQ29udGV4dChjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2sgfHwgdW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJ1xyXG4gICAgICAgID8gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tDb250ZXh0KVxyXG4gICAgICAgIDogbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRUeXBlLCBjYWxsYmFja0NvbnRleHQpO1xyXG4gICAgcmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbiAgICByZXR1cm4gKCkgPT4gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gb25WYWx1ZShxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ3ZhbHVlJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkQWRkZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9hZGRlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZENoYW5nZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9jaGFuZ2VkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkTW92ZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9tb3ZlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZFJlbW92ZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9yZW1vdmVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogRGV0YWNoZXMgYSBjYWxsYmFjayBwcmV2aW91c2x5IGF0dGFjaGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYG9uKigpYCAoYG9uVmFsdWVgLCBgb25DaGlsZEFkZGVkYCkgbGlzdGVuZXIuXHJcbiAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gcmVtb3ZlIGEgbGlzdGVuZXIuIEluc3RlYWQsIHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb21cclxuICogdGhlIHJlc3BlY3RpdmUgYG9uKmAgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBEZXRhY2ggYSBjYWxsYmFjayBwcmV2aW91c2x5IGF0dGFjaGVkIHdpdGggYG9uKigpYC4gQ2FsbGluZyBgb2ZmKClgIG9uIGEgcGFyZW50IGxpc3RlbmVyXHJcbiAqIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcmVtb3ZlIGxpc3RlbmVycyByZWdpc3RlcmVkIG9uIGNoaWxkIG5vZGVzLCBgb2ZmKClgXHJcbiAqIG11c3QgYWxzbyBiZSBjYWxsZWQgb24gYW55IGNoaWxkIGxpc3RlbmVycyB0byByZW1vdmUgdGhlIGNhbGxiYWNrLlxyXG4gKlxyXG4gKiBJZiBhIGNhbGxiYWNrIGlzIG5vdCBzcGVjaWZpZWQsIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRUeXBlXHJcbiAqIHdpbGwgYmUgcmVtb3ZlZC4gU2ltaWxhcmx5LCBpZiBubyBldmVudFR5cGUgaXMgc3BlY2lmaWVkLCBhbGwgY2FsbGJhY2tzXHJcbiAqIGZvciB0aGUgYFJlZmVyZW5jZWAgd2lsbCBiZSByZW1vdmVkLlxyXG4gKlxyXG4gKiBJbmRpdmlkdWFsIGxpc3RlbmVycyBjYW4gYWxzbyBiZSByZW1vdmVkIGJ5IGludm9raW5nIHRoZWlyIHVuc3Vic2NyaWJlXHJcbiAqIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRoYXQgdGhlIGxpc3RlbmVyIHdhcyByZWdpc3RlcmVkIHdpdGguXHJcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBPbmUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdzOiBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIixcclxuICogXCJjaGlsZF9jaGFuZ2VkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBvciBcImNoaWxkX21vdmVkLlwiIElmIG9taXR0ZWQsIGFsbCBjYWxsYmFja3NcclxuICogZm9yIHRoZSBgUmVmZXJlbmNlYCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdhcyBwYXNzZWQgdG8gYG9uKClgIG9yXHJcbiAqIGB1bmRlZmluZWRgIHRvIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKi9cclxuZnVuY3Rpb24gb2ZmKHF1ZXJ5LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgY29udGFpbmVyID0gbnVsbDtcclxuICAgIGNvbnN0IGV4cENhbGxiYWNrID0gY2FsbGJhY2sgPyBuZXcgQ2FsbGJhY2tDb250ZXh0KGNhbGxiYWNrKSA6IG51bGw7XHJcbiAgICBpZiAoZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oZXhwQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRUeXBlLCBleHBDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXHJcbiAqIERhdGFiYXNlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIGVuZEF0fSxcclxuICoge0BsaW5rIGVuZEJlZm9yZX0sIHtAbGluayBzdGFydEF0fSwge0BsaW5rIHN0YXJ0QWZ0ZXJ9LCB7QGxpbmtcclxuICogbGltaXRUb0ZpcnN0fSwge0BsaW5rIGxpbWl0VG9MYXN0fSwge0BsaW5rIG9yZGVyQnlDaGlsZH0sXHJcbiAqIHtAbGluayBvcmRlckJ5Q2hpbGR9LCB7QGxpbmsgb3JkZXJCeUtleX0gLCB7QGxpbmsgb3JkZXJCeVByaW9yaXR5fSAsXHJcbiAqIHtAbGluayBvcmRlckJ5VmFsdWV9ICBvciB7QGxpbmsgZXF1YWxUb30gYW5kXHJcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgcXVlcnl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0XHJcbiAqIGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VuZEF0JywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEF0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5kQXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdlbmRCZWZvcmUgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgZW5kaW5nIHBvaW50LlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBlbmRpbmcgcG9pbnQgaXMgaW5jbHVzaXZlLCBzbyBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZVxyXG4gKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS4gVGhlIG9wdGlvbmFsIGtleSBhcmd1bWVudCBjYW4gYmUgdXNlZCB0b1xyXG4gKiBmdXJ0aGVyIGxpbWl0IHRoZSByYW5nZSBvZiB0aGUgcXVlcnkuIElmIGl0IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiB0aGF0XHJcbiAqIGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYWxzbyBoYXZlIGEga2V5IG5hbWUgbGVzcyB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgZW5kQXQoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5kIGF0LiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBlbmQgYXQsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBwcmV2aW91c2x5XHJcbiAqIHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnkgY2hpbGQsXHJcbiAqIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVuZEF0KHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlbmRBdCcsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeUVuZEJlZm9yZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VuZEJlZm9yZScsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQmVmb3JlKHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5kQmVmb3JlOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnZW5kQmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIGVuZGluZyBwb2ludCAoZXhjbHVzaXZlKS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgZW5kaW5nIHBvaW50IGlzIGV4Y2x1c2l2ZS4gSWYgb25seSBhIHZhbHVlIGlzIHByb3ZpZGVkLCBjaGlsZHJlblxyXG4gKiB3aXRoIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuXHJcbiAqIElmIGEga2V5IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiBtdXN0IGhhdmUgYSB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWxcclxuICogdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgYSBrZXkgbmFtZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmQgYmVmb3JlLiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBlbmQgYmVmb3JlLCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGVcclxuICogcHJldmlvdXNseSBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5XHJcbiAqIGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmRCZWZvcmUodmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VuZEJlZm9yZScsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUVuZEJlZm9yZUNvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlTdGFydEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc3RhcnRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBzdGFydGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgaW5jbHVzaXZlLCBzbyBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZVxyXG4gKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS4gVGhlIG9wdGlvbmFsIGtleSBhcmd1bWVudCBjYW4gYmUgdXNlZCB0b1xyXG4gKiBmdXJ0aGVyIGxpbWl0IHRoZSByYW5nZSBvZiB0aGUgcXVlcnkuIElmIGl0IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiB0aGF0XHJcbiAqIGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYWxzbyBoYXZlIGEga2V5IG5hbWUgZ3JlYXRlciB0aGFuIG9yXHJcbiAqIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgc3RhcnRBdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdGFydCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmXHJcbiAqIG9yZGVyaW5nIGJ5IGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEF0KHZhbHVlID0gbnVsbCwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnc3RhcnRBdCcsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3N0YXJ0QWZ0ZXInLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QWZ0ZXI6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QWZ0ZXIsIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50IChleGNsdXNpdmUpLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdGFydCBhZnRlci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYWZ0ZXIuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmXHJcbiAqIG9yZGVyaW5nIGJ5IGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEFmdGVyKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEFmdGVyJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvRmlyc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0xpbWl0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl9saW1pdCksIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGlmIGxpbWl0ZWQgdG8gdGhlIGZpcnN0IHNwZWNpZmljIG51bWJlclxyXG4gKiBvZiBjaGlsZHJlbi5cclxuICpcclxuICogVGhlIGBsaW1pdFRvRmlyc3QoKWAgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGEgbWF4aW11bSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gYmVcclxuICogc3luY2VkIGZvciBhIGdpdmVuIGNhbGxiYWNrLiBJZiB3ZSBzZXQgYSBsaW1pdCBvZiAxMDAsIHdlIHdpbGwgaW5pdGlhbGx5IG9ubHlcclxuICogcmVjZWl2ZSB1cCB0byAxMDAgYGNoaWxkX2FkZGVkYCBldmVudHMuIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiAxMDAgbWVzc2FnZXNcclxuICogc3RvcmVkIGluIG91ciBEYXRhYmFzZSwgYSBgY2hpbGRfYWRkZWRgIGV2ZW50IHdpbGwgZmlyZSBmb3IgZWFjaCBtZXNzYWdlLlxyXG4gKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG92ZXIgMTAwIG1lc3NhZ2VzLCB3ZSB3aWxsIG9ubHkgcmVjZWl2ZSBhIGBjaGlsZF9hZGRlZGBcclxuICogZXZlbnQgZm9yIHRoZSBmaXJzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0ZpcnN0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIGluY2x1ZGUgaW4gdGhpcyBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9GaXJzdChsaW1pdCkge1xyXG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9GaXJzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludChsaW1pdCk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX2xpbWl0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdFRvRmlyc3QgJyArXHJcbiAgICAgICAgICAgICAgICAnb3IgbGltaXRUb0xhc3QpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIHF1ZXJ5UGFyYW1zTGltaXRUb0xhc3QocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl9saW1pdCksIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGlzIGxpbWl0ZWQgdG8gcmV0dXJuIG9ubHkgdGhlIGxhc3RcclxuICogc3BlY2lmaWVkIG51bWJlciBvZiBjaGlsZHJlbi5cclxuICpcclxuICogVGhlIGBsaW1pdFRvTGFzdCgpYCBtZXRob2QgaXMgdXNlZCB0byBzZXQgYSBtYXhpbXVtIG51bWJlciBvZiBjaGlsZHJlbiB0byBiZVxyXG4gKiBzeW5jZWQgZm9yIGEgZ2l2ZW4gY2FsbGJhY2suIElmIHdlIHNldCBhIGxpbWl0IG9mIDEwMCwgd2Ugd2lsbCBpbml0aWFsbHkgb25seVxyXG4gKiByZWNlaXZlIHVwIHRvIDEwMCBgY2hpbGRfYWRkZWRgIGV2ZW50cy4gSWYgd2UgaGF2ZSBmZXdlciB0aGFuIDEwMCBtZXNzYWdlc1xyXG4gKiBzdG9yZWQgaW4gb3VyIERhdGFiYXNlLCBhIGBjaGlsZF9hZGRlZGAgZXZlbnQgd2lsbCBmaXJlIGZvciBlYWNoIG1lc3NhZ2UuXHJcbiAqIEhvd2V2ZXIsIGlmIHdlIGhhdmUgb3ZlciAxMDAgbWVzc2FnZXMsIHdlIHdpbGwgb25seSByZWNlaXZlIGEgYGNoaWxkX2FkZGVkYFxyXG4gKiBldmVudCBmb3IgdGhlIGxhc3QgMTAwIG9yZGVyZWQgbWVzc2FnZXMuIEFzIGl0ZW1zIGNoYW5nZSwgd2Ugd2lsbCByZWNlaXZlXHJcbiAqIGBjaGlsZF9yZW1vdmVkYCBldmVudHMgZm9yIGVhY2ggaXRlbSB0aGF0IGRyb3BzIG91dCBvZiB0aGUgYWN0aXZlIGxpc3Qgc29cclxuICogdGhhdCB0aGUgdG90YWwgbnVtYmVyIHN0YXlzIGF0IDEwMC5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGxpbWl0VG9MYXN0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIGluY2x1ZGUgaW4gdGhpcyBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9MYXN0KGxpbWl0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fCBNYXRoLmZsb29yKGxpbWl0KSAhPT0gbGltaXQgfHwgbGltaXQgPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0VG9MYXN0Q29uc3RyYWludChsaW1pdCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9wYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlDaGlsZCcpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFBhdGggPSBuZXcgUGF0aCh0aGlzLl9wYXRoKTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGFyc2VkUGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IGNhbm5vdCBwYXNzIGluIGVtcHR5IHBhdGguIFVzZSBvcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmRleCA9IG5ldyBQYXRoSW5kZXgocGFyc2VkUGF0aCk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgaW5kZXgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBzcGVjaWZpZWQgY2hpbGQga2V5LlxyXG4gKlxyXG4gKiBRdWVyaWVzIGNhbiBvbmx5IG9yZGVyIGJ5IG9uZSBrZXkgYXQgYSB0aW1lLiBDYWxsaW5nIGBvcmRlckJ5Q2hpbGQoKWBcclxuICogbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgcXVlcnkgaXMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEZpcmViYXNlIHF1ZXJpZXMgYWxsb3cgeW91IHRvIG9yZGVyIHlvdXIgZGF0YSBieSBhbnkgY2hpbGQga2V5IG9uIHRoZSBmbHkuXHJcbiAqIEhvd2V2ZXIsIGlmIHlvdSBrbm93IGluIGFkdmFuY2Ugd2hhdCB5b3VyIGluZGV4ZXMgd2lsbCBiZSwgeW91IGNhbiBkZWZpbmVcclxuICogdGhlbSB2aWEgdGhlIC5pbmRleE9uIHJ1bGUgaW4geW91ciBTZWN1cml0eSBSdWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLiBTZWVcclxuICogdGhle0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3NlY3VyaXR5L2luZGV4aW5nLWRhdGF9XHJcbiAqIHJ1bGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5Q2hpbGQoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gb3JkZXIgYnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5Q2hpbGQocGF0aCkge1xyXG4gICAgaWYgKHBhdGggPT09ICcka2V5Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0aCA9PT0gJyRwcmlvcml0eScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXRoID09PSAnJHZhbHVlJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiR2YWx1ZVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZygnb3JkZXJCeUNoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeUNoaWxkQ29uc3RyYWludChwYXRoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeUtleScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIEtFWV9JTkRFWCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgdGhlIGtleS5cclxuICpcclxuICogU29ydHMgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeSBieSB0aGVpciAoYXNjZW5kaW5nKSBrZXkgdmFsdWVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeUtleSgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlLZXkoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeUtleUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlQcmlvcml0eUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5UHJpb3JpdHknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgcHJpb3JpdHkuXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX1cclxuICogZm9yIGFsdGVybmF0aXZlcyB0byBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlQcmlvcml0eSgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5VmFsdWVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeVZhbHVlJyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgVkFMVUVfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHZhbHVlLlxyXG4gKlxyXG4gKiBJZiB0aGUgY2hpbGRyZW4gb2YgYSBxdWVyeSBhcmUgYWxsIHNjYWxhciB2YWx1ZXMgKHN0cmluZywgbnVtYmVyLCBvclxyXG4gKiBib29sZWFuKSwgeW91IGNhbiBvcmRlciB0aGUgcmVzdWx0cyBieSB0aGVpciAoYXNjZW5kaW5nKSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5VmFsdWUoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnZXF1YWxUbycsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQvc3RhcnRBZnRlciBvciAnICtcclxuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VxdWFsVG86IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdC9lbmRCZWZvcmUgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodGhpcy5fdmFsdWUsIHRoaXMuX2tleSkuX2FwcGx5KG5ldyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpLl9hcHBseShxdWVyeSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpbmNsdWRlcyBjaGlsZHJlbiB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWRcclxuICogdmFsdWUuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIG9wdGlvbmFsIGtleSBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBmdXJ0aGVyIGxpbWl0IHRoZSByYW5nZSBvZiB0aGVcclxuICogcXVlcnkuIElmIGl0IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiB0aGF0IGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkXHJcbiAqIHZhbHVlIG11c3QgYWxzbyBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCBrZXkgYXMgdGhlaXIga2V5IG5hbWUuIFRoaXMgY2FuIGJlXHJcbiAqIHVzZWQgdG8gZmlsdGVyIHJlc3VsdCBzZXRzIHdpdGggbWFueSBtYXRjaGVzIGZvciB0aGUgc2FtZSB2YWx1ZS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGVxdWFsVG8oKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbWF0Y2ggZm9yLiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBzdGFydCBhdCwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlXHJcbiAqIHByZXZpb3VzbHkgc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieVxyXG4gKiBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxUbyh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZXF1YWxUbycsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUVxdWFsVG9WYWx1ZUNvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIGluc3RhbmNlIG9mIGBRdWVyeWAgdGhhdCBpcyBleHRlbmRlZCB0byBhbHNvIGluY2x1ZGVcclxuICogYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIFF1ZXJ5IGluc3RhbmNlIHRvIHVzZSBhcyBhIGJhc2UgZm9yIHRoZSBuZXcgY29uc3RyYWludHMuXHJcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gVGhlIGxpc3Qgb2YgYFF1ZXJ5Q29uc3RyYWludGBzIHRvIGFwcGx5LlxyXG4gKiBAdGhyb3dzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgY29uc3RyYWludHMgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggdGhlXHJcbiAqIGV4aXN0aW5nIG9yIG5ldyBjb25zdHJhaW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCAuLi5xdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICBsZXQgcXVlcnlJbXBsID0gZ2V0TW9kdWxhckluc3RhbmNlKHF1ZXJ5KTtcclxuICAgIGZvciAoY29uc3QgY29uc3RyYWludCBvZiBxdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgcXVlcnlJbXBsID0gY29uc3RyYWludC5fYXBwbHkocXVlcnlJbXBsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeUltcGw7XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZSByZWZlcmVuY2UgY29uc3RydWN0b3IgaW4gdmFyaW91cyBtb2R1bGVzXHJcbiAqXHJcbiAqIFdlIGFyZSBkb2luZyB0aGlzIGhlcmUgdG8gYXZvaWQgc2V2ZXJhbCBjaXJjdWxhclxyXG4gKiBkZXBlbmRlbmN5IGlzc3Vlc1xyXG4gKi9cclxuc3luY1BvaW50U2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoUmVmZXJlbmNlSW1wbCk7XHJcbnN5bmNUcmVlU2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoUmVmZXJlbmNlSW1wbCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIHZhcmlhYmxlIGlzIGFsc28gZGVmaW5lZCBpbiB0aGUgZmlyZWJhc2UgTm9kZS5qcyBBZG1pbiBTREsuIEJlZm9yZVxyXG4gKiBtb2RpZnlpbmcgdGhpcyBkZWZpbml0aW9uLCBjb25zdWx0IHRoZSBkZWZpbml0aW9uIGluOlxyXG4gKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtYWRtaW4tbm9kZVxyXG4gKlxyXG4gKiBhbmQgbWFrZSBzdXJlIHRoZSB0d28gYXJlIGNvbnNpc3RlbnQuXHJcbiAqL1xyXG5jb25zdCBGSVJFQkFTRV9EQVRBQkFTRV9FTVVMQVRPUl9IT1NUX1ZBUiA9ICdGSVJFQkFTRV9EQVRBQkFTRV9FTVVMQVRPUl9IT1NUJztcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIGNhY2hlcyBgUmVwb2AgaW5zdGFuY2VzLlxyXG4gKi9cclxuY29uc3QgcmVwb3MgPSB7fTtcclxuLyoqXHJcbiAqIElmIHRydWUsIGFueSBuZXcgYFJlcG9gIHdpbGwgYmUgY3JlYXRlZCB0byB1c2UgYFJlYWRvbmx5UmVzdENsaWVudGAgKGZvciB0ZXN0aW5nIHB1cnBvc2VzKS5cclxuICovXHJcbmxldCB1c2VSZXN0Q2xpZW50ID0gZmFsc2U7XHJcbi8qKlxyXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgYFJlcG9gIGluIHBsYWNlIHRvIHBvaW50IHRvIGEgbmV3IGhvc3QvcG9ydC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzKHJlcG8sIGhvc3QsIHBvcnQsIHRva2VuUHJvdmlkZXIpIHtcclxuICAgIHJlcG8ucmVwb0luZm9fID0gbmV3IFJlcG9JbmZvKGAke2hvc3R9OiR7cG9ydH1gLCBcclxuICAgIC8qIHNlY3VyZT0gKi8gZmFsc2UsIHJlcG8ucmVwb0luZm9fLm5hbWVzcGFjZSwgcmVwby5yZXBvSW5mb18ud2ViU29ja2V0T25seSwgcmVwby5yZXBvSW5mb18ubm9kZUFkbWluLCByZXBvLnJlcG9JbmZvXy5wZXJzaXN0ZW5jZUtleSwgcmVwby5yZXBvSW5mb18uaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMsIFxyXG4gICAgLyppc1VzaW5nRW11bGF0b3I9Ki8gdHJ1ZSk7XHJcbiAgICBpZiAodG9rZW5Qcm92aWRlcikge1xyXG4gICAgICAgIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfID0gdG9rZW5Qcm92aWRlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBldmVyIGJlIGNhbGxlZCB0byBDUkVBVEUgYSBuZXcgZGF0YWJhc2UgaW5zdGFuY2UuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgbm9kZUFkbWluKSB7XHJcbiAgICBsZXQgZGJVcmwgPSB1cmwgfHwgYXBwLm9wdGlvbnMuZGF0YWJhc2VVUkw7XHJcbiAgICBpZiAoZGJVcmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICghYXBwLm9wdGlvbnMucHJvamVjdElkKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKFwiQ2FuJ3QgZGV0ZXJtaW5lIEZpcmViYXNlIERhdGFiYXNlIFVSTC4gQmUgc3VyZSB0byBpbmNsdWRlIFwiICtcclxuICAgICAgICAgICAgICAgICcgYSBQcm9qZWN0IElEIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZygnVXNpbmcgZGVmYXVsdCBob3N0IGZvciBwcm9qZWN0ICcsIGFwcC5vcHRpb25zLnByb2plY3RJZCk7XHJcbiAgICAgICAgZGJVcmwgPSBgJHthcHAub3B0aW9ucy5wcm9qZWN0SWR9LWRlZmF1bHQtcnRkYi5maXJlYmFzZWlvLmNvbWA7XHJcbiAgICB9XHJcbiAgICBsZXQgcGFyc2VkVXJsID0gcGFyc2VSZXBvSW5mbyhkYlVybCwgbm9kZUFkbWluKTtcclxuICAgIGxldCByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcclxuICAgIGxldCBpc0VtdWxhdG9yO1xyXG4gICAgbGV0IGRiRW11bGF0b3JIb3N0ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudikge1xyXG4gICAgICAgIGRiRW11bGF0b3JIb3N0ID0gcHJvY2Vzcy5lbnZbRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVJdO1xyXG4gICAgfVxyXG4gICAgaWYgKGRiRW11bGF0b3JIb3N0KSB7XHJcbiAgICAgICAgaXNFbXVsYXRvciA9IHRydWU7XHJcbiAgICAgICAgZGJVcmwgPSBgaHR0cDovLyR7ZGJFbXVsYXRvckhvc3R9P25zPSR7cmVwb0luZm8ubmFtZXNwYWNlfWA7XHJcbiAgICAgICAgcGFyc2VkVXJsID0gcGFyc2VSZXBvSW5mbyhkYlVybCwgbm9kZUFkbWluKTtcclxuICAgICAgICByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSAhcGFyc2VkVXJsLnJlcG9JbmZvLnNlY3VyZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhUb2tlblByb3ZpZGVyID0gbm9kZUFkbWluICYmIGlzRW11bGF0b3JcclxuICAgICAgICA/IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKVxyXG4gICAgICAgIDogbmV3IEZpcmViYXNlQXV0aFRva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcC5vcHRpb25zLCBhdXRoUHJvdmlkZXIpO1xyXG4gICAgdmFsaWRhdGVVcmwoJ0ludmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMJywgcGFyc2VkVXJsKTtcclxuICAgIGlmICghcGF0aElzRW1wdHkocGFyc2VkVXJsLnBhdGgpKSB7XHJcbiAgICAgICAgZmF0YWwoJ0RhdGFiYXNlIFVSTCBtdXN0IHBvaW50IHRvIHRoZSByb290IG9mIGEgRmlyZWJhc2UgRGF0YWJhc2UgJyArXHJcbiAgICAgICAgICAgICcobm90IGluY2x1ZGluZyBhIGNoaWxkIHBhdGgpLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgbmV3IEFwcENoZWNrVG9rZW5Qcm92aWRlcihhcHAubmFtZSwgYXBwQ2hlY2tQcm92aWRlcikpO1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZShyZXBvLCBhcHApO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIHJlcG8gYW5kIG1ha2Ugc3VyZSBpdCBpcyBkaXNjb25uZWN0ZWQuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckRlbGV0ZVJlcG8ocmVwbywgYXBwTmFtZSkge1xyXG4gICAgY29uc3QgYXBwUmVwb3MgPSByZXBvc1thcHBOYW1lXTtcclxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4uLlxyXG4gICAgaWYgKCFhcHBSZXBvcyB8fCBhcHBSZXBvc1tyZXBvLmtleV0gIT09IHJlcG8pIHtcclxuICAgICAgICBmYXRhbChgRGF0YWJhc2UgJHthcHBOYW1lfSgke3JlcG8ucmVwb0luZm9ffSkgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkLmApO1xyXG4gICAgfVxyXG4gICAgcmVwb0ludGVycnVwdChyZXBvKTtcclxuICAgIGRlbGV0ZSBhcHBSZXBvc1tyZXBvLmtleV07XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZXMgYSByZXBvIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBhbmQgdGhlbiBjcmVhdGVzIG9uZSB1c2luZyB0aGVcclxuICogcHJvdmlkZWQgYXBwLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVwb0luZm8gLSBUaGUgbWV0YWRhdGEgYWJvdXQgdGhlIFJlcG9cclxuICogQHJldHVybnMgVGhlIFJlcG8gb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHNlcnZlciAvIHJlcG9OYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJDcmVhdGVSZXBvKHJlcG9JbmZvLCBhcHAsIGF1dGhUb2tlblByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyKSB7XHJcbiAgICBsZXQgYXBwUmVwb3MgPSByZXBvc1thcHAubmFtZV07XHJcbiAgICBpZiAoIWFwcFJlcG9zKSB7XHJcbiAgICAgICAgYXBwUmVwb3MgPSB7fTtcclxuICAgICAgICByZXBvc1thcHAubmFtZV0gPSBhcHBSZXBvcztcclxuICAgIH1cclxuICAgIGxldCByZXBvID0gYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV07XHJcbiAgICBpZiAocmVwbykge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBpbml0aWFsaXplZCBtdWx0aXBsZSB0aW1lcy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhYmFzZSBVUkwgbWF0Y2hlcyB3aXRoIGVhY2ggZGF0YWJhc2UoKSBjYWxsLicpO1xyXG4gICAgfVxyXG4gICAgcmVwbyA9IG5ldyBSZXBvKHJlcG9JbmZvLCB1c2VSZXN0Q2xpZW50LCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcik7XHJcbiAgICBhcHBSZXBvc1tyZXBvSW5mby50b1VSTFN0cmluZygpXSA9IHJlcG87XHJcbiAgICByZXR1cm4gcmVwbztcclxufVxyXG4vKipcclxuICogRm9yY2VzIHVzIHRvIHVzZSBSZWFkb25seVJlc3RDbGllbnQgaW5zdGVhZCBvZiBQZXJzaXN0ZW50Q29ubmVjdGlvbiBmb3IgbmV3IFJlcG9zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KSB7XHJcbiAgICB1c2VSZXN0Q2xpZW50ID0gZm9yY2VSZXN0Q2xpZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBGaXJlYmFzZSBSZWFsdGltZSBEYXRhYmFzZS5cclxuICovXHJcbmNsYXNzIERhdGFiYXNlIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVwb0ludGVybmFsLCBcclxuICAgIC8qKiBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIFJlYWx0aW1lIERhdGFiYXNlIGluc3RhbmNlLiAqL1xyXG4gICAgYXBwKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwb0ludGVybmFsID0gX3JlcG9JbnRlcm5hbDtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICAvKiogUmVwcmVzZW50cyBhIGBEYXRhYmFzZWAgaW5zdGFuY2UuICovXHJcbiAgICAgICAgdGhpc1sndHlwZSddID0gJ2RhdGFiYXNlJztcclxuICAgICAgICAvKiogVHJhY2sgaWYgdGhlIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgKHJvb3Qgb3IgcmVwbyBhY2Nlc3NlZCkgKi9cclxuICAgICAgICB0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBfcmVwbygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgICAgICByZXBvU3RhcnQodGhpcy5fcmVwb0ludGVybmFsLCB0aGlzLmFwcC5vcHRpb25zLmFwcElkLCB0aGlzLmFwcC5vcHRpb25zWydkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJ10pO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwb0ludGVybmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9yb290KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdEludGVybmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RJbnRlcm5hbCA9IG5ldyBSZWZlcmVuY2VJbXBsKHRoaXMuX3JlcG8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RJbnRlcm5hbDtcclxuICAgIH1cclxuICAgIF9kZWxldGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RJbnRlcm5hbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXBvTWFuYWdlckRlbGV0ZVJlcG8odGhpcy5fcmVwbywgdGhpcy5hcHAubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RJbnRlcm5hbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIF9jaGVja05vdERlbGV0ZWQoYXBpTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZmF0YWwoJ0Nhbm5vdCBjYWxsICcgKyBhcGlOYW1lICsgJyBvbiBhIGRlbGV0ZWQgZGF0YWJhc2UuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrVHJhbnNwb3J0SW5pdCgpIHtcclxuICAgIGlmIChUcmFuc3BvcnRNYW5hZ2VyLklTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCkge1xyXG4gICAgICAgIHdhcm4oJ1RyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgY2FsbCB0aGlzIGZ1bmN0aW9uIGJlZm9yZSBjYWxsaW5nIHJlZiBvciBzZXR0aW5nIHVwIGEgbGlzdGVuZXInKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRm9yY2UgdGhlIHVzZSBvZiB3ZWJzb2NrZXRzIGluc3RlYWQgb2YgbG9uZ1BvbGxpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JjZVdlYlNvY2tldHMoKSB7XHJcbiAgICBjaGVja1RyYW5zcG9ydEluaXQoKTtcclxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93KCk7XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlIHRoZSB1c2Ugb2YgbG9uZ1BvbGxpbmcgaW5zdGVhZCBvZiB3ZWJzb2NrZXRzLiBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB3ZWJzb2NrZXQgcHJvdG9jb2wgaXMgdXNlZCBpbiBkYXRhYmFzZVVSTC5cclxuICovXHJcbmZ1bmN0aW9uIGZvcmNlTG9uZ1BvbGxpbmcoKSB7XHJcbiAgICBjaGVja1RyYW5zcG9ydEluaXQoKTtcclxuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xyXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlQWxsb3coKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIFJlYWx0aW1lIERhdGFiYXNlIFNESyB0aGF0IGlzIGFzc29jaWF0ZWRcclxuICogd2l0aCB0aGUgcHJvdmlkZWQge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9LiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSB3aXRoXHJcbiAqIHdpdGggZGVmYXVsdCBzZXR0aW5ncyBpZiBubyBpbnN0YW5jZSBleGlzdHMgb3IgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHVzZXNcclxuICogYSBjdXN0b20gZGF0YWJhc2UgVVJMLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZSB0aGF0IHRoZSByZXR1cm5lZCBSZWFsdGltZVxyXG4gKiBEYXRhYmFzZSBpbnN0YW5jZSBpcyBhc3NvY2lhdGVkIHdpdGguXHJcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBpbnN0YW5jZSB0byBjb25uZWN0IHRvLiBJZiBub3RcclxuICogcHJvdmlkZWQsIHRoZSBTREsgY29ubmVjdHMgdG8gdGhlIGRlZmF1bHQgaW5zdGFuY2Ugb2YgdGhlIEZpcmViYXNlIEFwcC5cclxuICogQHJldHVybnMgVGhlIGBEYXRhYmFzZWAgaW5zdGFuY2Ugb2YgdGhlIHByb3ZpZGVkIGFwcC5cclxuICovXHJcbmZ1bmN0aW9uIGdldERhdGFiYXNlKGFwcCA9IGdldEFwcCgpLCB1cmwpIHtcclxuICAgIGNvbnN0IGRiID0gX2dldFByb3ZpZGVyKGFwcCwgJ2RhdGFiYXNlJykuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICBpZGVudGlmaWVyOiB1cmxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFkYi5faW5zdGFuY2VTdGFydGVkKSB7XHJcbiAgICAgICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ2RhdGFiYXNlJyk7XHJcbiAgICAgICAgaWYgKGVtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yKGRiLCAuLi5lbXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiO1xyXG59XHJcbi8qKlxyXG4gKiBNb2RpZnkgdGhlIHByb3ZpZGVkIGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIFJlYWx0aW1lIERhdGFiYXNlXHJcbiAqIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiA8cD5Ob3RlOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcGVyZm9ybWluZyBhbnkgb3RoZXIgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gbW9kaWZ5LlxyXG4gKiBAcGFyYW0gaG9zdCAtIFRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KVxyXG4gKiBAcGFyYW0gcG9ydCAtIFRoZSBlbXVsYXRvciBwb3J0IChleDogODA4MClcclxuICogQHBhcmFtIG9wdGlvbnMubW9ja1VzZXJUb2tlbiAtIHRoZSBtb2NrIGF1dGggdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmcgU2VjdXJpdHkgUnVsZXNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yKGRiLCBob3N0LCBwb3J0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ3VzZUVtdWxhdG9yJyk7XHJcbiAgICBpZiAoZGIuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCB1c2VFbXVsYXRvcigpIGFmdGVyIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXBvID0gZGIuX3JlcG9JbnRlcm5hbDtcclxuICAgIGxldCB0b2tlblByb3ZpZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHJlcG8ucmVwb0luZm9fLm5vZGVBZG1pbikge1xyXG4gICAgICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcclxuICAgICAgICAgICAgZmF0YWwoJ21vY2tVc2VyVG9rZW4gaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgQWRtaW4gU0RLLiBGb3IgY2xpZW50IGFjY2VzcyB3aXRoIG1vY2sgdXNlcnMsIHBsZWFzZSB1c2UgdGhlIFwiZmlyZWJhc2VcIiBwYWNrYWdlIGluc3RlYWQgb2YgXCJmaXJlYmFzZS1hZG1pblwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2tlblByb3ZpZGVyID0gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcihFbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0eXBlb2Ygb3B0aW9ucy5tb2NrVXNlclRva2VuID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IG9wdGlvbnMubW9ja1VzZXJUb2tlblxyXG4gICAgICAgICAgICA6IGNyZWF0ZU1vY2tVc2VyVG9rZW4ob3B0aW9ucy5tb2NrVXNlclRva2VuLCBkYi5hcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgIHRva2VuUHJvdmlkZXIgPSBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKHRva2VuKTtcclxuICAgIH1cclxuICAgIC8vIE1vZGlmeSB0aGUgcmVwbyB0byBhcHBseSBlbXVsYXRvciBzZXR0aW5nc1xyXG4gICAgcmVwb01hbmFnZXJBcHBseUVtdWxhdG9yU2V0dGluZ3MocmVwbywgaG9zdCwgcG9ydCwgdG9rZW5Qcm92aWRlcik7XHJcbn1cclxuLyoqXHJcbiAqIERpc2Nvbm5lY3RzIGZyb20gdGhlIHNlcnZlciAoYWxsIERhdGFiYXNlIG9wZXJhdGlvbnMgd2lsbCBiZSBjb21wbGV0ZWRcclxuICogb2ZmbGluZSkuXHJcbiAqXHJcbiAqIFRoZSBjbGllbnQgYXV0b21hdGljYWxseSBtYWludGFpbnMgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gdG8gdGhlIERhdGFiYXNlXHJcbiAqIHNlcnZlciwgd2hpY2ggd2lsbCByZW1haW4gYWN0aXZlIGluZGVmaW5pdGVseSBhbmQgcmVjb25uZWN0IHdoZW5cclxuICogZGlzY29ubmVjdGVkLiBIb3dldmVyLCB0aGUgYGdvT2ZmbGluZSgpYCBhbmQgYGdvT25saW5lKClgIG1ldGhvZHMgbWF5IGJlIHVzZWRcclxuICogdG8gY29udHJvbCB0aGUgY2xpZW50IGNvbm5lY3Rpb24gaW4gY2FzZXMgd2hlcmUgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gaXNcclxuICogdW5kZXNpcmFibGUuXHJcbiAqXHJcbiAqIFdoaWxlIG9mZmxpbmUsIHRoZSBjbGllbnQgd2lsbCBubyBsb25nZXIgcmVjZWl2ZSBkYXRhIHVwZGF0ZXMgZnJvbSB0aGVcclxuICogRGF0YWJhc2UuIEhvd2V2ZXIsIGFsbCBEYXRhYmFzZSBvcGVyYXRpb25zIHBlcmZvcm1lZCBsb2NhbGx5IHdpbGwgY29udGludWUgdG9cclxuICogaW1tZWRpYXRlbHkgZmlyZSBldmVudHMsIGFsbG93aW5nIHlvdXIgYXBwbGljYXRpb24gdG8gY29udGludWUgYmVoYXZpbmdcclxuICogbm9ybWFsbHkuIEFkZGl0aW9uYWxseSwgZWFjaCBvcGVyYXRpb24gcGVyZm9ybWVkIGxvY2FsbHkgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAqIGJlIHF1ZXVlZCBhbmQgcmV0cmllZCB1cG9uIHJlY29ubmVjdGlvbiB0byB0aGUgRGF0YWJhc2Ugc2VydmVyLlxyXG4gKlxyXG4gKiBUbyByZWNvbm5lY3QgdG8gdGhlIERhdGFiYXNlIGFuZCBiZWdpbiByZWNlaXZpbmcgcmVtb3RlIGV2ZW50cywgc2VlXHJcbiAqIGBnb09ubGluZSgpYC5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIGRpc2Nvbm5lY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnb09mZmxpbmUoZGIpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ2dvT2ZmbGluZScpO1xyXG4gICAgcmVwb0ludGVycnVwdChkYi5fcmVwbyk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29ubmVjdHMgdG8gdGhlIHNlcnZlciBhbmQgc3luY2hyb25pemVzIHRoZSBvZmZsaW5lIERhdGFiYXNlIHN0YXRlXHJcbiAqIHdpdGggdGhlIHNlcnZlciBzdGF0ZS5cclxuICpcclxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgZGlzYWJsaW5nIHRoZSBhY3RpdmUgY29ubmVjdGlvbiB3aXRoXHJcbiAqIGBnb09mZmxpbmUoKWAuIE9uY2UgcmVjb25uZWN0ZWQsIHRoZSBjbGllbnQgd2lsbCB0cmFuc21pdCB0aGUgcHJvcGVyIGRhdGFcclxuICogYW5kIGZpcmUgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cyBzbyB0aGF0IHlvdXIgY2xpZW50IFwiY2F0Y2hlcyB1cFwiXHJcbiAqIGF1dG9tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byByZWNvbm5lY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnb09ubGluZShkYikge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgnZ29PbmxpbmUnKTtcclxuICAgIHJlcG9SZXN1bWUoZGIuX3JlcG8pO1xyXG59XHJcbmZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmcobG9nZ2VyLCBwZXJzaXN0ZW50KSB7XHJcbiAgICBlbmFibGVMb2dnaW5nJDEobG9nZ2VyLCBwZXJzaXN0ZW50KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckRhdGFiYXNlKHZhcmlhbnQpIHtcclxuICAgIHNldFNES1ZlcnNpb24oU0RLX1ZFUlNJT04kMSk7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnZGF0YWJhc2UnLCAoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogdXJsIH0pID0+IHtcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpO1xyXG4gICAgICAgIGNvbnN0IGFwcENoZWNrUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xyXG4gICAgICAgIHJldHVybiByZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcChhcHAsIGF1dGhQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgdXJsKTtcclxuICAgIH0sIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBTRVJWRVJfVElNRVNUQU1QID0ge1xyXG4gICAgJy5zdic6ICd0aW1lc3RhbXAnXHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGF1dG8tcG9wdWxhdGluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAgKHRpbWVcclxuICogc2luY2UgdGhlIFVuaXggZXBvY2gsIGluIG1pbGxpc2Vjb25kcykgYXMgZGV0ZXJtaW5lZCBieSB0aGUgRmlyZWJhc2VcclxuICogc2VydmVycy5cclxuICovXHJcbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcclxuICAgIHJldHVybiBTRVJWRVJfVElNRVNUQU1QO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcGxhY2Vob2xkZXIgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byBhdG9taWNhbGx5IGluY3JlbWVudCB0aGVcclxuICogY3VycmVudCBkYXRhYmFzZSB2YWx1ZSBieSB0aGUgcHJvdmlkZWQgZGVsdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSBkZWx0YSAtIHRoZSBhbW91bnQgdG8gbW9kaWZ5IHRoZSBjdXJyZW50IHZhbHVlIGF0b21pY2FsbHkuXHJcbiAqIEByZXR1cm5zIEEgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIG1vZGlmeWluZyBkYXRhIGF0b21pY2FsbHkgc2VydmVyLXNpZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNyZW1lbnQoZGVsdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJy5zdic6IHtcclxuICAgICAgICAgICAgJ2luY3JlbWVudCc6IGRlbHRhXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB0eXBlIGZvciB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb25SZXN1bHQge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsbHkgY29tbWl0dGVkLiAqL1xyXG4gICAgY29tbWl0dGVkLCBcclxuICAgIC8qKiBUaGUgcmVzdWx0aW5nIGRhdGEgc25hcHNob3QuICovXHJcbiAgICBzbmFwc2hvdCkge1xyXG4gICAgICAgIHRoaXMuY29tbWl0dGVkID0gY29tbWl0dGVkO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgY29tbWl0dGVkOiB0aGlzLmNvbW1pdHRlZCwgc25hcHNob3Q6IHRoaXMuc25hcHNob3QudG9KU09OKCkgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXRvbWljYWxseSBtb2RpZmllcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBdG9taWNhbGx5IG1vZGlmeSB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uLiBVbmxpa2UgYSBub3JtYWwgYHNldCgpYCwgd2hpY2hcclxuICoganVzdCBvdmVyd3JpdGVzIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgaXRzIHByZXZpb3VzIHZhbHVlLCBgcnVuVHJhbnNhY3Rpb24oKWAgaXNcclxuICogdXNlZCB0byBtb2RpZnkgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIGEgbmV3IHZhbHVlLCBlbnN1cmluZyB0aGVyZSBhcmUgbm9cclxuICogY29uZmxpY3RzIHdpdGggb3RoZXIgY2xpZW50cyB3cml0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAqXHJcbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgeW91IHBhc3MgYHJ1blRyYW5zYWN0aW9uKClgIGFuIHVwZGF0ZSBmdW5jdGlvbiB3aGljaCBpc1xyXG4gKiB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgY3VycmVudCB2YWx1ZSBpbnRvIGEgbmV3IHZhbHVlLiBJZiBhbm90aGVyIGNsaWVudFxyXG4gKiB3cml0ZXMgdG8gdGhlIGxvY2F0aW9uIGJlZm9yZSB5b3VyIG5ldyB2YWx1ZSBpcyBzdWNjZXNzZnVsbHkgd3JpdHRlbiwgeW91clxyXG4gKiB1cGRhdGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aCB0aGUgbmV3IGN1cnJlbnQgdmFsdWUsIGFuZCB0aGVcclxuICogd3JpdGUgd2lsbCBiZSByZXRyaWVkLiBUaGlzIHdpbGwgaGFwcGVuIHJlcGVhdGVkbHkgdW50aWwgeW91ciB3cml0ZSBzdWNjZWVkc1xyXG4gKiB3aXRob3V0IGNvbmZsaWN0IG9yIHlvdSBhYm9ydCB0aGUgdHJhbnNhY3Rpb24gYnkgbm90IHJldHVybmluZyBhIHZhbHVlIGZyb21cclxuICogeW91ciB1cGRhdGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIE5vdGU6IE1vZGlmeWluZyBkYXRhIHdpdGggYHNldCgpYCB3aWxsIGNhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2FjdGlvbnMgYXRcclxuICogdGhhdCBsb2NhdGlvbiwgc28gZXh0cmVtZSBjYXJlIHNob3VsZCBiZSB0YWtlbiBpZiBtaXhpbmcgYHNldCgpYCBhbmRcclxuICogYHJ1blRyYW5zYWN0aW9uKClgIHRvIHVwZGF0ZSB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBOb3RlOiBXaGVuIHVzaW5nIHRyYW5zYWN0aW9ucyB3aXRoIFNlY3VyaXR5IGFuZCBGaXJlYmFzZSBSdWxlcyBpbiBwbGFjZSwgYmVcclxuICogYXdhcmUgdGhhdCBhIGNsaWVudCBuZWVkcyBgLnJlYWRgIGFjY2VzcyBpbiBhZGRpdGlvbiB0byBgLndyaXRlYCBhY2Nlc3MgaW5cclxuICogb3JkZXIgdG8gcGVyZm9ybSBhIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGNsaWVudC1zaWRlIG5hdHVyZSBvZlxyXG4gKiB0cmFuc2FjdGlvbnMgcmVxdWlyZXMgdGhlIGNsaWVudCB0byByZWFkIHRoZSBkYXRhIGluIG9yZGVyIHRvIHRyYW5zYWN0aW9uYWxseVxyXG4gKiB1cGRhdGUgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gYXRvbWljYWxseSBtb2RpZnkuXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblVwZGF0ZSAtIEEgZGV2ZWxvcGVyLXN1cHBsaWVkIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgcGFzc2VkXHJcbiAqIHRoZSBjdXJyZW50IGRhdGEgc3RvcmVkIGF0IHRoaXMgbG9jYXRpb24gKGFzIGEgSmF2YVNjcmlwdCBvYmplY3QpLiBUaGVcclxuICogZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgbmV3IHZhbHVlIGl0IHdvdWxkIGxpa2Ugd3JpdHRlbiAoYXMgYSBKYXZhU2NyaXB0XHJcbiAqIG9iamVjdCkuIElmIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIChpLmUuIHlvdSByZXR1cm4gd2l0aCBubyBhcmd1bWVudHMpIHRoZVxyXG4gKiB0cmFuc2FjdGlvbiB3aWxsIGJlIGFib3J0ZWQgYW5kIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gd2lsbCBub3QgYmVcclxuICogbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIHRyYW5zYWN0aW9ucy5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBjYW4gb3B0aW9uYWxseSBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGBvbkNvbXBsZXRlYFxyXG4gKiBjYWxsYmFjayB0byBoYW5kbGUgc3VjY2VzcyBhbmQgZmFpbHVyZS5cclxuICovXHJcbmZ1bmN0aW9uIHJ1blRyYW5zYWN0aW9uKHJlZiwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbnRyYW5zYWN0aW9uVXBkYXRlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCByZWYuX3BhdGgpO1xyXG4gICAgaWYgKHJlZi5rZXkgPT09ICcubGVuZ3RoJyB8fCByZWYua2V5ID09PSAnLmtleXMnKSB7XHJcbiAgICAgICAgdGhyb3cgKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24gZmFpbGVkOiAnICsgcmVmLmtleSArICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0LicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXBwbHlMb2NhbGx5ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFwcGx5TG9jYWxseSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjb25zdCBwcm9taXNlQ29tcGxldGUgPSAoZXJyb3IsIGNvbW1pdHRlZCwgbm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBkYXRhU25hcHNob3QgPSBudWxsO1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YVNuYXBzaG90ID0gbmV3IERhdGFTbmFwc2hvdChub2RlLCBuZXcgUmVmZXJlbmNlSW1wbChyZWYuX3JlcG8sIHJlZi5fcGF0aCksIFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShuZXcgVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBkYXRhU25hcHNob3QpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQWRkIGEgd2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGdldCBzZXJ2ZXIgdXBkYXRlcy5cclxuICAgIGNvbnN0IHVud2F0Y2hlciA9IG9uVmFsdWUocmVmLCAoKSA9PiB7IH0pO1xyXG4gICAgcmVwb1N0YXJ0VHJhbnNhY3Rpb24ocmVmLl9yZXBvLCByZWYuX3BhdGgsIHRyYW5zYWN0aW9uVXBkYXRlLCBwcm9taXNlQ29tcGxldGUsIHVud2F0Y2hlciwgYXBwbHlMb2NhbGx5KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblBlcnNpc3RlbnRDb25uZWN0aW9uO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2ltcGxlTGlzdGVuID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3EnLCB7IHA6IHBhdGhTdHJpbmcgfSwgb25Db21wbGV0ZSk7XHJcbn07XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcblBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5lY2hvID0gZnVuY3Rpb24gKGRhdGEsIG9uRWNobykge1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCgnZWNobycsIHsgZDogZGF0YSB9LCBvbkVjaG8pO1xyXG59O1xyXG4vLyBSZWFsVGltZUNvbm5lY3Rpb24gcHJvcGVydGllcyB0aGF0IHdlIHVzZSBpbiB0ZXN0cy5cclxuQ29ubmVjdGlvbjtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgaGlqYWNrSGFzaCA9IGZ1bmN0aW9uIChuZXdIYXNoKSB7XHJcbiAgICBjb25zdCBvbGRQdXQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0O1xyXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBoYXNoID0gbmV3SGFzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRQdXQuY2FsbCh0aGlzLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBvbGRQdXQ7XHJcbiAgICB9O1xyXG59O1xyXG5SZXBvSW5mbztcclxuLyoqXHJcbiAqIEZvcmNlcyB0aGUgUmVwb01hbmFnZXIgdG8gY3JlYXRlIFJlcG9zIHRoYXQgdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IGZvcmNlUmVzdENsaWVudCA9IGZ1bmN0aW9uIChmb3JjZVJlc3RDbGllbnQpIHtcclxuICAgIHJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50KGZvcmNlUmVzdENsaWVudCk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnNldFdlYlNvY2tldEltcGwoV2Vic29ja2V0LkNsaWVudCk7XHJcbnJlZ2lzdGVyRGF0YWJhc2UoJ25vZGUnKTtcblxuZXhwb3J0IHsgRGF0YVNuYXBzaG90LCBEYXRhYmFzZSwgT25EaXNjb25uZWN0LCBRdWVyeUNvbnN0cmFpbnQsIFRyYW5zYWN0aW9uUmVzdWx0LCBRdWVyeUltcGwgYXMgX1F1ZXJ5SW1wbCwgUXVlcnlQYXJhbXMgYXMgX1F1ZXJ5UGFyYW1zLCBSZWZlcmVuY2VJbXBsIGFzIF9SZWZlcmVuY2VJbXBsLCBmb3JjZVJlc3RDbGllbnQgYXMgX1RFU1RfQUNDRVNTX2ZvcmNlUmVzdENsaWVudCwgaGlqYWNrSGFzaCBhcyBfVEVTVF9BQ0NFU1NfaGlqYWNrSGFzaCwgcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAgYXMgX3JlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwLCBzZXRTREtWZXJzaW9uIGFzIF9zZXRTREtWZXJzaW9uLCB2YWxpZGF0ZVBhdGhTdHJpbmcgYXMgX3ZhbGlkYXRlUGF0aFN0cmluZywgdmFsaWRhdGVXcml0YWJsZVBhdGggYXMgX3ZhbGlkYXRlV3JpdGFibGVQYXRoLCBjaGlsZCwgY29ubmVjdERhdGFiYXNlRW11bGF0b3IsIGVuYWJsZUxvZ2dpbmcsIGVuZEF0LCBlbmRCZWZvcmUsIGVxdWFsVG8sIGZvcmNlTG9uZ1BvbGxpbmcsIGZvcmNlV2ViU29ja2V0cywgZ2V0LCBnZXREYXRhYmFzZSwgZ29PZmZsaW5lLCBnb09ubGluZSwgaW5jcmVtZW50LCBsaW1pdFRvRmlyc3QsIGxpbWl0VG9MYXN0LCBvZmYsIG9uQ2hpbGRBZGRlZCwgb25DaGlsZENoYW5nZWQsIG9uQ2hpbGRNb3ZlZCwgb25DaGlsZFJlbW92ZWQsIG9uRGlzY29ubmVjdCwgb25WYWx1ZSwgb3JkZXJCeUNoaWxkLCBvcmRlckJ5S2V5LCBvcmRlckJ5UHJpb3JpdHksIG9yZGVyQnlWYWx1ZSwgcHVzaCwgcXVlcnksIHJlZiwgcmVmRnJvbVVSTCwgcmVtb3ZlLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBzZXQsIHNldFByaW9yaXR5LCBzZXRXaXRoUHJpb3JpdHksIHN0YXJ0QWZ0ZXIsIHN0YXJ0QXQsIHVwZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiV2Vic29ja2V0Iiwic3RyaW5naWZ5IiwianNvbkV2YWwiLCJjb250YWlucyIsImFzc2VydCIsImlzTm9kZVNkayIsInN0cmluZ1RvQnl0ZUFycmF5IiwiU2hhMSIsImJhc2U2NCIsImRlZXBDb3B5IiwiYmFzZTY0RW5jb2RlIiwiaXNNb2JpbGVDb3Jkb3ZhIiwic3RyaW5nTGVuZ3RoIiwiRGVmZXJyZWQiLCJzYWZlR2V0IiwiaXNBZG1pbiIsImlzVmFsaWRGb3JtYXQiLCJpc0VtcHR5IiwiaXNSZWFjdE5hdGl2ZSIsImFzc2VydGlvbkVycm9yIiwibWFwIiwicXVlcnlzdHJpbmciLCJlcnJvclByZWZpeCIsImdldE1vZHVsYXJJbnN0YW5jZSIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImNyZWF0ZU1vY2tVc2VyVG9rZW4iLCJMb2dnZXIiLCJMb2dMZXZlbCIsIl9nZXRQcm92aWRlciIsImdldEFwcCIsIlNES19WRVJTSU9OIiwiU0RLX1ZFUlNJT04kMSIsIl9yZWdpc3RlckNvbXBvbmVudCIsInJlZ2lzdGVyVmVyc2lvbiIsIkNvbXBvbmVudCIsIlBST1RPQ09MX1ZFUlNJT04iLCJWRVJTSU9OX1BBUkFNIiwiVFJBTlNQT1JUX1NFU1NJT05fUEFSQU0iLCJSRUZFUkVSX1BBUkFNIiwiRk9SR0VfUkVGIiwiRk9SR0VfRE9NQUlOX1JFIiwiTEFTVF9TRVNTSU9OX1BBUkFNIiwiQVBQTElDQVRJT05fSURfUEFSQU0iLCJBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0iLCJXRUJTT0NLRVQiLCJMT05HX1BPTExJTkciLCJET01TdG9yYWdlV3JhcHBlciIsImNvbnN0cnVjdG9yIiwiZG9tU3RvcmFnZV8iLCJwcmVmaXhfIiwic2V0Iiwia2V5IiwidmFsdWUiLCJyZW1vdmVJdGVtIiwicHJlZml4ZWROYW1lXyIsInNldEl0ZW0iLCJnZXQiLCJzdG9yZWRWYWwiLCJnZXRJdGVtIiwicmVtb3ZlIiwibmFtZSIsInRvU3RyaW5nIiwiTWVtb3J5U3RvcmFnZSIsImNhY2hlXyIsImlzSW5NZW1vcnlTdG9yYWdlIiwiY3JlYXRlU3RvcmFnZWZvciIsImRvbVN0b3JhZ2VOYW1lIiwid2luZG93IiwiZG9tU3RvcmFnZSIsImUiLCJQZXJzaXN0ZW50U3RvcmFnZSIsIlNlc3Npb25TdG9yYWdlIiwibG9nQ2xpZW50IiwiTFVJREdlbmVyYXRvciIsImlkIiwic2hhMSIsInN0ciIsInV0ZjhCeXRlcyIsInVwZGF0ZSIsInNoYTFCeXRlcyIsImRpZ2VzdCIsImVuY29kZUJ5dGVBcnJheSIsImJ1aWxkTG9nTWVzc2FnZV8iLCJ2YXJBcmdzIiwibWVzc2FnZSIsImkiLCJsZW5ndGgiLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJhcHBseSIsImxvZ2dlciIsImZpcnN0TG9nXyIsImVuYWJsZUxvZ2dpbmckMSIsImxvZ2dlcl8iLCJwZXJzaXN0ZW50IiwibG9nTGV2ZWwiLCJWRVJCT1NFIiwibG9nIiwiYmluZCIsImxvZ1dyYXBwZXIiLCJwcmVmaXgiLCJlcnJvciIsImZhdGFsIiwiRXJyb3IiLCJ3YXJuIiwid2FybklmUGFnZUlzU2VjdXJlIiwibG9jYXRpb24iLCJwcm90b2NvbCIsImluZGV4T2YiLCJpc0ludmFsaWRKU09OTnVtYmVyIiwiZGF0YSIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJleGVjdXRlV2hlbkRPTVJlYWR5IiwiZm4iLCJkb2N1bWVudCIsInJlYWR5U3RhdGUiLCJjYWxsZWQiLCJ3cmFwcGVkRm4iLCJib2R5Iiwic2V0VGltZW91dCIsIk1hdGgiLCJmbG9vciIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsIk1JTl9OQU1FIiwiTUFYX05BTUUiLCJuYW1lQ29tcGFyZSIsImEiLCJiIiwiYUFzSW50IiwidHJ5UGFyc2VJbnQiLCJiQXNJbnQiLCJzdHJpbmdDb21wYXJlIiwicmVxdWlyZUtleSIsIm9iaiIsIk9iamVjdFRvVW5pcXVlS2V5Iiwia2V5cyIsImsiLCJwdXNoIiwic29ydCIsInNwbGl0U3RyaW5nQnlTaXplIiwic2Vnc2l6ZSIsImxlbiIsImRhdGFTZWdzIiwiYyIsInN1YnN0cmluZyIsImVhY2giLCJoYXNPd25Qcm9wZXJ0eSIsImRvdWJsZVRvSUVFRTc1NFN0cmluZyIsInYiLCJlYml0cyIsImZiaXRzIiwiYmlhcyIsInMiLCJmIiwibG4iLCJJbmZpbml0eSIsImFicyIsInBvdyIsIm1pbiIsIkxOMiIsInJvdW5kIiwiYml0cyIsInJldmVyc2UiLCJqb2luIiwiaGV4Qnl0ZVN0cmluZyIsImhleEJ5dGUiLCJwYXJzZUludCIsInN1YnN0ciIsInRvTG93ZXJDYXNlIiwiaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0IiwidGVzdCIsImhyZWYiLCJpc1dpbmRvd3NTdG9yZUFwcCIsIldpbmRvd3MiLCJVSSIsImVycm9yRm9yU2VydmVyQ29kZSIsImNvZGUiLCJxdWVyeSIsInJlYXNvbiIsIl9wYXRoIiwidG9VcHBlckNhc2UiLCJJTlRFR0VSX1JFR0VYUF8iLCJSZWdFeHAiLCJJTlRFR0VSXzMyX01JTiIsIklOVEVHRVJfMzJfTUFYIiwiaW50VmFsIiwiZXhjZXB0aW9uR3VhcmQiLCJzdGFjayIsImJlaW5nQ3Jhd2xlZCIsInVzZXJBZ2VudCIsInNlYXJjaCIsInNldFRpbWVvdXROb25CbG9ja2luZyIsInRpbWUiLCJ0aW1lb3V0IiwiRGVubyIsInVucmVmVGltZXIiLCJSZXBvSW5mbyIsImhvc3QiLCJzZWN1cmUiLCJuYW1lc3BhY2UiLCJ3ZWJTb2NrZXRPbmx5Iiwibm9kZUFkbWluIiwicGVyc2lzdGVuY2VLZXkiLCJpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyIsImlzVXNpbmdFbXVsYXRvciIsIl9ob3N0IiwiX2RvbWFpbiIsImludGVybmFsSG9zdCIsImlzQ2FjaGVhYmxlSG9zdCIsImlzQ3VzdG9tSG9zdCIsIm5ld0hvc3QiLCJ0b1VSTFN0cmluZyIsInJlcG9JbmZvTmVlZHNRdWVyeVBhcmFtIiwicmVwb0luZm8iLCJyZXBvSW5mb0Nvbm5lY3Rpb25VUkwiLCJ0eXBlIiwicGFyYW1zIiwiY29ublVSTCIsInBhaXJzIiwiU3RhdHNDb2xsZWN0aW9uIiwiY291bnRlcnNfIiwiaW5jcmVtZW50Q291bnRlciIsImFtb3VudCIsImNvbGxlY3Rpb25zIiwicmVwb3J0ZXJzIiwic3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbiIsImhhc2hTdHJpbmciLCJzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyIiwiY3JlYXRvckZ1bmN0aW9uIiwic2V0U0RLVmVyc2lvbiIsInZlcnNpb24iLCJXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUiLCJXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMIiwiV2ViU29ja2V0SW1wbCIsIk1veldlYlNvY2tldCIsIldlYlNvY2tldCIsInNldFdlYlNvY2tldEltcGwiLCJpbXBsIiwiV2ViU29ja2V0Q29ubmVjdGlvbiIsImNvbm5JZCIsImFwcGxpY2F0aW9uSWQiLCJhcHBDaGVja1Rva2VuIiwiYXV0aFRva2VuIiwidHJhbnNwb3J0U2Vzc2lvbklkIiwibGFzdFNlc3Npb25JZCIsImtlZXBhbGl2ZVRpbWVyIiwiZnJhbWVzIiwidG90YWxGcmFtZXMiLCJieXRlc1NlbnQiLCJieXRlc1JlY2VpdmVkIiwibG9nXyIsInN0YXRzXyIsImNvbm5lY3Rpb25VUkxfIiwidXJsUGFyYW1zIiwiaG9zdG5hbWUiLCJvcGVuIiwib25NZXNzYWdlIiwib25EaXNjb25uZWN0IiwiZXZlckNvbm5lY3RlZF8iLCJvcHRpb25zIiwiZGV2aWNlIiwiaGVhZGVycyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImVudiIsInByb3h5Iiwib3JpZ2luIiwibXlTb2NrIiwib25DbG9zZWRfIiwib25vcGVuIiwib25jbG9zZSIsIm9ubWVzc2FnZSIsIm0iLCJoYW5kbGVJbmNvbWluZ0ZyYW1lIiwib25lcnJvciIsInN0YXJ0IiwiZm9yY2VEaXNhbGxvdyIsImZvcmNlRGlzYWxsb3dfIiwiaXNBdmFpbGFibGUiLCJpc09sZEFuZHJvaWQiLCJuYXZpZ2F0b3IiLCJvbGRBbmRyb2lkUmVnZXgiLCJvbGRBbmRyb2lkTWF0Y2giLCJtYXRjaCIsInBhcnNlRmxvYXQiLCJwcmV2aW91c2x5RmFpbGVkIiwibWFya0Nvbm5lY3Rpb25IZWFsdGh5IiwiYXBwZW5kRnJhbWVfIiwiZnVsbE1lc3MiLCJqc29uTWVzcyIsImhhbmRsZU5ld0ZyYW1lQ291bnRfIiwiZnJhbWVDb3VudCIsImV4dHJhY3RGcmFtZUNvdW50XyIsImlzTmFOIiwibWVzcyIsInJlc2V0S2VlcEFsaXZlIiwicmVtYWluaW5nRGF0YSIsInNlbmQiLCJkYXRhU3RyIiwic2VuZFN0cmluZ18iLCJTdHJpbmciLCJzaHV0ZG93bl8iLCJpc0Nsb3NlZF8iLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJzZXRJbnRlcnZhbCIsInJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHkiLCJoZWFsdGh5VGltZW91dCIsIkFwcENoZWNrVG9rZW5Qcm92aWRlciIsImFwcE5hbWVfIiwiYXBwQ2hlY2tQcm92aWRlciIsImFwcENoZWNrIiwiZ2V0SW1tZWRpYXRlIiwib3B0aW9uYWwiLCJ0aGVuIiwiZ2V0VG9rZW4iLCJmb3JjZVJlZnJlc2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZFRva2VuQ2hhbmdlTGlzdGVuZXIiLCJsaXN0ZW5lciIsIl9hIiwiYWRkVG9rZW5MaXN0ZW5lciIsIm5vdGlmeUZvckludmFsaWRUb2tlbiIsIkZpcmViYXNlQXV0aFRva2VuUHJvdmlkZXIiLCJmaXJlYmFzZU9wdGlvbnNfIiwiYXV0aFByb3ZpZGVyXyIsImF1dGhfIiwib25Jbml0IiwiYXV0aCIsImNhdGNoIiwiYWRkQXV0aFRva2VuTGlzdGVuZXIiLCJyZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyIiwicmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIiLCJlcnJvck1lc3NhZ2UiLCJFbXVsYXRvclRva2VuUHJvdmlkZXIiLCJhY2Nlc3NUb2tlbiIsIk9XTkVSIiwiUGFja2V0UmVjZWl2ZXIiLCJvbk1lc3NhZ2VfIiwicGVuZGluZ1Jlc3BvbnNlcyIsImN1cnJlbnRSZXNwb25zZU51bSIsImNsb3NlQWZ0ZXJSZXNwb25zZSIsIm9uQ2xvc2UiLCJjbG9zZUFmdGVyIiwicmVzcG9uc2VOdW0iLCJjYWxsYmFjayIsImhhbmRsZVJlc3BvbnNlIiwicmVxdWVzdE51bSIsInRvUHJvY2VzcyIsIkZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCIsIkZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSIsIkZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSIsIkZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9DQUxMQkFDS19JRF9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUIiwiRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTSIsIk1BWF9VUkxfREFUQV9TSVpFIiwiU0VHX0hFQURFUl9TSVpFIiwiTUFYX1BBWUxPQURfU0laRSIsIktFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMIiwiTFBfQ09OTkVDVF9USU1FT1VUIiwiQnJvd3NlclBvbGxDb25uZWN0aW9uIiwidXJsRm4iLCJjdXJTZWdtZW50TnVtIiwib25EaXNjb25uZWN0XyIsIm15UGFja2V0T3JkZXJlciIsImNvbm5lY3RUaW1lb3V0VGltZXJfIiwic2NyaXB0VGFnSG9sZGVyIiwiRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIiLCJhcmdzIiwiY29tbWFuZCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJpbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyIsImNsZWFyVGltZW91dCIsInBhc3N3b3JkIiwic2VuZE5ld1BvbGxzIiwicE4iLCJyYW5kb20iLCJ1bmlxdWVDYWxsYmFja0lkZW50aWZpZXIiLCJjb25uZWN0VVJMIiwiYWRkVGFnIiwic3RhcnRMb25nUG9sbCIsImFkZERpc2Nvbm5lY3RQaW5nRnJhbWUiLCJmb3JjZUFsbG93IiwiZm9yY2VBbGxvd18iLCJjcmVhdGVFbGVtZW50IiwibXlEaXNjb25uRnJhbWUiLCJyZW1vdmVDaGlsZCIsImJhc2U2NGRhdGEiLCJlbnF1ZXVlU2VnbWVudCIsInB3Iiwic3JjIiwic3R5bGUiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJjb21tYW5kQ0IiLCJvbk1lc3NhZ2VDQiIsIm91dHN0YW5kaW5nUmVxdWVzdHMiLCJTZXQiLCJwZW5kaW5nU2VncyIsImN1cnJlbnRTZXJpYWwiLCJteUlGcmFtZSIsImNyZWF0ZUlGcmFtZV8iLCJzY3JpcHQiLCJjdXJyZW50RG9tYWluIiwiZG9tYWluIiwiaWZyYW1lQ29udGVudHMiLCJkb2MiLCJ3cml0ZSIsImlmcmFtZSIsImNvbnRlbnRXaW5kb3ciLCJjb250ZW50RG9jdW1lbnQiLCJhbGl2ZSIsInRleHRDb250ZW50IiwibXlJRCIsIm15UFciLCJuZXdSZXF1ZXN0XyIsInNpemUiLCJ0aGVVUkwiLCJjdXJEYXRhU3RyaW5nIiwibmV4dFNlZyIsImQiLCJ0aGVTZWciLCJzaGlmdCIsInNlZyIsInRzIiwiYWRkTG9uZ1BvbGxUYWdfIiwic2VnbnVtIiwidG90YWxzZWdzIiwidXJsIiwic2VyaWFsIiwiYWRkIiwiZG9OZXdSZXF1ZXN0IiwiZGVsZXRlIiwia2VlcGFsaXZlVGltZW91dCIsInJlYWR5U3RhdGVDQiIsImxvYWRDQiIsImRvTm9kZUxvbmdQb2xsIiwibmV3U2NyaXB0IiwiYXN5bmMiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyc3RhdGUiLCJwYXJlbnROb2RlIiwiVHJhbnNwb3J0TWFuYWdlciIsImluaXRUcmFuc3BvcnRzXyIsIkFMTF9UUkFOU1BPUlRTIiwiSVNfVFJBTlNQT1JUX0lOSVRJQUxJWkVEIiwiZ2xvYmFsVHJhbnNwb3J0SW5pdGlhbGl6ZWRfIiwiaXNXZWJTb2NrZXRzQXZhaWxhYmxlIiwiaXNTa2lwUG9sbENvbm5lY3Rpb24iLCJ0cmFuc3BvcnRzXyIsInRyYW5zcG9ydHMiLCJ0cmFuc3BvcnQiLCJpbml0aWFsVHJhbnNwb3J0IiwidXBncmFkZVRyYW5zcG9ydCIsIlVQR1JBREVfVElNRU9VVCIsIkRFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTIiwiQllURVNfU0VOVF9IRUFMVEhZX09WRVJSSURFIiwiQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSIsIk1FU1NBR0VfVFlQRSIsIk1FU1NBR0VfREFUQSIsIkNPTlRST0xfU0hVVERPV04iLCJDT05UUk9MX1JFU0VUIiwiQ09OVFJPTF9FUlJPUiIsIkNPTlRST0xfUE9ORyIsIlNXSVRDSF9BQ0siLCJFTkRfVFJBTlNNSVNTSU9OIiwiUElORyIsIlNFUlZFUl9IRUxMTyIsIkNvbm5lY3Rpb24iLCJyZXBvSW5mb18iLCJhcHBsaWNhdGlvbklkXyIsImFwcENoZWNrVG9rZW5fIiwiYXV0aFRva2VuXyIsIm9uUmVhZHlfIiwib25LaWxsXyIsImNvbm5lY3Rpb25Db3VudCIsInBlbmRpbmdEYXRhTWVzc2FnZXMiLCJzdGF0ZV8iLCJ0cmFuc3BvcnRNYW5hZ2VyXyIsInN0YXJ0XyIsImNvbm4iLCJjb25uXyIsIm5leHRUcmFuc3BvcnRJZF8iLCJwcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIiwib25NZXNzYWdlUmVjZWl2ZWQiLCJjb25uUmVjZWl2ZXJfIiwib25Db25uZWN0aW9uTG9zdCIsImRpc2Nvbm5SZWNlaXZlcl8iLCJ0eF8iLCJyeF8iLCJzZWNvbmRhcnlDb25uXyIsImlzSGVhbHRoeV8iLCJoZWFsdGh5VGltZW91dE1TIiwiaGVhbHRoeVRpbWVvdXRfIiwiZXZlckNvbm5lY3RlZCIsIm9uQ29ubmVjdGlvbkxvc3RfIiwib25TZWNvbmRhcnlDb25uZWN0aW9uTG9zdF8iLCJvblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfIiwib25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfIiwic2VuZFJlcXVlc3QiLCJkYXRhTXNnIiwibXNnIiwidCIsInNlbmREYXRhXyIsInRyeUNsZWFudXBDb25uZWN0aW9uIiwib25TZWNvbmRhcnlDb250cm9sXyIsImNvbnRyb2xEYXRhIiwiY21kIiwidXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8iLCJzZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8iLCJwYXJzZWREYXRhIiwibGF5ZXIiLCJwcm9jZWVkV2l0aFVwZ3JhZGVfIiwib25Db250cm9sXyIsIm9uRGF0YU1lc3NhZ2VfIiwib25QcmltYXJ5UmVzcG9uc2VfIiwicGF5bG9hZCIsImhhbmRzaGFrZVBheWxvYWQiLCJPYmplY3QiLCJhc3NpZ24iLCJoIiwib25IYW5kc2hha2VfIiwib25Db25uZWN0aW9uU2h1dGRvd25fIiwib25SZXNldF8iLCJzZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XyIsImhhbmRzaGFrZSIsInRpbWVzdGFtcCIsInNlc3Npb25JZCIsIm9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyIsInRyeVN0YXJ0VXBncmFkZV8iLCJzdGFydFVwZ3JhZGVfIiwiY2xvc2VDb25uZWN0aW9uc18iLCJTZXJ2ZXJBY3Rpb25zIiwicHV0IiwicGF0aFN0cmluZyIsIm9uQ29tcGxldGUiLCJoYXNoIiwibWVyZ2UiLCJyZWZyZXNoQXV0aFRva2VuIiwidG9rZW4iLCJyZWZyZXNoQXBwQ2hlY2tUb2tlbiIsIm9uRGlzY29ubmVjdFB1dCIsIm9uRGlzY29ubmVjdE1lcmdlIiwib25EaXNjb25uZWN0Q2FuY2VsIiwicmVwb3J0U3RhdHMiLCJzdGF0cyIsIkV2ZW50RW1pdHRlciIsImFsbG93ZWRFdmVudHNfIiwibGlzdGVuZXJzXyIsInRyaWdnZXIiLCJldmVudFR5cGUiLCJsaXN0ZW5lcnMiLCJjb250ZXh0Iiwib24iLCJ2YWxpZGF0ZUV2ZW50VHlwZV8iLCJldmVudERhdGEiLCJnZXRJbml0aWFsRXZlbnQiLCJvZmYiLCJzcGxpY2UiLCJmaW5kIiwiZXQiLCJPbmxpbmVNb25pdG9yIiwib25saW5lXyIsImdldEluc3RhbmNlIiwiY3VycmVudGx5T25saW5lIiwiTUFYX1BBVEhfREVQVEgiLCJNQVhfUEFUSF9MRU5HVEhfQllURVMiLCJQYXRoIiwicGF0aE9yU3RyaW5nIiwicGllY2VOdW0iLCJwaWVjZXNfIiwic3BsaXQiLCJjb3B5VG8iLCJwaWVjZU51bV8iLCJuZXdFbXB0eVBhdGgiLCJwYXRoR2V0RnJvbnQiLCJwYXRoIiwicGF0aEdldExlbmd0aCIsInBhdGhQb3BGcm9udCIsInBhdGhHZXRCYWNrIiwicGF0aFRvVXJsRW5jb2RlZFN0cmluZyIsImVuY29kZVVSSUNvbXBvbmVudCIsInBhdGhTbGljZSIsImJlZ2luIiwic2xpY2UiLCJwYXRoUGFyZW50IiwicGllY2VzIiwicGF0aENoaWxkIiwiY2hpbGRQYXRoT2JqIiwiY2hpbGRQaWVjZXMiLCJwYXRoSXNFbXB0eSIsIm5ld1JlbGF0aXZlUGF0aCIsIm91dGVyUGF0aCIsImlubmVyUGF0aCIsIm91dGVyIiwiaW5uZXIiLCJwYXRoQ29tcGFyZSIsImxlZnQiLCJyaWdodCIsImxlZnRLZXlzIiwicmlnaHRLZXlzIiwiY21wIiwicGF0aEVxdWFscyIsIm90aGVyIiwiaiIsInBhdGhDb250YWlucyIsIlZhbGlkYXRpb25QYXRoIiwiZXJyb3JQcmVmaXhfIiwicGFydHNfIiwiYnl0ZUxlbmd0aF8iLCJtYXgiLCJ2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQiLCJ2YWxpZGF0aW9uUGF0aFB1c2giLCJ2YWxpZGF0aW9uUGF0aCIsImNoaWxkIiwidmFsaWRhdGlvblBhdGhQb3AiLCJsYXN0IiwicG9wIiwidmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nIiwiVmlzaWJpbGl0eU1vbml0b3IiLCJoaWRkZW4iLCJ2aXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJsZV8iLCJ2aXNpYmxlIiwiUkVDT05ORUNUX01JTl9ERUxBWSIsIlJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVCIsIlJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUyIsIlJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSIiwiUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQiLCJTRVJWRVJfS0lMTF9JTlRFUlJVUFRfUkVBU09OIiwiSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQiLCJQZXJzaXN0ZW50Q29ubmVjdGlvbiIsIm9uRGF0YVVwZGF0ZV8iLCJvbkNvbm5lY3RTdGF0dXNfIiwib25TZXJ2ZXJJbmZvVXBkYXRlXyIsImF1dGhUb2tlblByb3ZpZGVyXyIsImFwcENoZWNrVG9rZW5Qcm92aWRlcl8iLCJhdXRoT3ZlcnJpZGVfIiwibmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfIiwiaW50ZXJydXB0UmVhc29uc18iLCJsaXN0ZW5zIiwiTWFwIiwib3V0c3RhbmRpbmdQdXRzXyIsIm91dHN0YW5kaW5nR2V0c18iLCJvdXRzdGFuZGluZ1B1dENvdW50XyIsIm91dHN0YW5kaW5nR2V0Q291bnRfIiwib25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyIsImNvbm5lY3RlZF8iLCJyZWNvbm5lY3REZWxheV8iLCJtYXhSZWNvbm5lY3REZWxheV8iLCJzZWN1cml0eURlYnVnQ2FsbGJhY2tfIiwiZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyIsInJlcXVlc3RDQkhhc2hfIiwicmVxdWVzdE51bWJlcl8iLCJyZWFsdGltZV8iLCJmb3JjZVRva2VuUmVmcmVzaF8iLCJpbnZhbGlkQXV0aFRva2VuQ291bnRfIiwiaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8iLCJmaXJzdENvbm5lY3Rpb25fIiwibGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8iLCJsYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8iLCJvblZpc2libGVfIiwib25PbmxpbmVfIiwiYWN0aW9uIiwib25SZXNwb25zZSIsImN1clJlcU51bSIsInIiLCJpbml0Q29ubmVjdGlvbl8iLCJkZWZlcnJlZCIsInJlcXVlc3QiLCJwIiwicSIsIl9xdWVyeU9iamVjdCIsIm91dHN0YW5kaW5nR2V0IiwiaW5kZXgiLCJzZW5kR2V0XyIsInByb21pc2UiLCJsaXN0ZW4iLCJjdXJyZW50SGFzaEZuIiwidGFnIiwicXVlcnlJZCIsIl9xdWVyeUlkZW50aWZpZXIiLCJoYXMiLCJfcXVlcnlQYXJhbXMiLCJpc0RlZmF1bHQiLCJsb2Fkc0FsbERhdGEiLCJsaXN0ZW5TcGVjIiwiaGFzaEZuIiwic2VuZExpc3Rlbl8iLCJyZXEiLCJzdGF0dXMiLCJ3YXJuT25MaXN0ZW5XYXJuaW5nc18iLCJjdXJyZW50TGlzdGVuU3BlYyIsInJlbW92ZUxpc3Rlbl8iLCJ3YXJuaW5ncyIsImluZGV4U3BlYyIsImdldEluZGV4IiwiaW5kZXhQYXRoIiwidHJ5QXV0aCIsInJlZHVjZVJlY29ubmVjdERlbGF5SWZBZG1pbkNyZWRlbnRpYWxfIiwiY3JlZGVudGlhbCIsImlzRmlyZWJhc2VTZWNyZXQiLCJ0cnlBcHBDaGVjayIsImF1dGhNZXRob2QiLCJyZXF1ZXN0RGF0YSIsImNyZWQiLCJyZXMiLCJvbkF1dGhSZXZva2VkXyIsIm9uQXBwQ2hlY2tSZXZva2VkXyIsInVubGlzdGVuIiwic2VuZFVubGlzdGVuXyIsInF1ZXJ5T2JqIiwic2VuZE9uRGlzY29ubmVjdF8iLCJyZXNwb25zZSIsInB1dEludGVybmFsIiwidW5kZWZpbmVkIiwic2VuZFB1dF8iLCJxdWV1ZWQiLCJyZXN1bHQiLCJlcnJvclJlYXNvbiIsInJlcU51bSIsIm9uRGF0YVB1c2hfIiwib25MaXN0ZW5SZXZva2VkXyIsIm9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8iLCJEYXRlIiwiZ2V0VGltZSIsImhhbmRsZVRpbWVzdGFtcF8iLCJzZW5kQ29ubmVjdFN0YXRzXyIsInJlc3RvcmVTdGF0ZV8iLCJzY2hlZHVsZUNvbm5lY3RfIiwiZXN0YWJsaXNoQ29ubmVjdGlvbl8iLCJvbmxpbmUiLCJvblJlYWx0aW1lRGlzY29ubmVjdF8iLCJjYW5jZWxTZW50VHJhbnNhY3Rpb25zXyIsInNob3VsZFJlY29ubmVjdF8iLCJ0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCIsInRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCIsInJlY29ubmVjdERlbGF5Iiwib25EYXRhTWVzc2FnZSIsIm9uUmVhZHkiLCJuZXh0Q29ubmVjdGlvbklkXyIsImNhbmNlbGVkIiwiY29ubmVjdGlvbiIsImNsb3NlRm4iLCJzZW5kUmVxdWVzdEZuIiwiYWxsIiwiaW50ZXJydXB0IiwicmVzdW1lIiwiZGVsdGEiLCJzZXJ2ZXJUaW1lT2Zmc2V0Iiwibm9ybWFsaXplZFBhdGhTdHJpbmciLCJzdGF0dXNDb2RlIiwiZXhwbGFuYXRpb24iLCJjb25zb2xlIiwicmVwbGFjZSIsInF1ZXJpZXMiLCJ2YWx1ZXMiLCJjbGllbnROYW1lIiwiTmFtZWROb2RlIiwibm9kZSIsIldyYXAiLCJJbmRleCIsImdldENvbXBhcmUiLCJjb21wYXJlIiwiaW5kZXhlZFZhbHVlQ2hhbmdlZCIsIm9sZE5vZGUiLCJuZXdOb2RlIiwib2xkV3JhcHBlZCIsIm5ld1dyYXBwZWQiLCJtaW5Qb3N0IiwiTUlOIiwiX19FTVBUWV9OT0RFIiwiS2V5SW5kZXgiLCJ2YWwiLCJpc0RlZmluZWRPbiIsIm1heFBvc3QiLCJtYWtlUG9zdCIsImluZGV4VmFsdWUiLCJLRVlfSU5ERVgiLCJTb3J0ZWRNYXBJdGVyYXRvciIsInN0YXJ0S2V5IiwiY29tcGFyYXRvciIsImlzUmV2ZXJzZV8iLCJyZXN1bHRHZW5lcmF0b3JfIiwibm9kZVN0YWNrXyIsImdldE5leHQiLCJoYXNOZXh0IiwicGVlayIsIkxMUkJOb2RlIiwiY29sb3IiLCJSRUQiLCJTb3J0ZWRNYXAiLCJFTVBUWV9OT0RFIiwiY29weSIsImNvdW50IiwiaW5vcmRlclRyYXZlcnNhbCIsInJldmVyc2VUcmF2ZXJzYWwiLCJtaW5fIiwibWluS2V5IiwibWF4S2V5IiwiaW5zZXJ0IiwibiIsImZpeFVwXyIsInJlbW92ZU1pbl8iLCJpc1JlZF8iLCJtb3ZlUmVkTGVmdF8iLCJzbWFsbGVzdCIsInJvdGF0ZVJpZ2h0XyIsIm1vdmVSZWRSaWdodF8iLCJyb3RhdGVMZWZ0XyIsImNvbG9yRmxpcF8iLCJubCIsIm5yIiwiY2hlY2tNYXhEZXB0aF8iLCJibGFja0RlcHRoIiwiY2hlY2tfIiwiQkxBQ0siLCJMTFJCRW1wdHlOb2RlIiwiY29tcGFyYXRvcl8iLCJyb290XyIsImdldFByZWRlY2Vzc29yS2V5IiwicmlnaHRQYXJlbnQiLCJnZXRJdGVyYXRvciIsInJlc3VsdEdlbmVyYXRvciIsImdldEl0ZXJhdG9yRnJvbSIsImdldFJldmVyc2VJdGVyYXRvckZyb20iLCJnZXRSZXZlcnNlSXRlcmF0b3IiLCJOQU1FX09OTFlfQ09NUEFSQVRPUiIsIk5BTUVfQ09NUEFSQVRPUiIsIk1BWF9OT0RFJDIiLCJzZXRNYXhOb2RlJDEiLCJwcmlvcml0eUhhc2hUZXh0IiwicHJpb3JpdHkiLCJ2YWxpZGF0ZVByaW9yaXR5Tm9kZSIsInByaW9yaXR5Tm9kZSIsImlzTGVhZk5vZGUiLCJnZXRQcmlvcml0eSIsIl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IiLCJMZWFmTm9kZSIsInZhbHVlXyIsInByaW9yaXR5Tm9kZV8iLCJsYXp5SGFzaF8iLCJ1cGRhdGVQcmlvcml0eSIsIm5ld1ByaW9yaXR5Tm9kZSIsImdldEltbWVkaWF0ZUNoaWxkIiwiY2hpbGROYW1lIiwiZ2V0Q2hpbGQiLCJoYXNDaGlsZCIsImdldFByZWRlY2Vzc29yQ2hpbGROYW1lIiwiY2hpbGROb2RlIiwidXBkYXRlSW1tZWRpYXRlQ2hpbGQiLCJuZXdDaGlsZE5vZGUiLCJ1cGRhdGVDaGlsZCIsImZyb250IiwibnVtQ2hpbGRyZW4iLCJmb3JFYWNoQ2hpbGQiLCJleHBvcnRGb3JtYXQiLCJnZXRWYWx1ZSIsInRvSGFzaCIsImNvbXBhcmVUbyIsImNvbXBhcmVUb0xlYWZOb2RlXyIsIm90aGVyTGVhZiIsIm90aGVyTGVhZlR5cGUiLCJ0aGlzTGVhZlR5cGUiLCJvdGhlckluZGV4IiwiVkFMVUVfVFlQRV9PUkRFUiIsInRoaXNJbmRleCIsIndpdGhJbmRleCIsImlzSW5kZXhlZCIsImVxdWFscyIsIm5vZGVGcm9tSlNPTiQxIiwiTUFYX05PREUkMSIsInNldE5vZGVGcm9tSlNPTiIsInNldE1heE5vZGUiLCJQcmlvcml0eUluZGV4IiwiYVByaW9yaXR5IiwiYlByaW9yaXR5IiwiaW5kZXhDbXAiLCJQUklPUklUWV9JTkRFWCIsIkxPR18yIiwiQmFzZTEyTnVtIiwibG9nQmFzZTIiLCJudW0iLCJiaXRNYXNrIiwiY3VycmVudF8iLCJtYXNrIiwiYml0c18iLCJuZXh0Qml0SXNPbmUiLCJidWlsZENoaWxkU2V0IiwiY2hpbGRMaXN0Iiwia2V5Rm4iLCJtYXBTb3J0Rm4iLCJidWlsZEJhbGFuY2VkVHJlZSIsImxvdyIsImhpZ2giLCJuYW1lZE5vZGUiLCJtaWRkbGUiLCJidWlsZEZyb20xMkFycmF5IiwiYmFzZTEyIiwicm9vdCIsImJ1aWxkUGVubmFudCIsImNodW5rU2l6ZSIsImNoaWxkVHJlZSIsImF0dGFjaFBlbm5hbnQiLCJwZW5uYW50IiwiaXNPbmUiLCJfZGVmYXVsdEluZGV4TWFwIiwiZmFsbGJhY2tPYmplY3QiLCJJbmRleE1hcCIsImluZGV4ZXNfIiwiaW5kZXhTZXRfIiwiRGVmYXVsdCIsImluZGV4S2V5Iiwic29ydGVkTWFwIiwiaGFzSW5kZXgiLCJpbmRleERlZmluaXRpb24iLCJhZGRJbmRleCIsImV4aXN0aW5nQ2hpbGRyZW4iLCJzYXdJbmRleGVkVmFsdWUiLCJpdGVyIiwibmV4dCIsIm5ld0luZGV4IiwiaW5kZXhOYW1lIiwibmV3SW5kZXhTZXQiLCJuZXdJbmRleGVzIiwiYWRkVG9JbmRleGVzIiwiaW5kZXhlZENoaWxkcmVuIiwiZXhpc3RpbmdTbmFwIiwibmV3Q2hpbGRyZW4iLCJyZW1vdmVGcm9tSW5kZXhlcyIsIkNoaWxkcmVuTm9kZSIsImNoaWxkcmVuXyIsImluZGV4TWFwXyIsIm5ld0luZGV4TWFwIiwibmV3UHJpb3JpdHkiLCJuZXdJbW1lZGlhdGVDaGlsZCIsIm51bUtleXMiLCJhbGxJbnRlZ2VyS2V5cyIsImFycmF5IiwiY2hpbGRIYXNoIiwiaWR4IiwicmVzb2x2ZUluZGV4XyIsInByZWRlY2Vzc29yIiwiZ2V0Rmlyc3RDaGlsZE5hbWUiLCJnZXRGaXJzdENoaWxkIiwiZ2V0TGFzdENoaWxkTmFtZSIsImdldExhc3RDaGlsZCIsIndyYXBwZWROb2RlIiwic3RhcnRQb3N0IiwiaXRlcmF0b3IiLCJlbmRQb3N0IiwiTUFYX05PREUiLCJvdGhlckNoaWxkcmVuTm9kZSIsInRoaXNJdGVyIiwib3RoZXJJdGVyIiwidGhpc0N1cnJlbnQiLCJvdGhlckN1cnJlbnQiLCJNYXhOb2RlIiwiZGVmaW5lUHJvcGVydGllcyIsIk1BWCIsIlVTRV9ISU5aRSIsIm5vZGVGcm9tSlNPTiIsImpzb24iLCJqc29uTGVhZiIsImNoaWxkcmVuIiwiY2hpbGRyZW5IYXZlUHJpb3JpdHkiLCJoaW56ZUpzb25PYmoiLCJjaGlsZFNldCIsInNvcnRlZENoaWxkU2V0IiwiY2hpbGREYXRhIiwiUGF0aEluZGV4IiwiaW5kZXhQYXRoXyIsImV4dHJhY3RDaGlsZCIsInNuYXAiLCJhQ2hpbGQiLCJiQ2hpbGQiLCJ2YWx1ZU5vZGUiLCJWYWx1ZUluZGV4IiwiVkFMVUVfSU5ERVgiLCJjaGFuZ2VWYWx1ZSIsInNuYXBzaG90Tm9kZSIsImNoYW5nZUNoaWxkQWRkZWQiLCJjaGFuZ2VDaGlsZFJlbW92ZWQiLCJjaGFuZ2VDaGlsZENoYW5nZWQiLCJvbGRTbmFwIiwiY2hhbmdlQ2hpbGRNb3ZlZCIsIkluZGV4ZWRGaWx0ZXIiLCJpbmRleF8iLCJuZXdDaGlsZCIsImFmZmVjdGVkUGF0aCIsInNvdXJjZSIsIm9wdENoYW5nZUFjY3VtdWxhdG9yIiwib2xkQ2hpbGQiLCJ0cmFja0NoaWxkQ2hhbmdlIiwidXBkYXRlRnVsbE5vZGUiLCJuZXdTbmFwIiwiZmlsdGVyc05vZGVzIiwiZ2V0SW5kZXhlZEZpbHRlciIsIlJhbmdlZEZpbHRlciIsImluZGV4ZWRGaWx0ZXJfIiwic3RhcnRQb3N0XyIsImdldFN0YXJ0UG9zdF8iLCJlbmRQb3N0XyIsImdldEVuZFBvc3RfIiwic3RhcnRJc0luY2x1c2l2ZV8iLCJzdGFydEFmdGVyU2V0XyIsImVuZElzSW5jbHVzaXZlXyIsImVuZEJlZm9yZVNldF8iLCJnZXRTdGFydFBvc3QiLCJnZXRFbmRQb3N0IiwibWF0Y2hlcyIsImlzV2l0aGluU3RhcnQiLCJpc1dpdGhpbkVuZCIsImZpbHRlcmVkIiwic2VsZiIsImhhc1N0YXJ0Iiwic3RhcnROYW1lIiwiZ2V0SW5kZXhTdGFydE5hbWUiLCJnZXRJbmRleFN0YXJ0VmFsdWUiLCJoYXNFbmQiLCJlbmROYW1lIiwiZ2V0SW5kZXhFbmROYW1lIiwiZ2V0SW5kZXhFbmRWYWx1ZSIsIkxpbWl0ZWRGaWx0ZXIiLCJ3aXRoaW5EaXJlY3Rpb25hbFN0YXJ0IiwicmV2ZXJzZV8iLCJ3aXRoaW5FbmRQb3N0Iiwid2l0aGluU3RhcnRQb3N0Iiwid2l0aGluRGlyZWN0aW9uYWxFbmQiLCJjb21wYXJlUmVzIiwicmFuZ2VkRmlsdGVyXyIsImxpbWl0XyIsImdldExpbWl0IiwiaXNWaWV3RnJvbUxlZnQiLCJmdWxsTGltaXRVcGRhdGVDaGlsZF8iLCJpblJhbmdlIiwiY2hpbGRLZXkiLCJjaGlsZFNuYXAiLCJjaGFuZ2VBY2N1bXVsYXRvciIsIm9sZEV2ZW50Q2FjaGUiLCJuZXdDaGlsZE5hbWVkTm9kZSIsIndpbmRvd0JvdW5kYXJ5Iiwib2xkQ2hpbGRTbmFwIiwibmV4dENoaWxkIiwiZ2V0Q2hpbGRBZnRlckNoaWxkIiwiY29tcGFyZU5leHQiLCJyZW1haW5zSW5XaW5kb3ciLCJuZXdFdmVudENhY2hlIiwibmV4dENoaWxkSW5SYW5nZSIsIlF1ZXJ5UGFyYW1zIiwibGltaXRTZXRfIiwic3RhcnRTZXRfIiwic3RhcnROYW1lU2V0XyIsImVuZFNldF8iLCJlbmROYW1lU2V0XyIsInZpZXdGcm9tXyIsImluZGV4U3RhcnRWYWx1ZV8iLCJpbmRleFN0YXJ0TmFtZV8iLCJpbmRleEVuZFZhbHVlXyIsImluZGV4RW5kTmFtZV8iLCJoYXNMaW1pdCIsImhhc0FuY2hvcmVkTGltaXQiLCJxdWVyeVBhcmFtc0dldE5vZGVGaWx0ZXIiLCJxdWVyeVBhcmFtcyIsInF1ZXJ5UGFyYW1zTGltaXRUb0ZpcnN0IiwibmV3TGltaXQiLCJuZXdQYXJhbXMiLCJxdWVyeVBhcmFtc0xpbWl0VG9MYXN0IiwicXVlcnlQYXJhbXNTdGFydEF0IiwicXVlcnlQYXJhbXNTdGFydEFmdGVyIiwicXVlcnlQYXJhbXNFbmRBdCIsInF1ZXJ5UGFyYW1zRW5kQmVmb3JlIiwicXVlcnlQYXJhbXNPcmRlckJ5IiwicXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMiLCJxcyIsIm9yZGVyQnkiLCJzdGFydFBhcmFtIiwiZW5kUGFyYW0iLCJxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0Iiwidmlld0Zyb20iLCJSZWFkb25seVJlc3RDbGllbnQiLCJsaXN0ZW5zXyIsImdldExpc3RlbklkXyIsImxpc3RlbklkIiwidGhpc0xpc3RlbiIsInF1ZXJ5U3RyaW5nUGFyYW1ldGVycyIsInJlc3RSZXF1ZXN0XyIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUZXh0IiwiU25hcHNob3RIb2xkZXIiLCJyb290Tm9kZV8iLCJnZXROb2RlIiwidXBkYXRlU25hcHNob3QiLCJuZXdTbmFwc2hvdE5vZGUiLCJuZXdTcGFyc2VTbmFwc2hvdFRyZWUiLCJzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlciIsInNwYXJzZVNuYXBzaG90VHJlZSIsImNsZWFyIiwic3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0IiwidHJlZSIsInNhZmVUb1JlbW92ZSIsInNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlIiwicHJlZml4UGF0aCIsImZ1bmMiLCJzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoQ2hpbGQiLCJmb3JFYWNoIiwiU3RhdHNMaXN0ZW5lciIsImNvbGxlY3Rpb25fIiwibGFzdF8iLCJuZXdTdGF0cyIsInN0YXQiLCJGSVJTVF9TVEFUU19NSU5fVElNRSIsIkZJUlNUX1NUQVRTX01BWF9USU1FIiwiUkVQT1JUX1NUQVRTX0lOVEVSVkFMIiwiU3RhdHNSZXBvcnRlciIsImNvbGxlY3Rpb24iLCJzZXJ2ZXJfIiwic3RhdHNUb1JlcG9ydF8iLCJzdGF0c0xpc3RlbmVyXyIsInJlcG9ydFN0YXRzXyIsInJlcG9ydGVkU3RhdHMiLCJoYXZlU3RhdHNUb1JlcG9ydCIsIk9wZXJhdGlvblR5cGUiLCJuZXdPcGVyYXRpb25Tb3VyY2VVc2VyIiwiZnJvbVVzZXIiLCJmcm9tU2VydmVyIiwidGFnZ2VkIiwibmV3T3BlcmF0aW9uU291cmNlU2VydmVyIiwibmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkiLCJBY2tVc2VyV3JpdGUiLCJhZmZlY3RlZFRyZWUiLCJyZXZlcnQiLCJBQ0tfVVNFUl9XUklURSIsIm9wZXJhdGlvbkZvckNoaWxkIiwic3VidHJlZSIsIkxpc3RlbkNvbXBsZXRlIiwiTElTVEVOX0NPTVBMRVRFIiwiT3ZlcndyaXRlIiwiT1ZFUldSSVRFIiwiTWVyZ2UiLCJNRVJHRSIsIkNhY2hlTm9kZSIsIm5vZGVfIiwiZnVsbHlJbml0aWFsaXplZF8iLCJmaWx0ZXJlZF8iLCJpc0Z1bGx5SW5pdGlhbGl6ZWQiLCJpc0ZpbHRlcmVkIiwiaXNDb21wbGV0ZUZvclBhdGgiLCJpc0NvbXBsZXRlRm9yQ2hpbGQiLCJFdmVudEdlbmVyYXRvciIsInF1ZXJ5XyIsImV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzIiwiZXZlbnRHZW5lcmF0b3IiLCJjaGFuZ2VzIiwiZXZlbnRDYWNoZSIsImV2ZW50UmVnaXN0cmF0aW9ucyIsImV2ZW50cyIsIm1vdmVzIiwiY2hhbmdlIiwiZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUiLCJyZWdpc3RyYXRpb25zIiwiZmlsdGVyZWRDaGFuZ2VzIiwiZmlsdGVyIiwiZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyIsIm1hdGVyaWFsaXplZENoYW5nZSIsImV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UiLCJyZWdpc3RyYXRpb24iLCJyZXNwb25kc1RvIiwiY3JlYXRlRXZlbnQiLCJwcmV2TmFtZSIsImFXcmFwcGVkIiwiYldyYXBwZWQiLCJuZXdWaWV3Q2FjaGUiLCJzZXJ2ZXJDYWNoZSIsInZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCIsInZpZXdDYWNoZSIsImV2ZW50U25hcCIsImNvbXBsZXRlIiwidmlld0NhY2hlVXBkYXRlU2VydmVyU25hcCIsInNlcnZlclNuYXAiLCJ2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcCIsInZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCIsImVtcHR5Q2hpbGRyZW5TaW5nbGV0b24iLCJFbXB0eUNoaWxkcmVuIiwiSW1tdXRhYmxlVHJlZSIsImZyb21PYmplY3QiLCJjaGlsZFBhdGgiLCJmaW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZSIsInJlbGF0aXZlUGF0aCIsInByZWRpY2F0ZSIsImNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUiLCJmdWxsUGF0aCIsImZpbmRSb290TW9zdFZhbHVlQW5kUGF0aCIsInRvU2V0Iiwic2V0VHJlZSIsIm5ld1RyZWUiLCJmb2xkIiwiZm9sZF8iLCJwYXRoU29GYXIiLCJhY2N1bSIsImZpbmRPblBhdGgiLCJmaW5kT25QYXRoXyIsInBhdGhUb0ZvbGxvdyIsImZvcmVhY2hPblBhdGgiLCJmb3JlYWNoT25QYXRoXyIsImN1cnJlbnRSZWxhdGl2ZVBhdGgiLCJmb3JlYWNoIiwiZm9yZWFjaF8iLCJmb3JlYWNoQ2hpbGQiLCJDb21wb3VuZFdyaXRlIiwid3JpdGVUcmVlXyIsImVtcHR5IiwiY29tcG91bmRXcml0ZUFkZFdyaXRlIiwiY29tcG91bmRXcml0ZSIsInJvb3Rtb3N0Iiwicm9vdE1vc3RQYXRoIiwibmV3V3JpdGVUcmVlIiwiY29tcG91bmRXcml0ZUFkZFdyaXRlcyIsInVwZGF0ZXMiLCJuZXdXcml0ZSIsImNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSIsImNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlIiwiY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSIsImNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuIiwiY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSIsInNoYWRvd2luZ05vZGUiLCJjb21wb3VuZFdyaXRlSXNFbXB0eSIsImNvbXBvdW5kV3JpdGVBcHBseSIsImFwcGx5U3VidHJlZVdyaXRlIiwid3JpdGVUcmVlIiwicHJpb3JpdHlXcml0ZSIsIndyaXRlVHJlZUNoaWxkV3JpdGVzIiwibmV3V3JpdGVUcmVlUmVmIiwid3JpdGVUcmVlQWRkT3ZlcndyaXRlIiwid3JpdGVJZCIsImxhc3RXcml0ZUlkIiwiYWxsV3JpdGVzIiwidmlzaWJsZVdyaXRlcyIsIndyaXRlVHJlZUFkZE1lcmdlIiwiY2hhbmdlZENoaWxkcmVuIiwid3JpdGVUcmVlR2V0V3JpdGUiLCJyZWNvcmQiLCJ3cml0ZVRyZWVSZW1vdmVXcml0ZSIsImZpbmRJbmRleCIsIndyaXRlVG9SZW1vdmUiLCJyZW1vdmVkV3JpdGVXYXNWaXNpYmxlIiwicmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMiLCJjdXJyZW50V3JpdGUiLCJ3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfIiwid3JpdGVUcmVlUmVzZXRUcmVlXyIsIndyaXRlUmVjb3JkIiwid3JpdGVUcmVlTGF5ZXJUcmVlXyIsIndyaXRlVHJlZURlZmF1bHRGaWx0ZXJfIiwid3JpdGVzIiwidHJlZVJvb3QiLCJ3cml0ZVBhdGgiLCJkZWVwTm9kZSIsIndyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUiLCJ0cmVlUGF0aCIsImNvbXBsZXRlU2VydmVyQ2FjaGUiLCJ3cml0ZUlkc1RvRXhjbHVkZSIsImluY2x1ZGVIaWRkZW5Xcml0ZXMiLCJzdWJNZXJnZSIsImxheWVyZWRDYWNoZSIsIm1lcmdlQXRQYXRoIiwid3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbiIsImNvbXBsZXRlU2VydmVyQ2hpbGRyZW4iLCJjb21wbGV0ZUNoaWxkcmVuIiwidG9wTGV2ZWxTZXQiLCJ3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlIiwiZXhpc3RpbmdFdmVudFNuYXAiLCJleGlzdGluZ1NlcnZlclNuYXAiLCJjaGlsZE1lcmdlIiwid3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQiLCJ3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSIsIndyaXRlVHJlZUNhbGNJbmRleGVkU2xpY2UiLCJjb21wbGV0ZVNlcnZlckRhdGEiLCJ0b0l0ZXJhdGUiLCJub2RlcyIsIndyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUiLCJ3cml0ZVRyZWVSZWYiLCJ3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuIiwid3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSIsIndyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlIiwid3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSIsIndyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkIiwiZXhpc3RpbmdTZXJ2ZXJDYWNoZSIsIndyaXRlVHJlZVJlZkNoaWxkIiwiQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciIsImNoYW5nZU1hcCIsIm9sZENoYW5nZSIsIm9sZFR5cGUiLCJnZXRDaGFuZ2VzIiwiZnJvbSIsIk5vQ29tcGxldGVDaGlsZFNvdXJjZV8iLCJnZXRDb21wbGV0ZUNoaWxkIiwiTk9fQ09NUExFVEVfQ0hJTERfU09VUkNFIiwiV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSIsIndyaXRlc18iLCJ2aWV3Q2FjaGVfIiwib3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8iLCJzZXJ2ZXJOb2RlIiwibmV3Vmlld1Byb2Nlc3NvciIsInZpZXdQcm9jZXNzb3JBc3NlcnRJbmRleGVkIiwidmlld1Byb2Nlc3NvciIsInZpZXdQcm9jZXNzb3JBcHBseU9wZXJhdGlvbiIsIm9sZFZpZXdDYWNoZSIsIm9wZXJhdGlvbiIsIndyaXRlc0NhY2hlIiwiY29tcGxldGVDYWNoZSIsImFjY3VtdWxhdG9yIiwiZmlsdGVyU2VydmVyTm9kZSIsIm92ZXJ3cml0ZSIsInZpZXdQcm9jZXNzb3JBcHBseVVzZXJPdmVyd3JpdGUiLCJ2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUiLCJ2aWV3UHJvY2Vzc29yQXBwbHlVc2VyTWVyZ2UiLCJ2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSIsImFja1VzZXJXcml0ZSIsInZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUiLCJ2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlIiwidmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlIiwidmlld1Byb2Nlc3Nvck1heWJlQWRkVmFsdWVFdmVudCIsImlzTGVhZk9yRW1wdHkiLCJvbGRDb21wbGV0ZVNuYXAiLCJ2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCIsImNoYW5nZVBhdGgiLCJvbGRFdmVudFNuYXAiLCJjb21wbGV0ZUV2ZW50Q2hpbGRyZW4iLCJjb21wbGV0ZU5vZGUiLCJvbGRFdmVudE5vZGUiLCJ1cGRhdGVkUHJpb3JpdHkiLCJjaGlsZENoYW5nZVBhdGgiLCJuZXdFdmVudENoaWxkIiwiZXZlbnRDaGlsZFVwZGF0ZSIsImNoYW5nZWRTbmFwIiwib2xkU2VydmVyU25hcCIsIm5ld1NlcnZlckNhY2hlIiwic2VydmVyRmlsdGVyIiwibmV3U2VydmVyTm9kZSIsIm5ld0V2ZW50U25hcCIsInZpZXdQcm9jZXNzb3JDYWNoZUhhc0NoaWxkIiwiY3VyVmlld0NhY2hlIiwidmlld1Byb2Nlc3NvckFwcGx5TWVyZ2UiLCJ2aWV3TWVyZ2VUcmVlIiwic2VydmVyQ2hpbGQiLCJjaGlsZE1lcmdlVHJlZSIsImlzVW5rbm93bkRlZXBNZXJnZSIsImFja1BhdGgiLCJtZXJnZVBhdGgiLCJzZXJ2ZXJDYWNoZVBhdGgiLCJvbGRTZXJ2ZXJOb2RlIiwic2VydmVyQ2hpbGRyZW4iLCJWaWV3IiwiaW5pdGlhbFZpZXdDYWNoZSIsImV2ZW50UmVnaXN0cmF0aW9uc18iLCJpbmRleEZpbHRlciIsInByb2Nlc3Nvcl8iLCJpbml0aWFsU2VydmVyQ2FjaGUiLCJpbml0aWFsRXZlbnRDYWNoZSIsImV2ZW50R2VuZXJhdG9yXyIsInZpZXdHZXRTZXJ2ZXJDYWNoZSIsInZpZXciLCJ2aWV3R2V0Q29tcGxldGVOb2RlIiwidmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUiLCJjYWNoZSIsInZpZXdJc0VtcHR5Iiwidmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uIiwiZXZlbnRSZWdpc3RyYXRpb24iLCJ2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24iLCJjYW5jZWxFcnJvciIsImNhbmNlbEV2ZW50cyIsIm1heWJlRXZlbnQiLCJjcmVhdGVDYW5jZWxFdmVudCIsInJlbWFpbmluZyIsImV4aXN0aW5nIiwiaGFzQW55Q2FsbGJhY2siLCJjb25jYXQiLCJ2aWV3QXBwbHlPcGVyYXRpb24iLCJ2aWV3R2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyIsInZpZXdHZXRJbml0aWFsRXZlbnRzIiwiaW5pdGlhbENoYW5nZXMiLCJldmVudE5vZGUiLCJyZWZlcmVuY2VDb25zdHJ1Y3RvciQxIiwiU3luY1BvaW50Iiwidmlld3MiLCJzeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvciIsInN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yIiwic3luY1BvaW50SXNFbXB0eSIsInN5bmNQb2ludCIsInN5bmNQb2ludEFwcGx5T3BlcmF0aW9uIiwib3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSIsInN5bmNQb2ludEdldFZpZXciLCJzZXJ2ZXJDYWNoZUNvbXBsZXRlIiwiZXZlbnRDYWNoZUNvbXBsZXRlIiwic3luY1BvaW50QWRkRXZlbnRSZWdpc3RyYXRpb24iLCJzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiIsInJlbW92ZWQiLCJoYWRDb21wbGV0ZVZpZXciLCJzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXciLCJ2aWV3UXVlcnlJZCIsImVudHJpZXMiLCJfcmVwbyIsInN5bmNQb2ludEdldFF1ZXJ5Vmlld3MiLCJzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlIiwic3luY1BvaW50Vmlld0ZvclF1ZXJ5Iiwic3luY1BvaW50R2V0Q29tcGxldGVWaWV3Iiwic3luY1BvaW50Vmlld0V4aXN0c0ZvclF1ZXJ5IiwicmVmZXJlbmNlQ29uc3RydWN0b3IiLCJzeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yIiwic3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvciIsInN5bmNUcmVlTmV4dFF1ZXJ5VGFnXyIsIlN5bmNUcmVlIiwibGlzdGVuUHJvdmlkZXJfIiwic3luY1BvaW50VHJlZV8iLCJwZW5kaW5nV3JpdGVUcmVlXyIsInRhZ1RvUXVlcnlNYXAiLCJxdWVyeVRvVGFnTWFwIiwic3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUiLCJzeW5jVHJlZSIsIm5ld0RhdGEiLCJzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyIsInN5bmNUcmVlQXBwbHlVc2VyTWVyZ2UiLCJjaGFuZ2VUcmVlIiwic3luY1RyZWVBY2tVc2VyV3JpdGUiLCJuZWVkVG9SZWV2YWx1YXRlIiwic3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZSIsInN5bmNUcmVlQXBwbHlTZXJ2ZXJNZXJnZSIsInN5bmNUcmVlQXBwbHlMaXN0ZW5Db21wbGV0ZSIsInN5bmNUcmVlQXBwbHlUYWdnZWRMaXN0ZW5Db21wbGV0ZSIsInF1ZXJ5S2V5Iiwic3luY1RyZWVRdWVyeUtleUZvclRhZ18iLCJzeW5jVHJlZVBhcnNlUXVlcnlLZXlfIiwicXVlcnlQYXRoIiwib3AiLCJzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyIsInN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24iLCJza2lwTGlzdGVuZXJEZWR1cCIsIm1heWJlU3luY1BvaW50IiwicmVtb3ZlZEFuZEV2ZW50cyIsInJlbW92aW5nRGVmYXVsdCIsImNvdmVyZWQiLCJwYXJlbnRTeW5jUG9pbnQiLCJuZXdWaWV3cyIsInN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyIsIm5ld1F1ZXJ5Iiwic3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfIiwic3RhcnRMaXN0ZW5pbmciLCJzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyIsInN5bmNUcmVlVGFnRm9yUXVlcnkiLCJkZWZhdWx0VGFnIiwic3RvcExpc3RlbmluZyIsInF1ZXJ5VG9SZW1vdmUiLCJ0YWdUb1JlbW92ZSIsInN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyIsInN5bmNUcmVlUmVtb3ZlVGFnc18iLCJzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUiLCJzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZSIsInN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24iLCJza2lwU2V0dXBMaXN0ZW5lciIsImZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyIsInBhdGhUb1N5bmNQb2ludCIsInNwIiwiY2hpbGRTeW5jUG9pbnQiLCJ2aWV3QWxyZWFkeUV4aXN0cyIsInN5bmNUcmVlR2V0TmV4dFF1ZXJ5VGFnXyIsInN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8iLCJzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUiLCJpbmNsdWRlSGlkZGVuU2V0cyIsInN5bmNUcmVlR2V0U2VydmVyVmFsdWUiLCJzZXJ2ZXJDYWNoZU5vZGUiLCJzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyIsInN5bmNQb2ludFRyZWUiLCJzeW5jVHJlZUFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfIiwiY2hpbGRPcGVyYXRpb24iLCJjaGlsZFNlcnZlckNhY2hlIiwiY2hpbGRXcml0ZXNDYWNoZSIsInNwbGl0SW5kZXgiLCJtYXliZUNoaWxkU3luY1BvaW50IiwiY2hpbGRNYXAiLCJjb21wbGV0ZVZpZXciLCJfa2V5IiwiY2hpbGRWaWV3cyIsInJlbW92ZWRRdWVyeSIsInJlbW92ZWRRdWVyeUtleSIsInJlbW92ZWRRdWVyeVRhZyIsInF1ZXJpZXNUb1N0b3AiLCJjaGlsZFF1ZXJpZXMiLCJxdWVyeVRvU3RvcCIsIkV4aXN0aW5nVmFsdWVQcm92aWRlciIsIkRlZmVycmVkVmFsdWVQcm92aWRlciIsInN5bmNUcmVlXyIsInBhdGhfIiwiZ2VuZXJhdGVXaXRoVmFsdWVzIiwicmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlIiwiZXhpc3RpbmdWYWwiLCJzZXJ2ZXJWYWx1ZXMiLCJyZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVDb21wbGV4RGVmZXJyZWRWYWx1ZSIsIkpTT04iLCJ1bnVzZWQiLCJleGlzdGluZ05vZGUiLCJsZWFmIiwicmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlIiwicmVzb2x2ZURlZmVycmVkVmFsdWUiLCJyZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90IiwicmF3UHJpIiwibGVhZk5vZGUiLCJjaGlsZHJlbk5vZGUiLCJUcmVlIiwicGFyZW50IiwiY2hpbGRDb3VudCIsInRyZWVTdWJUcmVlIiwicGF0aE9iaiIsInRyZWVHZXRWYWx1ZSIsInRyZWVTZXRWYWx1ZSIsInRyZWVVcGRhdGVQYXJlbnRzIiwidHJlZUhhc0NoaWxkcmVuIiwidHJlZUlzRW1wdHkiLCJ0cmVlRm9yRWFjaENoaWxkIiwidHJlZUZvckVhY2hEZXNjZW5kYW50IiwiaW5jbHVkZVNlbGYiLCJjaGlsZHJlbkZpcnN0IiwidHJlZUZvckVhY2hBbmNlc3RvciIsInRyZWVHZXRQYXRoIiwidHJlZVVwZGF0ZUNoaWxkIiwiY2hpbGRFbXB0eSIsImNoaWxkRXhpc3RzIiwiSU5WQUxJRF9LRVlfUkVHRVhfIiwiSU5WQUxJRF9QQVRIX1JFR0VYXyIsIk1BWF9MRUFGX1NJWkVfIiwiaXNWYWxpZEtleSIsImlzVmFsaWRQYXRoU3RyaW5nIiwiaXNWYWxpZFJvb3RQYXRoU3RyaW5nIiwiaXNWYWxpZFByaW9yaXR5IiwidmFsaWRhdGVGaXJlYmFzZURhdGFBcmciLCJmbk5hbWUiLCJ2YWxpZGF0ZUZpcmViYXNlRGF0YSIsImhhc0RvdFZhbHVlIiwiaGFzQWN0dWFsQ2hpbGQiLCJ2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyIsIm1lcmdlUGF0aHMiLCJjdXJQYXRoIiwicHJldlBhdGgiLCJ2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnIiwiZXJyb3JQcmVmaXgkMSIsInZhbGlkYXRlUHJpb3JpdHkiLCJ2YWxpZGF0ZUtleSIsImFyZ3VtZW50TmFtZSIsInZhbGlkYXRlUGF0aFN0cmluZyIsInZhbGlkYXRlUm9vdFBhdGhTdHJpbmciLCJ2YWxpZGF0ZVdyaXRhYmxlUGF0aCIsInZhbGlkYXRlVXJsIiwicGFyc2VkVXJsIiwiRXZlbnRRdWV1ZSIsImV2ZW50TGlzdHNfIiwicmVjdXJzaW9uRGVwdGhfIiwiZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzIiwiZXZlbnRRdWV1ZSIsImV2ZW50RGF0YUxpc3QiLCJjdXJyTGlzdCIsImdldFBhdGgiLCJldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgiLCJldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZSIsImV2ZW50UGF0aCIsImV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoIiwiY2hhbmdlZFBhdGgiLCJzZW50QWxsIiwiZXZlbnRMaXN0IiwiZXZlbnRMaXN0UmFpc2UiLCJldmVudEZuIiwiZ2V0RXZlbnRSdW5uZXIiLCJJTlRFUlJVUFRfUkVBU09OIiwiTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVMiLCJSZXBvIiwiZm9yY2VSZXN0Q2xpZW50XyIsImFwcENoZWNrUHJvdmlkZXJfIiwiZGF0YVVwZGF0ZUNvdW50IiwiZXZlbnRRdWV1ZV8iLCJuZXh0V3JpdGVJZF8iLCJpbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfIiwidHJhbnNhY3Rpb25RdWV1ZVRyZWVfIiwicGVyc2lzdGVudENvbm5lY3Rpb25fIiwicmVwb1N0YXJ0IiwicmVwbyIsImFwcElkIiwiYXV0aE92ZXJyaWRlIiwiaXNNZXJnZSIsInJlcG9PbkRhdGFVcGRhdGUiLCJyZXBvT25Db25uZWN0U3RhdHVzIiwiY29ubmVjdFN0YXR1cyIsInJlcG9PblNlcnZlckluZm9VcGRhdGUiLCJzdGF0c1JlcG9ydGVyXyIsImluZm9EYXRhXyIsImluZm9TeW5jVHJlZV8iLCJpbmZvRXZlbnRzIiwicmVwb1VwZGF0ZUluZm8iLCJzZXJ2ZXJTeW5jVHJlZV8iLCJyZXBvU2VydmVyVGltZSIsIm9mZnNldE5vZGUiLCJvZmZzZXQiLCJyZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMiLCJ0YWdnZWRDaGlsZHJlbiIsInJhdyIsInRhZ2dlZFNuYXAiLCJyZXBvUmVydW5UcmFuc2FjdGlvbnMiLCJyZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzIiwicmVwb0dldE5leHRXcml0ZUlkIiwicmVwb0dldFZhbHVlIiwiY2FjaGVkIiwiZXJyIiwicmVwb0xvZyIsInJlcG9TZXRXaXRoUHJpb3JpdHkiLCJuZXdWYWwiLCJuZXdOb2RlVW5yZXNvbHZlZCIsInN1Y2Nlc3MiLCJjbGVhckV2ZW50cyIsInJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrIiwicmVwb0Fib3J0VHJhbnNhY3Rpb25zIiwicmVwb1VwZGF0ZSIsImNoaWxkcmVuVG9NZXJnZSIsImNoYW5nZWRLZXkiLCJjaGFuZ2VkVmFsdWUiLCJyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUiLCJyZXNvbHZlZCIsInJlcG9PbkRpc2Nvbm5lY3RDYW5jZWwiLCJyZXBvT25EaXNjb25uZWN0U2V0IiwicmVwb09uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSIsInJlcG9PbkRpc2Nvbm5lY3RVcGRhdGUiLCJyZXBvQWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5IiwicmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeSIsInJlcG9JbnRlcnJ1cHQiLCJyZXBvUmVzdW1lIiwicmVwb1N0YXJ0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvblVwZGF0ZSIsInVud2F0Y2hlciIsImFwcGx5TG9jYWxseSIsInRyYW5zYWN0aW9uIiwib3JkZXIiLCJyZXRyeUNvdW50IiwiYWJvcnRSZWFzb24iLCJjdXJyZW50V3JpdGVJZCIsImN1cnJlbnRJbnB1dFNuYXBzaG90IiwiY3VycmVudE91dHB1dFNuYXBzaG90UmF3IiwiY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQiLCJjdXJyZW50U3RhdGUiLCJyZXBvR2V0TGF0ZXN0U3RhdGUiLCJxdWV1ZU5vZGUiLCJub2RlUXVldWUiLCJwcmlvcml0eUZvck5vZGUiLCJjdXJyZW50Tm9kZSIsInJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMiLCJleGNsdWRlU2V0cyIsInJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZSIsInF1ZXVlIiwicmVwb0J1aWxkVHJhbnNhY3Rpb25RdWV1ZSIsImFsbFJ1biIsImV2ZXJ5IiwicmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlIiwic2V0c1RvSWdub3JlIiwidHhuIiwibGF0ZXN0U3RhdGUiLCJzbmFwVG9TZW5kIiwibGF0ZXN0SGFzaCIsImRhdGFUb1NlbmQiLCJwYXRoVG9TZW5kIiwiY2FsbGJhY2tzIiwicm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUiLCJyZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUiLCJyZXBvUmVydW5UcmFuc2FjdGlvblF1ZXVlIiwidHhuc1RvUmVydW4iLCJhYm9ydFRyYW5zYWN0aW9uIiwibmV3RGF0YU5vZGUiLCJoYXNFeHBsaWNpdFByaW9yaXR5Iiwib2xkV3JpdGVJZCIsIm5ld05vZGVSZXNvbHZlZCIsInRyYW5zYWN0aW9uTm9kZSIsInRyYW5zYWN0aW9uUXVldWUiLCJyZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlIiwidG8iLCJyZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUiLCJsYXN0U2VudCIsImRlY29kZVBhdGgiLCJwYXRoU3RyaW5nRGVjb2RlZCIsInBpZWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZGVjb2RlUXVlcnkiLCJxdWVyeVN0cmluZyIsInJlc3VsdHMiLCJjaGFyQXQiLCJzZWdtZW50Iiwia3YiLCJwYXJzZVJlcG9JbmZvIiwiZGF0YVVSTCIsInBhcnNlRGF0YWJhc2VVUkwiLCJzY2hlbWUiLCJzdWJkb21haW4iLCJwb3J0IiwiY29sb25JbmQiLCJzbGFzaEluZCIsInF1ZXN0aW9uTWFya0luZCIsImhvc3RXaXRob3V0UG9ydCIsImRvdEluZCIsIlBVU0hfQ0hBUlMiLCJuZXh0UHVzaElkIiwibGFzdFB1c2hUaW1lIiwibGFzdFJhbmRDaGFycyIsIm5vdyIsImR1cGxpY2F0ZVRpbWUiLCJ0aW1lU3RhbXBDaGFycyIsIkRhdGFFdmVudCIsInNuYXBzaG90IiwicmVmIiwiZ2V0RXZlbnRUeXBlIiwiZXhwb3J0VmFsIiwiQ2FuY2VsRXZlbnQiLCJDYWxsYmFja0NvbnRleHQiLCJzbmFwc2hvdENhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2siLCJvblZhbHVlIiwiZXhwRGF0YVNuYXBzaG90IiwicHJldmlvdXNDaGlsZE5hbWUiLCJjYWxsIiwib25DYW5jZWwiLCJoYXNDYW5jZWxDYWxsYmFjayIsInVzZXJDYWxsYmFjayIsIk9uRGlzY29ubmVjdCIsImNhbmNlbCIsIndyYXBDYWxsYmFjayIsInNldFdpdGhQcmlvcml0eSIsIlF1ZXJ5SW1wbCIsIl9vcmRlckJ5Q2FsbGVkIiwiUmVmZXJlbmNlSW1wbCIsImlzRXF1YWwiLCJzYW1lUmVwbyIsInNhbWVQYXRoIiwic2FtZVF1ZXJ5SWRlbnRpZmllciIsInRvSlNPTiIsInZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsIiwidmFsaWRhdGVRdWVyeUVuZHBvaW50cyIsInN0YXJ0Tm9kZSIsImVuZE5vZGUiLCJ0b29NYW55QXJnc0Vycm9yIiwid3JvbmdBcmdUeXBlRXJyb3IiLCJ2YWxpZGF0ZUxpbWl0IiwicGFyZW50UGF0aCIsIkRhdGFTbmFwc2hvdCIsIl9ub2RlIiwiX2luZGV4IiwiY2hpbGRSZWYiLCJleGlzdHMiLCJoYXNDaGlsZHJlbiIsImRiIiwiX2NoZWNrTm90RGVsZXRlZCIsIl9yb290IiwicmVmRnJvbVVSTCIsInBhcnNlZFVSTCIsInRoZW5uYWJsZVB1c2hSZWYiLCJwdXNoUmVmIiwic2V0UHJpb3JpdHkiLCJjYWxsYmFja0NvbnRleHQiLCJjb250YWluZXIiLCJWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uIiwiQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiIsImV2ZW50VG9DaGVjayIsImNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zIiwib25seU9uY2UiLCJvbmNlQ2FsbGJhY2siLCJkYXRhU25hcHNob3QiLCJvbkNoaWxkQWRkZWQiLCJvbkNoaWxkQ2hhbmdlZCIsIm9uQ2hpbGRNb3ZlZCIsIm9uQ2hpbGRSZW1vdmVkIiwiZXhwQ2FsbGJhY2siLCJRdWVyeUNvbnN0cmFpbnQiLCJRdWVyeUVuZEF0Q29uc3RyYWludCIsIl92YWx1ZSIsIl9hcHBseSIsImVuZEF0IiwiUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50IiwiZW5kQmVmb3JlIiwiUXVlcnlTdGFydEF0Q29uc3RyYWludCIsInN0YXJ0QXQiLCJRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50Iiwic3RhcnRBZnRlciIsIlF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludCIsIl9saW1pdCIsImxpbWl0VG9GaXJzdCIsImxpbWl0IiwiUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQiLCJsaW1pdFRvTGFzdCIsIlF1ZXJ5T3JkZXJCeUNoaWxkQ29uc3RyYWludCIsInBhcnNlZFBhdGgiLCJvcmRlckJ5Q2hpbGQiLCJRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50Iiwib3JkZXJCeUtleSIsIlF1ZXJ5T3JkZXJCeVByaW9yaXR5Q29uc3RyYWludCIsIm9yZGVyQnlQcmlvcml0eSIsIlF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCIsIm9yZGVyQnlWYWx1ZSIsIlF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCIsImVxdWFsVG8iLCJxdWVyeUNvbnN0cmFpbnRzIiwicXVlcnlJbXBsIiwiY29uc3RyYWludCIsIkZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSIiwicmVwb3MiLCJ1c2VSZXN0Q2xpZW50IiwicmVwb01hbmFnZXJBcHBseUVtdWxhdG9yU2V0dGluZ3MiLCJ0b2tlblByb3ZpZGVyIiwicmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAiLCJhcHAiLCJhdXRoUHJvdmlkZXIiLCJkYlVybCIsImRhdGFiYXNlVVJMIiwicHJvamVjdElkIiwiaXNFbXVsYXRvciIsImRiRW11bGF0b3JIb3N0IiwiYXV0aFRva2VuUHJvdmlkZXIiLCJyZXBvTWFuYWdlckNyZWF0ZVJlcG8iLCJEYXRhYmFzZSIsInJlcG9NYW5hZ2VyRGVsZXRlUmVwbyIsImFwcE5hbWUiLCJhcHBSZXBvcyIsInJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50IiwiZm9yY2VSZXN0Q2xpZW50IiwiX3JlcG9JbnRlcm5hbCIsIl9pbnN0YW5jZVN0YXJ0ZWQiLCJfcm9vdEludGVybmFsIiwiX2RlbGV0ZSIsImFwaU5hbWUiLCJjaGVja1RyYW5zcG9ydEluaXQiLCJmb3JjZVdlYlNvY2tldHMiLCJmb3JjZUxvbmdQb2xsaW5nIiwiZ2V0RGF0YWJhc2UiLCJpZGVudGlmaWVyIiwiZW11bGF0b3IiLCJjb25uZWN0RGF0YWJhc2VFbXVsYXRvciIsIm1vY2tVc2VyVG9rZW4iLCJnb09mZmxpbmUiLCJnb09ubGluZSIsImVuYWJsZUxvZ2dpbmciLCJyZWdpc3RlckRhdGFiYXNlIiwidmFyaWFudCIsImluc3RhbmNlSWRlbnRpZmllciIsImdldFByb3ZpZGVyIiwic2V0TXVsdGlwbGVJbnN0YW5jZXMiLCJTRVJWRVJfVElNRVNUQU1QIiwic2VydmVyVGltZXN0YW1wIiwiaW5jcmVtZW50IiwiVHJhbnNhY3Rpb25SZXN1bHQiLCJjb21taXR0ZWQiLCJydW5UcmFuc2FjdGlvbiIsInByb21pc2VDb21wbGV0ZSIsInByb3RvdHlwZSIsInNpbXBsZUxpc3RlbiIsImVjaG8iLCJvbkVjaG8iLCJoaWphY2tIYXNoIiwibmV3SGFzaCIsIm9sZFB1dCIsIkNsaWVudCIsIl9RdWVyeUltcGwiLCJfUXVlcnlQYXJhbXMiLCJfUmVmZXJlbmNlSW1wbCIsIl9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQiLCJfVEVTVF9BQ0NFU1NfaGlqYWNrSGFzaCIsIl9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCIsIl9zZXRTREtWZXJzaW9uIiwiX3ZhbGlkYXRlUGF0aFN0cmluZyIsIl92YWxpZGF0ZVdyaXRhYmxlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A container for all of the Logger instances\r\n */ const instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    \"debug\": LogLevel.DEBUG,\n    \"verbose\": LogLevel.VERBOSE,\n    \"info\": LogLevel.INFO,\n    \"warn\": LogLevel.WARN,\n    \"error\": LogLevel.ERROR,\n    \"silent\": LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */ const defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */ const ConsoleMethod = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.VERBOSE]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */ const defaultLogHandler = (instance, logType, ...args)=>{\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    } else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */ constructor(name){\n        this.name = name;\n        /**\r\n         * The log level of the given Logger instance.\r\n         */ this._logLevel = defaultLogLevel;\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */ this._logHandler = defaultLogHandler;\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */ this._userLogHandler = null;\n        /**\r\n         * Capture the current instance for later use\r\n         */ instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== \"function\") {\n            throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */ debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach((inst)=>{\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances){\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        } else {\n            instance.userLogHandler = (instance, level, ...args)=>{\n                const message = args.map((arg)=>{\n                    if (arg == null) {\n                        return null;\n                    } else if (typeof arg === \"string\") {\n                        return arg;\n                    } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n                        return arg.toString();\n                    } else if (arg instanceof Error) {\n                        return arg.message;\n                    } else {\n                        try {\n                            return JSON.stringify(arg);\n                        } catch (ignored) {\n                            return null;\n                        }\n                    }\n                }).filter((arg)=>arg).join(\" \");\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVksRUFBRTtBQUNwQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDdkMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLE1BQU1DLG9CQUFvQjtJQUN0QixTQUFTRCxTQUFTRSxLQUFLO0lBQ3ZCLFdBQVdGLFNBQVNHLE9BQU87SUFDM0IsUUFBUUgsU0FBU0ksSUFBSTtJQUNyQixRQUFRSixTQUFTSyxJQUFJO0lBQ3JCLFNBQVNMLFNBQVNNLEtBQUs7SUFDdkIsVUFBVU4sU0FBU08sTUFBTTtBQUM3QjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCUixTQUFTSSxJQUFJO0FBQ3JDOzs7OztDQUtDLEdBQ0QsTUFBTUssZ0JBQWdCO0lBQ2xCLENBQUNULFNBQVNFLEtBQUssQ0FBQyxFQUFFO0lBQ2xCLENBQUNGLFNBQVNHLE9BQU8sQ0FBQyxFQUFFO0lBQ3BCLENBQUNILFNBQVNJLElBQUksQ0FBQyxFQUFFO0lBQ2pCLENBQUNKLFNBQVNLLElBQUksQ0FBQyxFQUFFO0lB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Szt3QkFDRCxJQUFJOzRCQUNBLE9BQU9JLEtBQUtDLFNBQVMsQ0FBQ0g7d0JBQzFCLEVBQ0EsT0FBT0ksU0FBUzs0QkFDWixPQUFPO3dCQUNYO29CQUNKO2dCQUNKLEdBQ0tDLE1BQU0sQ0FBQ0wsQ0FBQUEsTUFBT0EsS0FDZE0sSUFBSSxDQUFDO2dCQUNWLElBQUlmLFNBQVVNLENBQUFBLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUJqQyxTQUFTRyxRQUFRLEdBQUc7b0JBQ3RHNEIsWUFBWTt3QkFDUkosT0FBT3RDLFFBQVEsQ0FBQ3NDLE1BQU0sQ0FBQ2dCLFdBQVc7d0JBQ2xDVDt3QkFDQWhDO3dCQUNBMEMsTUFBTTVDLFNBQVNTLElBQUk7b0JBQ3ZCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFFNEQsQ0FDNUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFteWVlbWFuLmNvbS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/Mzk4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xyXG4gKi9cclxuY29uc3QgaW5zdGFuY2VzID0gW107XHJcbi8qKlxyXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXHJcbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cclxuICpcclxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcclxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxyXG4gKiBgVkVSQk9TRWAgbG9ncyB3aWxsIG5vdClcclxuICovXHJcbnZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJWRVJCT1NFXCJdID0gMV0gPSBcIlZFUkJPU0VcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA1XSA9IFwiU0lMRU5UXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGxldmVsU3RyaW5nVG9FbnVtID0ge1xyXG4gICAgJ2RlYnVnJzogTG9nTGV2ZWwuREVCVUcsXHJcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXHJcbiAgICAnaW5mbyc6IExvZ0xldmVsLklORk8sXHJcbiAgICAnd2Fybic6IExvZ0xldmVsLldBUk4sXHJcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcclxuICAgICdzaWxlbnQnOiBMb2dMZXZlbC5TSUxFTlRcclxufTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcclxuLyoqXHJcbiAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cclxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXHJcbiAqIChpLmUuIG9uY2UgZm9yIGZpcmViYXNlLCBhbmQgb25jZSBpbiB0aGUgY29uc29sZSksIHdlIGFyZSBzZW5kaW5nIGBERUJVR2BcclxuICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IENvbnNvbGVNZXRob2QgPSB7XHJcbiAgICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcclxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxyXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcclxuICogbWVzc2FnZXMgb24gdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb25zb2xlIGNvdW50ZXJwYXJ0cyAoaWYgdGhlIGxvZyBtZXRob2RcclxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcclxuICovXHJcbmNvbnN0IGRlZmF1bHRMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsb2dUeXBlLCAuLi5hcmdzKSA9PiB7XHJcbiAgICBpZiAobG9nVHlwZSA8IGluc3RhbmNlLmxvZ0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcclxuICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gbG9nIGEgbWVzc2FnZSB3aXRoIGFuIGludmFsaWQgbG9nVHlwZSAodmFsdWU6ICR7bG9nVHlwZX0pYCk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xyXG4gICAgICogRmlyZWJhc2UncyBsb2dnaW5nIHNjaGVtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFpbiAoaW50ZXJuYWwpIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gZGVmYXVsdExvZ0hhbmRsZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhcHR1cmUgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0xldmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcclxuICAgIH1cclxuICAgIHNldCBsb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXHJcbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gbGV2ZWxTdHJpbmdUb0VudW1bdmFsXSA6IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91c2VyTG9nSGFuZGxlcjtcclxuICAgIH1cclxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBsb2coLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmXHJcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbmZvKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgd2FybiguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVycm9yKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcclxuICAgIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xyXG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgbGV0IGN1c3RvbUxvZ0xldmVsID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbGV2ZWwsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihhcmcgPT4gYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsW2xldmVsXS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnN0YW5jZS5uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IExvZ0xldmVsLCBMb2dnZXIsIHNldExvZ0xldmVsLCBzZXRVc2VyTG9nSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpbnN0YW5jZXMiLCJMb2dMZXZlbCIsImxldmVsU3RyaW5nVG9FbnVtIiwiREVCVUciLCJWRVJCT1NFIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIlNJTEVOVCIsImRlZmF1bHRMb2dMZXZlbCIsIkNvbnNvbGVNZXRob2QiLCJkZWZhdWx0TG9nSGFuZGxlciIsImluc3RhbmNlIiwibG9nVHlwZSIsImFyZ3MiLCJsb2dMZXZlbCIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1ldGhvZCIsImNvbnNvbGUiLCJuYW1lIiwiRXJyb3IiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsIl9sb2dMZXZlbCIsIl9sb2dIYW5kbGVyIiwiX3VzZXJMb2dIYW5kbGVyIiwicHVzaCIsInZhbCIsIlR5cGVFcnJvciIsInNldExvZ0xldmVsIiwibG9nSGFuZGxlciIsInVzZXJMb2dIYW5kbGVyIiwiZGVidWciLCJsb2ciLCJpbmZvIiwid2FybiIsImVycm9yIiwibGV2ZWwiLCJmb3JFYWNoIiwiaW5zdCIsInNldFVzZXJMb2dIYW5kbGVyIiwibG9nQ2FsbGJhY2siLCJvcHRpb25zIiwiY3VzdG9tTG9nTGV2ZWwiLCJtZXNzYWdlIiwibWFwIiwiYXJnIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiaWdub3JlZCIsImZpbHRlciIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */ const CONSTANTS = {\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */ NODE_CLIENT: false,\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */ NODE_ADMIN: false,\n    /**\r\n     * Firebase SDK Version\r\n     */ SDK_VERSION: \"${JSCORE_VERSION}\"\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws an error if the provided assertion is falsy\r\n */ const assert = function(assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */ const assertionError = function(message) {\n    return new Error(\"Firebase Database (\" + CONSTANTS.SDK_VERSION + \") INTERNAL ASSERT FAILED: \" + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const stringToByteArray$1 = function(str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */ const byteArrayToString = function(bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while(pos < bytes.length){\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        } else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        } else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        } else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        }\n    }\n    return out.join(\"\");\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nconst base64 = {\n    /**\r\n     * Maps bytes to characters.\r\n     */ byteToCharMap_: null,\n    /**\r\n     * Maps characters to bytes.\r\n     */ charToByteMap_: null,\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */ byteToCharMapWebSafe_: null,\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */ charToByteMapWebSafe_: null,\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */ ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\",\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */ get ENCODED_VALS () {\n        return this.ENCODED_VALS_BASE + \"+/=\";\n    },\n    /**\r\n     * Our websafe alphabet.\r\n     */ get ENCODED_VALS_WEBSAFE () {\n        return this.ENCODED_VALS_BASE + \"-_.\";\n    },\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */ HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeByteArray (input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error(\"encodeByteArray takes an array as a parameter\");\n        }\n        this.init_();\n        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n        const output = [];\n        for(let i = 0; i < input.length; i += 3){\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n    },\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */ decodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */ decodeStringToByteArray (input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n        const output = [];\n        for(let i = 0; i < input.length;){\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = byte1 << 2 | byte2 >> 4;\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = byte3 << 6 & 0xc0 | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */ init_ () {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for(let i = 0; i < this.ENCODED_VALS.length; i++){\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\r\n * An error encountered while decoding base64 string.\r\n */ class DecodeBase64StringError extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"DecodeBase64StringError\";\n    }\n}\n/**\r\n * URL-safe base64 encoding\r\n */ const base64Encode = function(str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */ const base64urlEncodeWithoutPadding = function(str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, \"\");\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */ const base64Decode = function(str) {\n    try {\n        return base64.decodeString(str, true);\n    } catch (e) {\n        console.error(\"base64Decode failed: \", e);\n    }\n    return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */ function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */ function deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch(source.constructor){\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for(const prop in source){\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== \"__proto__\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */ function getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"Unable to locate global object.\");\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */ const getDefaultsFromEnvVariable = ()=>{\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = ()=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    } catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */ const getDefaults = ()=>{\n    try {\n        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n    } catch (e) {\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */ const getDefaultEmulatorHost = (productName)=>{\n    var _a, _b;\n    return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */ const getDefaultEmulatorHostnameAndPort = (productName)=>{\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(\":\"); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === \"[\") {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [\n            host.substring(1, separatorIndex - 1),\n            port\n        ];\n    } else {\n        return [\n            host.substring(0, separatorIndex),\n            port\n        ];\n    }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */ const getDefaultAppConfig = ()=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */ const getExperimentalSetting = (name)=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.reject = ()=>{};\n        this.resolve = ()=>{};\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */ wrapCallback(callback) {\n        return (error, value)=>{\n            if (error) {\n                this.reject(error);\n            } else {\n                this.resolve(value);\n            }\n            if (typeof callback === \"function\") {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(()=>{});\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                } else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: \"none\",\n        type: \"JWT\"\n    };\n    const project = projectId || \"demo-project\";\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({\n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`,\n        aud: project,\n        iat,\n        exp: iat + 3600,\n        auth_time: iat,\n        sub,\n        user_id: sub,\n        firebase: {\n            sign_in_provider: \"custom\",\n            identities: {}\n        }\n    }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = \"\";\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join(\".\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */ function getUA() {\n    if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n        return navigator[\"userAgent\"];\n    } else {\n        return \"\";\n    }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */ function isMobileCordova() {\n    return  false && 0;\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */ // Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === \"node\") {\n        return true;\n    } else if (forceEnvironment === \"browser\") {\n        return false;\n    }\n    try {\n        return Object.prototype.toString.call(global.process) === \"[object process]\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * Detect Browser Environment\r\n */ function isBrowser() {\n    return typeof self === \"object\" && self.self === self;\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : undefined;\n    return typeof runtime === \"object\" && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */ function isReactNative() {\n    return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\n/** Detects Electron apps. */ function isElectron() {\n    return getUA().indexOf(\"Electron/\") >= 0;\n}\n/** Detects Internet Explorer. */ function isIE() {\n    const ua = getUA();\n    return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\n/** Detects Universal Windows Platform apps. */ function isUWP() {\n    return getUA().indexOf(\"MSAppHost/\") >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */ function isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */ function isSafari() {\n    return !isNode() && navigator.userAgent.includes(\"Safari\") && !navigator.userAgent.includes(\"Chrome\");\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */ function isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === \"object\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */ function validateIndexedDBOpenable() {\n    return new Promise((resolve, reject)=>{\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = ()=>{\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = ()=>{\n                preExist = false;\n            };\n            request.onerror = ()=>{\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n            };\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */ function areCookiesEnabled() {\n    if (typeof navigator === \"undefined\" || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */ const ERROR_NAME = \"FirebaseError\";\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors){\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : \"Error\";\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key)=>{\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */ function jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */ function stringify(data) {\n    return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const decode = function(token) {\n    let header = {}, claims = {}, data = {}, signature = \"\";\n    try {\n        const parts = token.split(\".\");\n        header = jsonEval(base64Decode(parts[0]) || \"\");\n        claims = jsonEval(base64Decode(parts[1]) || \"\");\n        signature = parts[2];\n        data = claims[\"d\"] || {};\n        delete claims[\"d\"];\n    } catch (e) {}\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidTimestamp = function(token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === \"object\") {\n        if (claims.hasOwnProperty(\"nbf\")) {\n            validSince = claims[\"nbf\"];\n        } else if (claims.hasOwnProperty(\"iat\")) {\n            validSince = claims[\"iat\"];\n        }\n        if (claims.hasOwnProperty(\"exp\")) {\n            validUntil = claims[\"exp\"];\n        } else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const issuedAtTime = function(token) {\n    const claims = decode(token).claims;\n    if (typeof claims === \"object\" && claims.hasOwnProperty(\"iat\")) {\n        return claims[\"iat\"];\n    }\n    return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidFormat = function(token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === \"object\" && claims.hasOwnProperty(\"iat\");\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isAdmin = function(token) {\n    const claims = decode(token).claims;\n    return typeof claims === \"object\" && claims[\"admin\"] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    } else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */ function deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys){\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        } else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys){\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === \"object\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */ function promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(()=>deferredPromise.reject(\"timeout!\"), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */ function querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)){\n        if (Array.isArray(value)) {\n            value.forEach((arrayVal)=>{\n                params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n            });\n        } else {\n            params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n        }\n    }\n    return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */ function querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, \"\").split(\"&\");\n    tokens.forEach((token)=>{\n        if (token) {\n            const [key, value] = token.split(\"=\");\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */ function extractQuerystring(url) {\n    const queryStart = url.indexOf(\"?\");\n    if (!queryStart) {\n        return \"\";\n    }\n    const fragmentStart = url.indexOf(\"#\", queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */ /**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */ class Sha1 {\n    constructor(){\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */ this.chain_ = [];\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */ this.buf_ = [];\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */ this.W_ = [];\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */ this.pad_ = [];\n        /**\r\n         * @private {number}\r\n         */ this.inbuf_ = 0;\n        /**\r\n         * @private {number}\r\n         */ this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for(let i = 1; i < this.blockSize; ++i){\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */ compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === \"string\") {\n            for(let i = 0; i < 16; i++){\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        } else {\n            for(let i = 0; i < 16; i++){\n                W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for(let i = 16; i < 80; i++){\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for(let i = 0; i < 80; i++){\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ b & (c ^ d);\n                    k = 0x5a827999;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            } else {\n                if (i < 60) {\n                    f = b & c | d & (b | c);\n                    k = 0x8f1bbcdc;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n            e = d;\n            d = c;\n            c = (b << 30 | b >>> 2) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n        this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n        this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n        this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n        this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while(n < length){\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while(n <= lengthMinusBlock){\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === \"string\") {\n                while(n < length){\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            } else {\n                while(n < length){\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */ digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        } else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for(let i = this.blockSize - 1; i >= 56; i--){\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for(let i = 0; i < 5; i++){\n            for(let j = 24; j >= 0; j -= 8){\n                digest[n] = this.chain_[i] >> j & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */ function createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */ class ObserverProxy {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */ constructor(executor, onNoObservers){\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(()=>{\n            executor(this);\n        }).catch((e)=>{\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer)=>{\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer)=>{\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer)=>{\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */ subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            \"next\",\n            \"error\",\n            \"complete\"\n        ])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(()=>{\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for(let i = 0; i < this.observers.length; i++){\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args)=>{\n        Promise.resolve(true).then(()=>{\n            fn(...args);\n        }).catch((error)=>{\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */ function implementsAnyMethods(obj, methods) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return false;\n    }\n    for (const method of methods){\n        if (method in obj && typeof obj[method] === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */ const validateArgCount = function(fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = \"at least \" + minCount;\n    } else if (argCount > maxCount) {\n        argError = maxCount === 0 ? \"none\" : \"no more than \" + maxCount;\n    }\n    if (argError) {\n        const error = fnName + \" failed: Was called with \" + argCount + (argCount === 1 ? \" argument.\" : \" arguments.\") + \" Expects \" + argError + \".\";\n        throw new Error(error);\n    }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */ function errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */ function validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== \"string\") {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, \"namespace\") + \"must be a valid firebase namespace.\");\n    }\n}\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid function.\");\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== \"object\" || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid context object.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */ const stringToByteArray = function(str) {\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, \"Surrogate pair missing trail surrogate.\");\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if (c < 65536) {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */ const stringLength = function(str) {\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        } else if (c < 2048) {\n            p += 2;\n        } else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        } else {\n            p += 3;\n        }\n    }\n    return p;\n};\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */ const uuidv4 = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The amount of milliseconds to exponentially increase.\r\n */ const DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */ const DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */ const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */ const RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */ function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(// A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n    // if we add or subtract.\n    (Math.random() - 0.5) * 2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provide English ordinal letters after a number\r\n */ function ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return \"th\";\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return \"st\";\n    }\n    if (dec === 2) {\n        return \"nd\";\n    }\n    if (dec === 3) {\n        return \"rd\";\n    }\n    return \"th\";\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    } else {\n        return service;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVk7SUFDZDs7S0FFQyxHQUNEQyxhQUFhO0lBQ2I7O0tBRUMsR0FDREMsWUFBWTtJQUNaOztLQUVDLEdBQ0RDLGFBQWE7QUFDakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1DLFNBQVMsU0FBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU1FLGVBQWVEO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixTQUFVRCxPQUFPO0lBQ3BDLE9BQU8sSUFBSUUsTUFBTSx3QkFDYlIsVUFBVUcsV0FBVyxHQUNyQiwrQkFDQUc7QUFDUjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1HLHNCQUFzQixTQUFVQyxHQUFHO0lBQ3JDLDJEQUEyRDtJQUMzRCxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJRSxJQUFJTCxJQUFJTSxVQUFVLENBQUNIO1FBQ3ZCLElBQUlFLElBQUksS0FBSztZQUNUSixHQUFHLENBQUNDLElBQUksR0FBR0c7UUFDZixPQUNLLElBQUlBLElBQUksTUFBTTtZQUNmSixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFNLElBQUs7WUFDdEJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUssS0FBTTtRQUMxQixPQUNLLElBQUksQ0FBQ0csSUFBSSxNQUFLLE1BQU8sVUFD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O0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxrRUFBa0U7QUFDbEUxTSxVQUFVQyxXQUFXLEdBQUc7QUFFbzhCLENBQzU5QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYW15ZWVtYW4uY29tLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/OWU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxyXG4gKi9cclxuY29uc3QgQ09OU1RBTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XHJcbiAqL1xyXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxyXG4gKi9cclxuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xyXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXHJcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXHJcbiAgICAgICAgbWVzc2FnZSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxyXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcclxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXHJcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cclxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXHJcbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XHJcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxyXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufTtcclxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3RcclxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcclxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcclxuY29uc3QgYmFzZTY0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxyXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxyXG4gICAgICovXHJcbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cclxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcclxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxyXG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXHJcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XHJcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXHJcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XHJcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcclxuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXHJcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cclxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxyXG4gKi9cclxuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xyXG4gKlxyXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcclxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxyXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxyXG4gKi9cclxuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxyXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXHJcbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcclxuICogKGFuZCByZXR1cm5lZCkuXHJcbiAqXHJcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xyXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cclxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNhc2UgRGF0ZTpcclxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcclxuICAgICAgICBjYXNlIE9iamVjdDpcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cclxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cclxuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XHJcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXHJcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcclxuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcclxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxyXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcclxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cclxuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXHJcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxyXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XHJcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XHJcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXHJcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcclxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxyXG4gICAgICovXHJcbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xyXG4gICAgaWYgKHRva2VuLnVpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXHJcbiAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnbm9uZScsXHJcbiAgICAgICAgdHlwZTogJ0pXVCdcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xyXG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XHJcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXHJcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XHJcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0gfSwgdG9rZW4pO1xyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgXS5qb2luKCcuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cclxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VUEoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gKlxyXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxyXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XHJcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xyXG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxyXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXHJcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgTm9kZS5qcy5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcclxuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XHJcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcclxuICAgICAgICA/IGNocm9tZS5ydW50aW1lXHJcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xyXG59XHJcbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xyXG5mdW5jdGlvbiBpc0lFKCkge1xyXG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNVV1AoKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcclxuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcclxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxyXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcclxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcclxuICogcHJpdmF0ZSBicm93c2luZylcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVFeGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZUV4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcclxuICovXHJcbmZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqXHJcbiAqICAgLy8gVHlwZXNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xyXG4gKiAgIHR5cGUgRXJyID1cclxuICogICAgICd1bmtub3duJyB8XHJcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcclxuICogICAgIDtcclxuICpcclxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xyXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cclxuICogICB2YXIgRXJyID0ge1xyXG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxyXG4gKiAgIH1cclxuICpcclxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xyXG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcclxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxyXG4gKiAgIH07XHJcbiAqXHJcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cclxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XHJcbiAqXHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xyXG4gKiAgIC4uLlxyXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxyXG4gKlxyXG4gKiAgIGNhdGNoIChlKSB7XHJcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xyXG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcclxuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKi9cclxuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcclxuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcclxuY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY29kZSwgbWVzc2FnZSwgXHJcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjdXN0b21EYXRhKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSBjdXN0b21EYXRhO1xyXG4gICAgICAgIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xyXG4gICAgICAgIC8vIEZpeCBGb3IgRVM1XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxyXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVycm9yRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcclxuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbURhdGEgPSBkYXRhWzBdIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xyXG4gICAgICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cclxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cclxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgbGV0IGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xyXG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xyXG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xyXG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcclxuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcixcclxuICAgICAgICBjbGFpbXMsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxyXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuICAgIGxldCB2YWxpZFNpbmNlID0gMCwgdmFsaWRVbnRpbCA9IDA7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoISFub3cgJiZcclxuICAgICAgICAhIXZhbGlkU2luY2UgJiZcclxuICAgICAgICAhIXZhbGlkVW50aWwgJiZcclxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgIG5vdyA8PSB2YWxpZFVudGlsKTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICByZXR1cm4gY2xhaW1zWydpYXQnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xyXG4gICAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbWFwKG9iaiwgZm4sIGNvbnRleHRPYmopIHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKipcclxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFQcm9wID0gYVtrXTtcclxuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XHJcbiAgICAgICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcclxuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xyXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcclxuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXHJcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxyXG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xyXG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcclxuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxyXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxyXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xyXG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcclxuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XHJcbiAqXHJcbiAqIFBlcmZvcm1hbmNlOlxyXG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xyXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZmluYWxcclxuICogQHN0cnVjdFxyXG4gKi9cclxuY2xhc3MgU2hhMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xyXG4gICAgICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cclxuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuV18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xyXG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcclxuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcclxuICAgIH1cclxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXHJcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xyXG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xyXG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXHJcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXHJcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXHJcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcclxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxyXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcclxuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcclxuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXHJcbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XHJcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xyXG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWdlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcclxuICogVGhlbmFibGUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICogICAgIGFzIGEgcHJveHkuXHJcbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XHJcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXHJcbiAqIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gICAgICogICAgIGFzIGEgcHJveHkuXHJcbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXHJcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xyXG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxyXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxyXG4gICAgICAgIHRoaXMudGFza1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcjtcclxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xyXG4gICAgICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdjb21wbGV0ZSdcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxyXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcclxuICAgICAgICAvLyBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gdW5zdWI7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xyXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cclxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XHJcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXHJcbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xyXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxyXG4gICAgc2VuZE9uZShpLCBmbikge1xyXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsb3NlKGVycikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xyXG4gICAgbGV0IGFyZ0Vycm9yO1xyXG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xyXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICBhcmdDb3VudCArXHJcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcclxuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xyXG4gICAgICAgICAgICBhcmdFcnJvciArXHJcbiAgICAgICAgICAgICcuJztcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XHJcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmbk5hbWVcclxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXHJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcclxuICogQHBhcmFtIG9wdGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcclxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcclxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxyXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cclxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3RcclxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXHJcbi8vIHBhaXIpLlxyXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cclxuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIHArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgcCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxyXG4gICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxyXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXHJcbi8qKlxyXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxyXG4gKiBTZWVcclxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXHJcbiAqIGZvciBjb250ZXh0LlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxyXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXHJcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cclxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XHJcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxyXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXHJcbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcclxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICBSQU5ET01fRkFDVE9SICpcclxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcclxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcclxuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXHJcbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcclxuICAgICAgICAyKTtcclxuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cclxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcclxuICAgICAgICByZXR1cm4gYCR7aX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XHJcbn1cclxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcclxuICAgIGkgPSBNYXRoLmFicyhpKTtcclxuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xyXG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xyXG4gICAgICAgIHJldHVybiAndGgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xyXG4gICAgaWYgKGRlYyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiAnc3QnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiAnbmQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiAncmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0aCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcclxuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXHJcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNPTlNUQU5UUyIsIk5PREVfQ0xJRU5UIiwiTk9ERV9BRE1JTiIsIlNES19WRVJTSU9OIiwiYXNzZXJ0IiwiYXNzZXJ0aW9uIiwibWVzc2FnZSIsImFzc2VydGlvbkVycm9yIiwiRXJyb3IiLCJzdHJpbmdUb0J5dGVBcnJheSQxIiwic3RyIiwib3V0IiwicCIsImkiLCJsZW5ndGgiLCJjIiwiY2hhckNvZGVBdCIsImJ5dGVBcnJheVRvU3RyaW5nIiwiYnl0ZXMiLCJwb3MiLCJjMSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImMyIiwiYzMiLCJjNCIsInUiLCJqb2luIiwiYmFzZTY0IiwiYnl0ZVRvQ2hhck1hcF8iLCJjaGFyVG9CeXRlTWFwXyIsImJ5dGVUb0NoYXJNYXBXZWJTYWZlXyIsImNoYXJUb0J5dGVNYXBXZWJTYWZlXyIsIkVOQ09ERURfVkFMU19CQVNFIiwiRU5DT0RFRF9WQUxTIiwiRU5DT0RFRF9WQUxTX1dFQlNBRkUiLCJIQVNfTkFUSVZFX1NVUFBPUlQiLCJhdG9iIiwiZW5jb2RlQnl0ZUFycmF5IiwiaW5wdXQiLCJ3ZWJTYWZlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5pdF8iLCJieXRlVG9DaGFyTWFwIiwib3V0cHV0IiwiYnl0ZTEiLCJoYXZlQnl0ZTIiLCJieXRlMiIsImhhdmVCeXRlMyIsImJ5dGUzIiwib3V0Qnl0ZTEiLCJvdXRCeXRlMiIsIm91dEJ5dGUzIiwib3V0Qnl0ZTQiLCJwdXNoIiwiZW5jb2RlU3RyaW5nIiwiYnRvYSIsImRlY29kZVN0cmluZyIsImRlY29kZVN0cmluZ1RvQnl0ZUFycmF5IiwiY2hhclRvQnl0ZU1hcCIsImNoYXJBdCIsImhhdmVCeXRlNCIsImJ5dGU0IiwiRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIm5hbWUiLCJiYXNlNjRFbmNvZGUiLCJ1dGY4Qnl0ZXMiLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsInJlcGxhY2UiLCJiYXNlNjREZWNvZGUiLCJlIiwiY29uc29sZSIsImVycm9yIiwiZGVlcENvcHkiLCJ2YWx1ZSIsImRlZXBFeHRlbmQiLCJ1bmRlZmluZWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJPYmplY3QiLCJEYXRlIiwiZGF0ZVZhbHVlIiwiZ2V0VGltZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImlzVmFsaWRLZXkiLCJrZXkiLCJnZXRHbG9iYWwiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiZ2V0RGVmYXVsdHNGcm9tR2xvYmFsIiwiX19GSVJFQkFTRV9ERUZBVUxUU19fIiwiZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUiLCJwcm9jZXNzIiwiZW52IiwiZGVmYXVsdHNKc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiZ2V0RGVmYXVsdHNGcm9tQ29va2llIiwiZG9jdW1lbnQiLCJtYXRjaCIsImNvb2tpZSIsImRlY29kZWQiLCJnZXREZWZhdWx0cyIsImluZm8iLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0IiwicHJvZHVjdE5hbWUiLCJfYSIsIl9iIiwiZW11bGF0b3JIb3N0cyIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImhvc3QiLCJzZXBhcmF0b3JJbmRleCIsImxhc3RJbmRleE9mIiwicG9ydCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImNvbmZpZyIsImdldEV4cGVyaW1lbnRhbFNldHRpbmciLCJEZWZlcnJlZCIsInJlamVjdCIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsIndyYXBDYWxsYmFjayIsImNhbGxiYWNrIiwiY2F0Y2giLCJjcmVhdGVNb2NrVXNlclRva2VuIiwidG9rZW4iLCJwcm9qZWN0SWQiLCJ1aWQiLCJoZWFkZXIiLCJhbGciLCJ0eXBlIiwicHJvamVjdCIsImlhdCIsInN1YiIsInVzZXJfaWQiLCJwYXlsb2FkIiwiYXNzaWduIiwiaXNzIiwiYXVkIiwiZXhwIiwiYXV0aF90aW1lIiwiZmlyZWJhc2UiLCJzaWduX2luX3Byb3ZpZGVyIiwiaWRlbnRpdGllcyIsInNpZ25hdHVyZSIsInN0cmluZ2lmeSIsImdldFVBIiwibmF2aWdhdG9yIiwiaXNNb2JpbGVDb3Jkb3ZhIiwidGVzdCIsImlzTm9kZSIsImZvcmNlRW52aXJvbm1lbnQiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0Jyb3dzZXIiLCJpc0Jyb3dzZXJFeHRlbnNpb24iLCJydW50aW1lIiwiY2hyb21lIiwiYnJvd3NlciIsImlkIiwiaXNSZWFjdE5hdGl2ZSIsImlzRWxlY3Ryb24iLCJpbmRleE9mIiwiaXNJRSIsInVhIiwiaXNVV1AiLCJpc05vZGVTZGsiLCJpc1NhZmFyaSIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiaXNJbmRleGVkREJBdmFpbGFibGUiLCJpbmRleGVkREIiLCJ2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIiwicHJlRXhpc3QiLCJEQl9DSEVDS19OQU1FIiwicmVxdWVzdCIsIm9wZW4iLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJjbG9zZSIsImRlbGV0ZURhdGFiYXNlIiwib251cGdyYWRlbmVlZGVkIiwib25lcnJvciIsImFyZUNvb2tpZXNFbmFibGVkIiwiY29va2llRW5hYmxlZCIsIkVSUk9SX05BTUUiLCJGaXJlYmFzZUVycm9yIiwiY29kZSIsImN1c3RvbURhdGEiLCJzZXRQcm90b3R5cGVPZiIsImNhcHR1cmVTdGFja1RyYWNlIiwiRXJyb3JGYWN0b3J5IiwiY3JlYXRlIiwic2VydmljZSIsInNlcnZpY2VOYW1lIiwiZXJyb3JzIiwiZGF0YSIsImZ1bGxDb2RlIiwidGVtcGxhdGUiLCJyZXBsYWNlVGVtcGxhdGUiLCJmdWxsTWVzc2FnZSIsIlBBVFRFUk4iLCJfIiwianNvbkV2YWwiLCJkZWNvZGUiLCJjbGFpbXMiLCJwYXJ0cyIsInNwbGl0IiwiaXNWYWxpZFRpbWVzdGFtcCIsIm5vdyIsIk1hdGgiLCJmbG9vciIsInZhbGlkU2luY2UiLCJ2YWxpZFVudGlsIiwiaXNzdWVkQXRUaW1lIiwiaXNWYWxpZEZvcm1hdCIsImlzQWRtaW4iLCJjb250YWlucyIsIm9iaiIsInNhZmVHZXQiLCJpc0VtcHR5IiwibWFwIiwiZm4iLCJjb250ZXh0T2JqIiwicmVzIiwiZGVlcEVxdWFsIiwiYSIsImIiLCJhS2V5cyIsImtleXMiLCJiS2V5cyIsImsiLCJhUHJvcCIsImJQcm9wIiwiaXNPYmplY3QiLCJ0aGluZyIsInByb21pc2VXaXRoVGltZW91dCIsInRpbWVJbk1TIiwiZGVmZXJyZWRQcm9taXNlIiwic2V0VGltZW91dCIsInRoZW4iLCJxdWVyeXN0cmluZyIsInF1ZXJ5c3RyaW5nUGFyYW1zIiwicGFyYW1zIiwiZW50cmllcyIsImZvckVhY2giLCJhcnJheVZhbCIsImVuY29kZVVSSUNvbXBvbmVudCIsInF1ZXJ5c3RyaW5nRGVjb2RlIiwidG9rZW5zIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXh0cmFjdFF1ZXJ5c3RyaW5nIiwidXJsIiwicXVlcnlTdGFydCIsImZyYWdtZW50U3RhcnQiLCJTaGExIiwiY2hhaW5fIiwiYnVmXyIsIldfIiwicGFkXyIsImluYnVmXyIsInRvdGFsXyIsImJsb2NrU2l6ZSIsInJlc2V0IiwiY29tcHJlc3NfIiwiYnVmIiwib2Zmc2V0IiwiVyIsInQiLCJkIiwiZiIsInVwZGF0ZSIsImxlbmd0aE1pbnVzQmxvY2siLCJuIiwiaW5idWYiLCJkaWdlc3QiLCJ0b3RhbEJpdHMiLCJqIiwiY3JlYXRlU3Vic2NyaWJlIiwiZXhlY3V0b3IiLCJvbk5vT2JzZXJ2ZXJzIiwicHJveHkiLCJPYnNlcnZlclByb3h5Iiwic3Vic2NyaWJlIiwiYmluZCIsIm9ic2VydmVycyIsInVuc3Vic2NyaWJlcyIsIm9ic2VydmVyQ291bnQiLCJ0YXNrIiwiZmluYWxpemVkIiwibmV4dCIsImZvckVhY2hPYnNlcnZlciIsIm9ic2VydmVyIiwiY29tcGxldGUiLCJuZXh0T3JPYnNlcnZlciIsImltcGxlbWVudHNBbnlNZXRob2RzIiwibm9vcCIsInVuc3ViIiwidW5zdWJzY3JpYmVPbmUiLCJmaW5hbEVycm9yIiwic2VuZE9uZSIsImVyciIsImFzeW5jIiwib25FcnJvciIsImFyZ3MiLCJtZXRob2RzIiwibWV0aG9kIiwidmFsaWRhdGVBcmdDb3VudCIsImZuTmFtZSIsIm1pbkNvdW50IiwibWF4Q291bnQiLCJhcmdDb3VudCIsImFyZ0Vycm9yIiwiZXJyb3JQcmVmaXgiLCJhcmdOYW1lIiwidmFsaWRhdGVOYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJvcHRpb25hbCIsInZhbGlkYXRlQ2FsbGJhY2siLCJhcmd1bWVudE5hbWUiLCJ2YWxpZGF0ZUNvbnRleHRPYmplY3QiLCJjb250ZXh0Iiwic3RyaW5nVG9CeXRlQXJyYXkiLCJoaWdoIiwibG93Iiwic3RyaW5nTGVuZ3RoIiwidXVpZHY0IiwiciIsInJhbmRvbSIsInYiLCJERUZBVUxUX0lOVEVSVkFMX01JTExJUyIsIkRFRkFVTFRfQkFDS09GRl9GQUNUT1IiLCJNQVhfVkFMVUVfTUlMTElTIiwiUkFORE9NX0ZBQ1RPUiIsImNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMiLCJiYWNrb2ZmQ291bnQiLCJpbnRlcnZhbE1pbGxpcyIsImJhY2tvZmZGYWN0b3IiLCJjdXJyQmFzZVZhbHVlIiwicG93IiwicmFuZG9tV2FpdCIsInJvdW5kIiwibWluIiwib3JkaW5hbCIsIk51bWJlciIsImlzRmluaXRlIiwiaW5kaWNhdG9yIiwiYWJzIiwiY2VudCIsImRlYyIsImdldE1vZHVsYXJJbnN0YW5jZSIsIl9kZWxlZ2F0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;